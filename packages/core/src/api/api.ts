/* eslint-disable */
// @ts-nocheck
/**
 * Lab surveillance platform
 * Lab surveillance platform API
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: ids-bioinformatics@rivm.nl
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @ {string}
 */

export const AuthProtocol = {
    OAUTH2: 'OAUTH2',
    OIDC: 'OIDC'
} as const;

export type AuthProtocol = typeof AuthProtocol[keyof typeof AuthProtocol];


/**
 * 
 * @export
 * @ {string}
 */

export const BooleanOperator = {
    AND: 'AND',
    OR: 'OR',
    NOT: 'NOT',
    XOR: 'XOR',
    NAND: 'NAND',
    NOR: 'NOR',
    XNOR: 'XNOR',
    IMPLIES: 'IMPLIES',
    NIMPLIES: 'NIMPLIES'
} as const;

export type BooleanOperator = typeof BooleanOperator[keyof typeof BooleanOperator];


/**
 * A class representing a case.
 * @export
 * @interface Case
 */
export interface Case {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof Case
     */
    'id'?: string | null;
    /**
     * The ID of the case type. FOREIGN KEY
     * @type {string}
     * @memberof Case
     */
    'case_type_id': string;
    /**
     * 
     * @type {CaseType}
     * @memberof Case
     */
    'case_type'?: CaseType;
    /**
     * The ID of the subject. FOREIGN KEY
     * @type {string}
     * @memberof Case
     */
    'subject_id'?: string | null;
    /**
     * 
     * @type {Subject}
     * @memberof Case
     */
    'subject'?: Subject;
    /**
     * The ID of the data collection where the case was created. FOREIGN KEY
     * @type {string}
     * @memberof Case
     */
    'created_in_data_collection_id': string;
    /**
     * 
     * @type {DataCollection}
     * @memberof Case
     */
    'created_in_data_collection'?: DataCollection;
    /**
     * The number of cases, if applicable
     * @type {number}
     * @memberof Case
     */
    'count'?: number | null;
    /**
     * The date of the case
     * @type {string}
     * @memberof Case
     */
    'case_date': string;
    /**
     * The column data of the case as {col_id: str_value}
     * @type {{ [key: string]: string; }}
     * @memberof Case
     */
    'content': { [key: string]: string; };
}
/**
 * 
 * @export
 * @ {string}
 */

export const CaseClassification = {
    POSSIBLE: 'POSSIBLE',
    PROBABLE: 'PROBABLE',
    CONFIRMED: 'CONFIRMED'
} as const;

export type CaseClassification = typeof CaseClassification[keyof typeof CaseClassification];


/**
 * 
 * @export
 * @interface CaseDataCollectionLink
 */
export interface CaseDataCollectionLink {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof CaseDataCollectionLink
     */
    'id'?: string | null;
    /**
     * The ID of the case. FOREIGN KEY
     * @type {string}
     * @memberof CaseDataCollectionLink
     */
    'case_id': string;
    /**
     * 
     * @type {Case}
     * @memberof CaseDataCollectionLink
     */
    'case'?: Case;
    /**
     * The ID of the data collection. FOREIGN KEY
     * @type {string}
     * @memberof CaseDataCollectionLink
     */
    'data_collection_id': string;
    /**
     * 
     * @type {DataCollection}
     * @memberof CaseDataCollectionLink
     */
    'data_collection'?: DataCollection;
}
/**
 * 
 * @export
 * @interface CaseQuery
 */
export interface CaseQuery {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof CaseQuery
     */
    'id'?: string | null;
    /**
     * The label for the query.
     * @type {string}
     * @memberof CaseQuery
     */
    'label'?: string | null;
    /**
     * The IDs of the case type(s) that the case must belong to. Not applied if not provided.
     * @type {Array<string>}
     * @memberof CaseQuery
     */
    'case_type_ids'?: Array<string> | null;
    /**
     * The IDs of the case set(s) that the case must belong to. Not applied if not provided.
     * @type {Array<string>}
     * @memberof CaseQuery
     */
    'case_set_ids'?: Array<string> | null;
    /**
     * 
     * @type {TypedDatetimeRangeFilter}
     * @memberof CaseQuery
     */
    'datetime_range_filter'?: TypedDatetimeRangeFilter;
    /**
     * 
     * @type {TypedCompositeFilter}
     * @memberof CaseQuery
     */
    'filter'?: TypedCompositeFilter;
}
/**
 * Describes all the rights that a user has on one particular case, based on the data collections in which it is currently shared.
 * @export
 * @interface CaseRights
 */
export interface CaseRights {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof CaseRights
     */
    'id'?: string | null;
    /**
     * The ID of the data collection where the item was created
     * @type {string}
     * @memberof CaseRights
     */
    'created_in_data_collection_id': string;
    /**
     * The ID of the case type
     * @type {string}
     * @memberof CaseRights
     */
    'case_type_id': string;
    /**
     * The IDs of the data collections in which the item is currently shared, including the created_in_data_collection_id
     * @type {Array<string>}
     * @memberof CaseRights
     */
    'data_collection_ids': Array<string>;
    /**
     * Whether the user has full access to the item, i.e. all rights on all data collections
     * @type {boolean}
     * @memberof CaseRights
     */
    'is_full_access': boolean;
    /**
     * The IDs of the data collections to which the item is allowed to be added
     * @type {Array<string>}
     * @memberof CaseRights
     */
    'add_data_collection_ids': Array<string>;
    /**
     * The IDs of the data collections from which the item is allowed to be removed. If remove_data_collection_ids is equal to data_collection_ids, the item is allowed to be deleted
     * @type {Array<string>}
     * @memberof CaseRights
     */
    'remove_data_collection_ids': Array<string>;
    /**
     * Whether the item can be deleted.
     * @type {boolean}
     * @memberof CaseRights
     */
    'can_delete': boolean;
    /**
     * The IDs of the data collections in which the item is currently shared, excluding the created_in_data_collection_id
     * @type {Array<string>}
     * @memberof CaseRights
     */
    'shared_in_data_collection_ids': Array<string>;
    /**
     * The ID of the case
     * @type {string}
     * @memberof CaseRights
     */
    'case_id': string;
    /**
     * The IDs of the case type columns that are allowed to be read for the case
     * @type {Array<string>}
     * @memberof CaseRights
     */
    'read_case_type_col_ids': Array<string>;
    /**
     * The IDs of the case type columns that are allowed to be written for the case
     * @type {Array<string>}
     * @memberof CaseRights
     */
    'write_case_type_col_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface CaseSet
 */
export interface CaseSet {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof CaseSet
     */
    'id'?: string | null;
    /**
     * The ID of the case type. FOREIGN KEY
     * @type {string}
     * @memberof CaseSet
     */
    'case_type_id': string;
    /**
     * 
     * @type {CaseType}
     * @memberof CaseSet
     */
    'case_type'?: CaseType;
    /**
     * The ID of the data collection where the case set was created. FOREIGN KEY
     * @type {string}
     * @memberof CaseSet
     */
    'created_in_data_collection_id': string;
    /**
     * 
     * @type {DataCollection}
     * @memberof CaseSet
     */
    'created_in_data_collection'?: DataCollection;
    /**
     * The name of a case set, UNIQUE
     * @type {string}
     * @memberof CaseSet
     */
    'name': string;
    /**
     * The description of a case set
     * @type {string}
     * @memberof CaseSet
     */
    'description': string;
    /**
     * The datetime of the case set creation
     * @type {string}
     * @memberof CaseSet
     */
    'created_at'?: string;
    /**
     * The id of the category of the case set
     * @type {string}
     * @memberof CaseSet
     */
    'case_set_category_id': string;
    /**
     * 
     * @type {CaseSetCategory}
     * @memberof CaseSet
     */
    'case_set_category'?: CaseSetCategory;
    /**
     * The id of the status of the case set
     * @type {string}
     * @memberof CaseSet
     */
    'case_set_status_id': string;
    /**
     * 
     * @type {CaseSetStatus}
     * @memberof CaseSet
     */
    'case_set_status'?: CaseSetStatus;
}
/**
 * 
 * @export
 * @interface CaseSetCategory
 */
export interface CaseSetCategory {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof CaseSetCategory
     */
    'id'?: string | null;
    /**
     * The name of the case set category, UNIQUE
     * @type {string}
     * @memberof CaseSetCategory
     */
    'name': string;
    /**
     * The description of the case set category
     * @type {string}
     * @memberof CaseSetCategory
     */
    'description': string | null;
}
/**
 * 
 * @export
 * @interface CaseSetDataCollectionLink
 */
export interface CaseSetDataCollectionLink {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof CaseSetDataCollectionLink
     */
    'id'?: string | null;
    /**
     * The ID of the case set. FOREIGN KEY
     * @type {string}
     * @memberof CaseSetDataCollectionLink
     */
    'case_set_id': string;
    /**
     * 
     * @type {CaseSet}
     * @memberof CaseSetDataCollectionLink
     */
    'case_set'?: CaseSet;
    /**
     * The ID of the data collection. FOREIGN KEY
     * @type {string}
     * @memberof CaseSetDataCollectionLink
     */
    'data_collection_id': string;
    /**
     * 
     * @type {DataCollection}
     * @memberof CaseSetDataCollectionLink
     */
    'data_collection'?: DataCollection;
}
/**
 * 
 * @export
 * @interface CaseSetMember
 */
export interface CaseSetMember {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof CaseSetMember
     */
    'id'?: string | null;
    /**
     * The ID of the case set. FOREIGN KEY
     * @type {string}
     * @memberof CaseSetMember
     */
    'case_set_id': string;
    /**
     * 
     * @type {CaseSet}
     * @memberof CaseSetMember
     */
    'case_set'?: CaseSet;
    /**
     * The ID of the case. FOREIGN KEY
     * @type {string}
     * @memberof CaseSetMember
     */
    'case_id': string;
    /**
     * 
     * @type {Case}
     * @memberof CaseSetMember
     */
    'case'?: Case;
    /**
     * 
     * @type {CaseClassification}
     * @memberof CaseSetMember
     */
    'classification'?: CaseClassification;
}


/**
 * Describes all the rights that a user has on one particular case set, based on the data collections in which it is currently shared.
 * @export
 * @interface CaseSetRights
 */
export interface CaseSetRights {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof CaseSetRights
     */
    'id'?: string | null;
    /**
     * The ID of the data collection where the item was created
     * @type {string}
     * @memberof CaseSetRights
     */
    'created_in_data_collection_id': string;
    /**
     * The ID of the case type
     * @type {string}
     * @memberof CaseSetRights
     */
    'case_type_id': string;
    /**
     * The IDs of the data collections in which the item is currently shared, including the created_in_data_collection_id
     * @type {Array<string>}
     * @memberof CaseSetRights
     */
    'data_collection_ids': Array<string>;
    /**
     * Whether the user has full access to the item, i.e. all rights on all data collections
     * @type {boolean}
     * @memberof CaseSetRights
     */
    'is_full_access': boolean;
    /**
     * The IDs of the data collections to which the item is allowed to be added
     * @type {Array<string>}
     * @memberof CaseSetRights
     */
    'add_data_collection_ids': Array<string>;
    /**
     * The IDs of the data collections from which the item is allowed to be removed. If remove_data_collection_ids is equal to data_collection_ids, the item is allowed to be deleted
     * @type {Array<string>}
     * @memberof CaseSetRights
     */
    'remove_data_collection_ids': Array<string>;
    /**
     * Whether the item can be deleted.
     * @type {boolean}
     * @memberof CaseSetRights
     */
    'can_delete': boolean;
    /**
     * The IDs of the data collections in which the item is currently shared, excluding the created_in_data_collection_id
     * @type {Array<string>}
     * @memberof CaseSetRights
     */
    'shared_in_data_collection_ids': Array<string>;
    /**
     * The ID of the case set
     * @type {string}
     * @memberof CaseSetRights
     */
    'case_set_id': string;
    /**
     * Whether the case set is allowed to be read
     * @type {boolean}
     * @memberof CaseSetRights
     */
    'read_case_set': boolean;
    /**
     * Whether the case set is allowed to be written
     * @type {boolean}
     * @memberof CaseSetRights
     */
    'write_case_set': boolean;
}
/**
 * 
 * @export
 * @interface CaseSetStat
 */
export interface CaseSetStat {
    /**
     * The ID of the case set.
     * @type {string}
     * @memberof CaseSetStat
     */
    'case_set_id': string;
    /**
     * The number of cases in the case set.
     * @type {number}
     * @memberof CaseSetStat
     */
    'n_cases'?: number | null;
    /**
     * The number of own cases in the case set.
     * @type {number}
     * @memberof CaseSetStat
     */
    'n_own_cases'?: number | null;
    /**
     * The ISO year and month of the first case.
     * @type {string}
     * @memberof CaseSetStat
     */
    'first_case_month'?: string | null;
    /**
     * The ISO year and month of the last case.
     * @type {string}
     * @memberof CaseSetStat
     */
    'last_case_month'?: string | null;
}
/**
 * 
 * @export
 * @interface CaseSetStatus
 */
export interface CaseSetStatus {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof CaseSetStatus
     */
    'id'?: string | null;
    /**
     * The name of the case set status, UNIQUE
     * @type {string}
     * @memberof CaseSetStatus
     */
    'name': string;
    /**
     * The description of the case set status
     * @type {string}
     * @memberof CaseSetStatus
     */
    'description': string | null;
}
/**
 * 
 * @export
 * @interface CaseType
 */
export interface CaseType {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof CaseType
     */
    'id'?: string | null;
    /**
     * The name of the case type
     * @type {string}
     * @memberof CaseType
     */
    'name': string;
    /**
     * The description of the case type
     * @type {string}
     * @memberof CaseType
     */
    'description'?: string | null;
    /**
     * The ID of the disease. FOREIGN KEY
     * @type {string}
     * @memberof CaseType
     */
    'disease_id'?: string | null;
    /**
     * 
     * @type {Disease}
     * @memberof CaseType
     */
    'disease'?: Disease;
    /**
     * The ID of the etiological agent. FOREIGN KEY
     * @type {string}
     * @memberof CaseType
     */
    'etiological_agent_id'?: string | null;
    /**
     * 
     * @type {EtiologicalAgent}
     * @memberof CaseType
     */
    'etiological_agent'?: EtiologicalAgent;
}
/**
 * 
 * @export
 * @interface CaseTypeAccessAbac
 */
export interface CaseTypeAccessAbac {
    /**
     * The ID of the case type
     * @type {string}
     * @memberof CaseTypeAccessAbac
     */
    'case_type_id': string;
    /**
     * The ID of the data collection
     * @type {string}
     * @memberof CaseTypeAccessAbac
     */
    'data_collection_id': string;
    /**
     * Whether the data collection is private, limited to the case types in the case type set. When true, add/remove case and add/remove case set are considered (i) as the right to create/delete a case or case set in this data collection (setting case.created_in_data_collection to this data collection) and (ii) as the right to share the case or case set further in other data collections. Deleting a case or case set is only allowed when it can or has been removed from all other data collections as well.
     * @type {boolean}
     * @memberof CaseTypeAccessAbac
     */
    'is_private': boolean;
    /**
     * Whether cases may be added, limited to the case type and data collection
     * @type {boolean}
     * @memberof CaseTypeAccessAbac
     */
    'add_case': boolean;
    /**
     * Whether cases may be removed, limited to the case type and data collection
     * @type {boolean}
     * @memberof CaseTypeAccessAbac
     */
    'remove_case': boolean;
    /**
     * Whether case sets may be added, limited to the case type and data collection
     * @type {boolean}
     * @memberof CaseTypeAccessAbac
     */
    'add_case_set': boolean;
    /**
     * Whether case sets may be removed, limited to the case type and data collection
     * @type {boolean}
     * @memberof CaseTypeAccessAbac
     */
    'remove_case_set': boolean;
    /**
     * The IDs of the case type columns for which values can be read, limited to the case type and data collection
     * @type {Array<string>}
     * @memberof CaseTypeAccessAbac
     */
    'read_case_type_col_ids': Array<string>;
    /**
     * The IDs of the case type columns for which values can be updated, limited to the case types in the case type set
     * @type {Array<string>}
     * @memberof CaseTypeAccessAbac
     */
    'write_case_type_col_ids': Array<string>;
    /**
     * Whether case set be read, limited to the case type and data collection
     * @type {boolean}
     * @memberof CaseTypeAccessAbac
     */
    'read_case_set': boolean;
    /**
     * Whether case set be updated, limited to the case type and data collection
     * @type {boolean}
     * @memberof CaseTypeAccessAbac
     */
    'write_case_set': boolean;
}
/**
 * 
 * @export
 * @interface CaseTypeCol
 */
export interface CaseTypeCol {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof CaseTypeCol
     */
    'id'?: string | null;
    /**
     * The ID of the case type. FOREIGN KEY
     * @type {string}
     * @memberof CaseTypeCol
     */
    'case_type_id': string;
    /**
     * 
     * @type {CaseType}
     * @memberof CaseTypeCol
     */
    'case_type'?: CaseType;
    /**
     * The ID of the column. FOREIGN KEY
     * @type {string}
     * @memberof CaseTypeCol
     */
    'col_id': string;
    /**
     * 
     * @type {Col}
     * @memberof CaseTypeCol
     */
    'col'?: Col;
    /**
     * The index of the occurrence of the column for this case type. E.g. for first and second vaccination date it would be 1 and 2. Empty or 1 if only a single occurrence.
     * @type {number}
     * @memberof CaseTypeCol
     */
    'occurrence'?: number | null;
    /**
     * The code for the case type column, equal to the column code and, if present, dot \'x\' occurrence. E.g. \'Host.Vaccination.Date.COVID19.x1\' for occurrence=1, \'Specimen.Sampling.Date\' for occurrence null
     * @type {string}
     * @memberof CaseTypeCol
     */
    'code': string;
    /**
     * The rank of the column for this case type for ordering, if different from the general dimension and column rank.
     * @type {number}
     * @memberof CaseTypeCol
     */
    'rank'?: number | null;
    /**
     * The label of the column for this case type, if different from the general column label.
     * @type {string}
     * @memberof CaseTypeCol
     */
    'label'?: string | null;
    /**
     * Description of the case type column.
     * @type {string}
     * @memberof CaseTypeCol
     */
    'description'?: string | null;
    /**
     * The minimum value for a numeric column
     * @type {number}
     * @memberof CaseTypeCol
     */
    'min_value'?: number | null;
    /**
     * The maximum value for a numeric column
     * @type {number}
     * @memberof CaseTypeCol
     */
    'max_value'?: number | null;
    /**
     * The minimum datetime for a time column
     * @type {string}
     * @memberof CaseTypeCol
     */
    'min_datetime'?: string | null;
    /**
     * The maximum datetime for a time column
     * @type {string}
     * @memberof CaseTypeCol
     */
    'max_datetime'?: string | null;
    /**
     * The minimum length for a text column, if not empty
     * @type {number}
     * @memberof CaseTypeCol
     */
    'min_length'?: number | null;
    /**
     * The maximum length for a text column, if not empty
     * @type {number}
     * @memberof CaseTypeCol
     */
    'max_length'?: number | null;
    /**
     * The regular expression for a text column, if not empty
     * @type {string}
     * @memberof CaseTypeCol
     */
    'pattern'?: string | null;
    /**
     * The NCBI taxid for the column, if the column is a genetic sequence
     * @type {string}
     * @memberof CaseTypeCol
     */
    'ncbi_taxid'?: string | null;
    /**
     * The ID of the genetic sequence case type column, if this is a genetic sequence column. FOREIGN KEY
     * @type {string}
     * @memberof CaseTypeCol
     */
    'genetic_sequence_case_type_col_id'?: string | null;
    /**
     * The set of tree algorithms that can be used for the case type column
     * @type {Array<TreeAlgorithmType>}
     * @memberof CaseTypeCol
     */
    'tree_algorithm_codes'?: Array<TreeAlgorithmType> | null;
    /**
     * Additional properties of the case type column.
     * @type {object}
     * @memberof CaseTypeCol
     */
    'props'?: object;
}
/**
 * 
 * @export
 * @interface CaseTypeColSet
 */
export interface CaseTypeColSet {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof CaseTypeColSet
     */
    'id'?: string | null;
    /**
     * The name of a case type column set, UNIQUE
     * @type {string}
     * @memberof CaseTypeColSet
     */
    'name': string;
    /**
     * The description of the case type column set
     * @type {string}
     * @memberof CaseTypeColSet
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface CaseTypeColSetMember
 */
export interface CaseTypeColSetMember {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof CaseTypeColSetMember
     */
    'id'?: string | null;
    /**
     * The ID of the case type column set. FOREIGN KEY
     * @type {string}
     * @memberof CaseTypeColSetMember
     */
    'case_type_col_set_id': string;
    /**
     * 
     * @type {CaseTypeColSet}
     * @memberof CaseTypeColSetMember
     */
    'case_type_col_set'?: CaseTypeColSet;
    /**
     * The ID of the case type column. FOREIGN KEY
     * @type {string}
     * @memberof CaseTypeColSetMember
     */
    'case_type_col_id': string;
    /**
     * 
     * @type {CaseTypeCol}
     * @memberof CaseTypeColSetMember
     */
    'case_type_col'?: CaseTypeCol;
}
/**
 * 
 * @export
 * @interface CaseTypeDim
 */
export interface CaseTypeDim {
    /**
     * The ID of the first case type column.
     * @type {string}
     * @memberof CaseTypeDim
     */
    'id': string;
    /**
     * The ID of the dimension. FOREIGN KEY
     * @type {string}
     * @memberof CaseTypeDim
     */
    'dim_id': string;
    /**
     * The index of the occurrence of the dimension for this case type. E.g. for first and second vaccination time it would be 1 and 2. Empty if only a single occurrence.
     * @type {number}
     * @memberof CaseTypeDim
     */
    'occurrence'?: number | null;
    /**
     * The rank of the case type dimension for ordering
     * @type {number}
     * @memberof CaseTypeDim
     */
    'rank'?: number;
    /**
     * The order of the case type columns
     * @type {Array<string>}
     * @memberof CaseTypeDim
     */
    'case_type_col_order': Array<string>;
}
/**
 * 
 * @export
 * @interface CaseTypeSet
 */
export interface CaseTypeSet {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof CaseTypeSet
     */
    'id'?: string | null;
    /**
     * The name of the case type set
     * @type {string}
     * @memberof CaseTypeSet
     */
    'name': string;
    /**
     * The description of the case type set
     * @type {string}
     * @memberof CaseTypeSet
     */
    'description'?: string | null;
    /**
     * The id of the category of the case type set. FOREIGN KEY
     * @type {string}
     * @memberof CaseTypeSet
     */
    'case_type_set_category_id': string;
    /**
     * 
     * @type {CaseTypeSetCategory}
     * @memberof CaseTypeSet
     */
    'case_type_set_category'?: CaseTypeSetCategory;
    /**
     * The rank of the case type set, establishing a partial order
     * @type {number}
     * @memberof CaseTypeSet
     */
    'rank': number;
}
/**
 * 
 * @export
 * @interface CaseTypeSetCategory
 */
export interface CaseTypeSetCategory {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof CaseTypeSetCategory
     */
    'id'?: string | null;
    /**
     * The name of the case type set category
     * @type {string}
     * @memberof CaseTypeSetCategory
     */
    'name': string;
    /**
     * The description of the case type set category
     * @type {string}
     * @memberof CaseTypeSetCategory
     */
    'description'?: string | null;
    /**
     * The rank of the case type set category
     * @type {number}
     * @memberof CaseTypeSetCategory
     */
    'rank': number;
    /**
     * 
     * @type {CaseTypeSetCategoryPurpose}
     * @memberof CaseTypeSetCategory
     */
    'purpose'?: CaseTypeSetCategoryPurpose;
}


/**
 * 
 * @export
 * @ {string}
 */

export const CaseTypeSetCategoryPurpose = {
    CONTENT: 'CONTENT',
    SECURITY: 'SECURITY'
} as const;

export type CaseTypeSetCategoryPurpose = typeof CaseTypeSetCategoryPurpose[keyof typeof CaseTypeSetCategoryPurpose];


/**
 * 
 * @export
 * @interface CaseTypeSetMember
 */
export interface CaseTypeSetMember {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof CaseTypeSetMember
     */
    'id'?: string | null;
    /**
     * The ID of the case type set. FOREIGN KEY
     * @type {string}
     * @memberof CaseTypeSetMember
     */
    'case_type_set_id': string;
    /**
     * 
     * @type {CaseTypeSet}
     * @memberof CaseTypeSetMember
     */
    'case_type_set'?: CaseTypeSet;
    /**
     * The ID of the case type. FOREIGN KEY
     * @type {string}
     * @memberof CaseTypeSetMember
     */
    'case_type_id': string;
    /**
     * 
     * @type {CaseType}
     * @memberof CaseTypeSetMember
     */
    'case_type'?: CaseType;
}
/**
 * 
 * @export
 * @interface CaseTypeShareAbac
 */
export interface CaseTypeShareAbac {
    /**
     * The ID of the case type
     * @type {string}
     * @memberof CaseTypeShareAbac
     */
    'case_type_id': string;
    /**
     * The ID of the data collection
     * @type {string}
     * @memberof CaseTypeShareAbac
     */
    'data_collection_id': string;
    /**
     * The IDs of the data collections from which cases may be added to this data collection, limited to the case type
     * @type {Array<string>}
     * @memberof CaseTypeShareAbac
     */
    'add_case_from_data_collection_ids': Array<string>;
    /**
     * The IDs of the data collections from which cases may be removed from this data collection, limited to the case type
     * @type {Array<string>}
     * @memberof CaseTypeShareAbac
     */
    'remove_case_from_data_collection_ids': Array<string>;
    /**
     * The IDs of the data collections from which case sets may be added to this data collection, limited to the case type
     * @type {Array<string>}
     * @memberof CaseTypeShareAbac
     */
    'add_case_set_from_data_collection_ids': Array<string>;
    /**
     * The IDs of the data collections from which case sets may be removed from this data collection, limited to the case type
     * @type {Array<string>}
     * @memberof CaseTypeShareAbac
     */
    'remove_case_set_from_data_collection_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface CaseTypeStat
 */
export interface CaseTypeStat {
    /**
     * The ID of the case type.
     * @type {string}
     * @memberof CaseTypeStat
     */
    'case_type_id': string;
    /**
     * The number of cases for the case type.
     * @type {number}
     * @memberof CaseTypeStat
     */
    'n_cases'?: number | null;
    /**
     * The ISO year and month of the first case.
     * @type {string}
     * @memberof CaseTypeStat
     */
    'first_case_month'?: string | null;
    /**
     * The ISO year and month of the last case.
     * @type {string}
     * @memberof CaseTypeStat
     */
    'last_case_month'?: string | null;
}
/**
 * 
 * @export
 * @interface Col
 */
export interface Col {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof Col
     */
    'id'?: string | null;
    /**
     * The ID of the dimension. FOREIGN KEY
     * @type {string}
     * @memberof Col
     */
    'dim_id': string;
    /**
     * 
     * @type {Dim}
     * @memberof Col
     */
    'dim'?: Dim;
    /**
     * The code suffix for the column used to compose a full column code, if needed in addition to the dimension column code prefix. See code field.
     * @type {string}
     * @memberof Col
     */
    'code_suffix'?: string | null;
    /**
     * The code for the column, equal to the dimension column code prefix dot code_suffix (dot code_suffix only if the latter is not null).
     * @type {string}
     * @memberof Col
     */
    'code': string;
    /**
     * The rank of the column within the dimension, if relevant.
     * @type {number}
     * @memberof Col
     */
    'rank_in_dim'?: number | null;
    /**
     * The label for the column, if different from the code.
     * @type {string}
     * @memberof Col
     */
    'label'?: string | null;
    /**
     * 
     * @type {ColType}
     * @memberof Col
     */
    'col_type': ColType;
    /**
     * The ID of the concept set for the column in case of type NOMINAL, ORDINAL, INTERVAL. FOREIGN KEY
     * @type {string}
     * @memberof Col
     */
    'concept_set_id'?: string | null;
    /**
     * 
     * @type {ConceptSet}
     * @memberof Col
     */
    'concept_set'?: ConceptSet;
    /**
     * The ID of the region set for the column in case of type GEO. FOREIGN KEY
     * @type {string}
     * @memberof Col
     */
    'region_set_id'?: string | null;
    /**
     * 
     * @type {RegionSet}
     * @memberof Col
     */
    'region_set'?: RegionSet;
    /**
     * The ID of the genetic distance protocol that produces the input for the tree algorithm. FOREIGN KEY
     * @type {string}
     * @memberof Col
     */
    'genetic_distance_protocol_id'?: string | null;
    /**
     * 
     * @type {GeneticDistanceProtocol}
     * @memberof Col
     */
    'genetic_distance_protocol'?: GeneticDistanceProtocol;
    /**
     * Description of the column.
     * @type {string}
     * @memberof Col
     */
    'description'?: string | null;
    /**
     * Additional properties of the column.
     * @type {object}
     * @memberof Col
     */
    'props'?: object;
}


/**
 * 
 * @export
 * @ {string}
 */

export const ColType = {
    TEXT: 'TEXT',
    CONTEXT_FREE_GRAMMAR_JSON: 'CONTEXT_FREE_GRAMMAR_JSON',
    CONTEXT_FREE_GRAMMAR_XML: 'CONTEXT_FREE_GRAMMAR_XML',
    REGEX: 'REGEX',
    NOMINAL: 'NOMINAL',
    ORDINAL: 'ORDINAL',
    INTERVAL: 'INTERVAL',
    TIME_DAY: 'TIME_DAY',
    TIME_WEEK: 'TIME_WEEK',
    TIME_MONTH: 'TIME_MONTH',
    TIME_QUARTER: 'TIME_QUARTER',
    TIME_YEAR: 'TIME_YEAR',
    GEO_LATLON: 'GEO_LATLON',
    GEO_REGION: 'GEO_REGION',
    ID_DIRECT: 'ID_DIRECT',
    ID_PSEUDONYMISED: 'ID_PSEUDONYMISED',
    ID_ANONYMISED: 'ID_ANONYMISED',
    DECIMAL_0: 'DECIMAL_0',
    DECIMAL_1: 'DECIMAL_1',
    DECIMAL_2: 'DECIMAL_2',
    DECIMAL_3: 'DECIMAL_3',
    DECIMAL_4: 'DECIMAL_4',
    DECIMAL_5: 'DECIMAL_5',
    DECIMAL_6: 'DECIMAL_6',
    GENETIC_SEQUENCE: 'GENETIC_SEQUENCE',
    GENETIC_DISTANCE: 'GENETIC_DISTANCE',
    ORGANIZATION: 'ORGANIZATION',
    OTHER: 'OTHER'
} as const;

export type ColType = typeof ColType[keyof typeof ColType];


/**
 * 
 * @export
 * @ {string}
 */

export const CommandName = {
    UserShareCasePolicyCrudCommand: 'UserShareCasePolicyCrudCommand',
    RetrieveGeneticSequenceByCaseCommand: 'RetrieveGeneticSequenceByCaseCommand',
    DataCollectionCrudCommand: 'DataCollectionCrudCommand',
    RetrieveOrganizationContactCommand: 'RetrieveOrganizationContactCommand',
    IdentifierIssuerCrudCommand: 'IdentifierIssuerCrudCommand',
    CaseTypeCrudCommand: 'CaseTypeCrudCommand',
    CaseTypeColSetMemberCrudCommand: 'CaseTypeColSetMemberCrudCommand',
    RetrieveContainingRegionCommand: 'RetrieveContainingRegionCommand',
    OrganizationAdminPolicyCrudCommand: 'OrganizationAdminPolicyCrudCommand',
    CaseSetCreateCommand: 'CaseSetCreateCommand',
    DimCrudCommand: 'DimCrudCommand',
    TreeAlgorithmCrudCommand: 'TreeAlgorithmCrudCommand',
    DataCollectionSetDataCollectionUpdateAssociationCommand: 'DataCollectionSetDataCollectionUpdateAssociationCommand',
    RetrieveAlleleProfileCommand: 'RetrieveAlleleProfileCommand',
    RetrieveCaseSetStatsCommand: 'RetrieveCaseSetStatsCommand',
    CaseTypeColSetCrudCommand: 'CaseTypeColSetCrudCommand',
    RegionSetCrudCommand: 'RegionSetCrudCommand',
    ConceptSetMemberCrudCommand: 'ConceptSetMemberCrudCommand',
    SiteCrudCommand: 'SiteCrudCommand',
    ConceptCrudCommand: 'ConceptCrudCommand',
    CaseTypeSetCaseTypeUpdateAssociationCommand: 'CaseTypeSetCaseTypeUpdateAssociationCommand',
    OrganizationShareCasePolicyCrudCommand: 'OrganizationShareCasePolicyCrudCommand',
    DiseaseCrudCommand: 'DiseaseCrudCommand',
    DataCollectionSetMemberCrudCommand: 'DataCollectionSetMemberCrudCommand',
    OrganizationAccessCasePolicyCrudCommand: 'OrganizationAccessCasePolicyCrudCommand',
    RetrieveCompleteCaseTypeCommand: 'RetrieveCompleteCaseTypeCommand',
    CaseTypeColSetCaseTypeColUpdateAssociationCommand: 'CaseTypeColSetCaseTypeColUpdateAssociationCommand',
    RetrieveCaseRightsCommand: 'RetrieveCaseRightsCommand',
    CaseCrudCommand: 'CaseCrudCommand',
    RetrieveOutagesCommand: 'RetrieveOutagesCommand',
    RegisterInvitedUserCommand: 'RegisterInvitedUserCommand',
    CaseTypeSetCrudCommand: 'CaseTypeSetCrudCommand',
    OrganizationSetOrganizationUpdateAssociationCommand: 'OrganizationSetOrganizationUpdateAssociationCommand',
    CaseSetCategoryCrudCommand: 'CaseSetCategoryCrudCommand',
    TreeAlgorithmClassCrudCommand: 'TreeAlgorithmClassCrudCommand',
    DataCollectionSetCrudCommand: 'DataCollectionSetCrudCommand',
    UpdateUserOwnOrganizationCommand: 'UpdateUserOwnOrganizationCommand',
    RetrieveCaseSetRightsCommand: 'RetrieveCaseSetRightsCommand',
    ConceptSetCrudCommand: 'ConceptSetCrudCommand',
    RetrieveGeneticSequenceByIdCommand: 'RetrieveGeneticSequenceByIdCommand',
    RetrieveCasesByIdCommand: 'RetrieveCasesByIdCommand',
    OrganizationSetMemberCrudCommand: 'OrganizationSetMemberCrudCommand',
    CaseSetMemberCrudCommand: 'CaseSetMemberCrudCommand',
    RegionCrudCommand: 'RegionCrudCommand',
    RetrieveCompleteUserCommand: 'RetrieveCompleteUserCommand',
    UserCrudCommand: 'UserCrudCommand',
    SubjectIdentifierCrudCommand: 'SubjectIdentifierCrudCommand',
    CaseTypeColCrudCommand: 'CaseTypeColCrudCommand',
    RetrieveCaseTypeStatsCommand: 'RetrieveCaseTypeStatsCommand',
    CaseSetCrudCommand: 'CaseSetCrudCommand',
    CaseSetDataCollectionLinkCrudCommand: 'CaseSetDataCollectionLinkCrudCommand',
    CaseTypeSetCategoryCrudCommand: 'CaseTypeSetCategoryCrudCommand',
    RegionSetShapeCrudCommand: 'RegionSetShapeCrudCommand',
    RegionRelationCrudCommand: 'RegionRelationCrudCommand',
    GeneticDistanceProtocolCrudCommand: 'GeneticDistanceProtocolCrudCommand',
    UserInvitationCrudCommand: 'UserInvitationCrudCommand',
    EtiologicalAgentCrudCommand: 'EtiologicalAgentCrudCommand',
    DiseaseEtiologicalAgentUpdateAssociationCommand: 'DiseaseEtiologicalAgentUpdateAssociationCommand',
    EtiologyCrudCommand: 'EtiologyCrudCommand',
    RetrievePhylogeneticTreeBySequencesCommand: 'RetrievePhylogeneticTreeBySequencesCommand',
    RetrieveCasesByQueryCommand: 'RetrieveCasesByQueryCommand',
    ContactCrudCommand: 'ContactCrudCommand',
    ConceptSetConceptUpdateAssociationCommand: 'ConceptSetConceptUpdateAssociationCommand',
    SubjectCrudCommand: 'SubjectCrudCommand',
    GetOwnPermissionsCommand: 'GetOwnPermissionsCommand',
    OrganizationCrudCommand: 'OrganizationCrudCommand',
    RetrieveOrganizationAdminNameEmailsCommand: 'RetrieveOrganizationAdminNameEmailsCommand',
    ColCrudCommand: 'ColCrudCommand',
    OutageCrudCommand: 'OutageCrudCommand',
    InviteUserCommand: 'InviteUserCommand',
    UpdateUserCommand: 'UpdateUserCommand',
    CaseTypeSetMemberCrudCommand: 'CaseTypeSetMemberCrudCommand',
    CaseSetStatusCrudCommand: 'CaseSetStatusCrudCommand',
    GetIdentityProvidersCommand: 'GetIdentityProvidersCommand',
    UserAccessCasePolicyCrudCommand: 'UserAccessCasePolicyCrudCommand',
    DataCollectionRelationCrudCommand: 'DataCollectionRelationCrudCommand',
    CaseDataCollectionLinkCrudCommand: 'CaseDataCollectionLinkCrudCommand',
    OrganizationSetCrudCommand: 'OrganizationSetCrudCommand',
    CasesCreateCommand: 'CasesCreateCommand',
    RetrievePhylogeneticTreeByCasesCommand: 'RetrievePhylogeneticTreeByCasesCommand'
} as const;

export type CommandName = typeof CommandName[keyof typeof CommandName];


/**
 * 
 * @export
 * @ {string}
 */

export const ComparisonOperator = {
    Less_Than: '<',
    Less_Than_Or_Equal_To: '<=',
    Equal: '=',
    Greater_Than_Or_Equal_To: '>=',
    Greater_Than: '>',
    Not_Equal: '!='
} as const;

export type ComparisonOperator = typeof ComparisonOperator[keyof typeof ComparisonOperator];


/**
 * 
 * @export
 * @interface CompleteCaseType
 */
export interface CompleteCaseType {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof CompleteCaseType
     */
    'id'?: string | null;
    /**
     * The name of the case type
     * @type {string}
     * @memberof CompleteCaseType
     */
    'name': string;
    /**
     * The description of the case type
     * @type {string}
     * @memberof CompleteCaseType
     */
    'description'?: string | null;
    /**
     * The ID of the disease. FOREIGN KEY
     * @type {string}
     * @memberof CompleteCaseType
     */
    'disease_id'?: string | null;
    /**
     * 
     * @type {Disease}
     * @memberof CompleteCaseType
     */
    'disease'?: Disease;
    /**
     * The ID of the etiological agent. FOREIGN KEY
     * @type {string}
     * @memberof CompleteCaseType
     */
    'etiological_agent_id'?: string | null;
    /**
     * 
     * @type {EtiologicalAgent}
     * @memberof CompleteCaseType
     */
    'etiological_agent'?: EtiologicalAgent;
    /**
     * The etiologies used by the case type
     * @type {{ [key: string]: Etiology; }}
     * @memberof CompleteCaseType
     */
    'etiologies': { [key: string]: Etiology; };
    /**
     * The etiological agents used by the case type
     * @type {{ [key: string]: EtiologicalAgent; }}
     * @memberof CompleteCaseType
     */
    'etiological_agents': { [key: string]: EtiologicalAgent; };
    /**
     * The dimensions used by the case type
     * @type {{ [key: string]: Dim; }}
     * @memberof CompleteCaseType
     */
    'dims': { [key: string]: Dim; };
    /**
     * The columns used by the case type
     * @type {{ [key: string]: Col; }}
     * @memberof CompleteCaseType
     */
    'cols': { [key: string]: Col; };
    /**
     * The ordered list of case type dimensions
     * @type {Array<CaseTypeDim>}
     * @memberof CompleteCaseType
     */
    'case_type_dims': Array<CaseTypeDim>;
    /**
     * The case type columns for the case type
     * @type {{ [key: string]: CaseTypeCol; }}
     * @memberof CompleteCaseType
     */
    'case_type_cols': { [key: string]: CaseTypeCol; };
    /**
     * The order of the case type columns outside the context of a dimension
     * @type {Array<string>}
     * @memberof CompleteCaseType
     */
    'case_type_col_order': Array<string>;
    /**
     * The genetic distance protocols used by the case type
     * @type {{ [key: string]: GeneticDistanceProtocol; }}
     * @memberof CompleteCaseType
     */
    'genetic_distance_protocols': { [key: string]: GeneticDistanceProtocol; };
    /**
     * The tree algorithms used by the case type
     * @type {{ [key: string]: TreeAlgorithm; }}
     * @memberof CompleteCaseType
     */
    'tree_algorithms': { [key: string]: TreeAlgorithm; };
    /**
     * The case type access ABAC object by data collection ID
     * @type {{ [key: string]: CaseTypeAccessAbac; }}
     * @memberof CompleteCaseType
     */
    'case_type_access_abacs': { [key: string]: CaseTypeAccessAbac; };
    /**
     * The case type share ABAC object by data collection ID
     * @type {{ [key: string]: CaseTypeShareAbac; }}
     * @memberof CompleteCaseType
     */
    'case_type_share_abacs': { [key: string]: CaseTypeShareAbac; };
}
/**
 * 
 * @export
 * @interface CompleteUser
 */
export interface CompleteUser {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof CompleteUser
     */
    'id'?: string | null;
    /**
     * The email of the user, UNIQUE
     * @type {string}
     * @memberof CompleteUser
     */
    'email': string;
    /**
     * The full name of the user
     * @type {string}
     * @memberof CompleteUser
     */
    'name'?: string | null;
    /**
     * Whether the user is active or not. An inactive user cannot perform any actions that require authorization.
     * @type {boolean}
     * @memberof CompleteUser
     */
    'is_active'?: boolean;
    /**
     * The ID of the organization of the user. FOREIGN KEY
     * @type {string}
     * @memberof CompleteUser
     */
    'organization_id': string;
    /**
     * 
     * @type {Organization}
     * @memberof CompleteUser
     */
    'organization': Organization;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof CompleteUser
     */
    'permissions': Array<Permission>;
    /**
     * 
     * @type {Array<Role>}
     * @memberof CompleteUser
     */
    'roles': Array<Role>;
}
/**
 * 
 * @export
 * @interface Concept
 */
export interface Concept {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof Concept
     */
    'id'?: string | null;
    /**
     * The abbreviation for the concept.
     * @type {string}
     * @memberof Concept
     */
    'abbreviation': string;
    /**
     * The name of the concept.
     * @type {string}
     * @memberof Concept
     */
    'name'?: string | null;
    /**
     * The description of the concept.
     * @type {string}
     * @memberof Concept
     */
    'description'?: string | null;
    /**
     * Additional properties of the concept.
     * @type {object}
     * @memberof Concept
     */
    'props'?: object;
}
/**
 * 
 * @export
 * @interface ConceptSet
 */
export interface ConceptSet {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof ConceptSet
     */
    'id'?: string | null;
    /**
     * The code of the concept set
     * @type {string}
     * @memberof ConceptSet
     */
    'code': string;
    /**
     * The name of the concept set
     * @type {string}
     * @memberof ConceptSet
     */
    'name': string;
    /**
     * 
     * @type {ConceptSetType}
     * @memberof ConceptSet
     */
    'type': ConceptSetType;
    /**
     * The regular expression describing the concept set, in case of type REGULAR_EXPRESSION
     * @type {string}
     * @memberof ConceptSet
     */
    'regex'?: string | null;
    /**
     * The definition of the schema describing the concept set, in case of type CONTEXT_FREE_GRAMMAR_XXX
     * @type {string}
     * @memberof ConceptSet
     */
    'schema_definition'?: string | null;
    /**
     * The URI to the schema describing the concept set, in case of type CONTEXT_FREE_GRAMMAR_XXX
     * @type {string}
     * @memberof ConceptSet
     */
    'schema_uri'?: string | null;
    /**
     * The description of the concept set.
     * @type {string}
     * @memberof ConceptSet
     */
    'description'?: string | null;
}


/**
 * 
 * @export
 * @interface ConceptSetMember
 */
export interface ConceptSetMember {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof ConceptSetMember
     */
    'id'?: string | null;
    /**
     * The ID of the concept set. FOREIGN KEY
     * @type {string}
     * @memberof ConceptSetMember
     */
    'concept_set_id': string;
    /**
     * 
     * @type {ConceptSet}
     * @memberof ConceptSetMember
     */
    'concept_set'?: ConceptSet;
    /**
     * The ID of the concept. FOREIGN KEY
     * @type {string}
     * @memberof ConceptSetMember
     */
    'concept_id': string;
    /**
     * 
     * @type {Concept}
     * @memberof ConceptSetMember
     */
    'concept'?: Concept;
    /**
     * The rank of the concept within the set, in case of an ORDINAL or INTERVAL concept set
     * @type {number}
     * @memberof ConceptSetMember
     */
    'rank'?: number | null;
}
/**
 * 
 * @export
 * @ {string}
 */

export const ConceptSetType = {
    CONTEXT_FREE_GRAMMAR_JSON: 'CONTEXT_FREE_GRAMMAR_JSON',
    CONTEXT_FREE_GRAMMAR_XML: 'CONTEXT_FREE_GRAMMAR_XML',
    REGULAR_LANGUAGE: 'REGULAR_LANGUAGE',
    NOMINAL: 'NOMINAL',
    ORDINAL: 'ORDINAL',
    INTERVAL: 'INTERVAL'
} as const;

export type ConceptSetType = typeof ConceptSetType[keyof typeof ConceptSetType];


/**
 * A class representing contact information for an organization.
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof Contact
     */
    'id'?: string | null;
    /**
     * The ID of the site in case the contact is site-specific. FOREIGN KEY
     * @type {string}
     * @memberof Contact
     */
    'site_id': string | null;
    /**
     * 
     * @type {Site}
     * @memberof Contact
     */
    'site'?: Site;
    /**
     * The name of the contact, UNIQUE
     * @type {string}
     * @memberof Contact
     */
    'name': string;
    /**
     * The email address of the contact
     * @type {string}
     * @memberof Contact
     */
    'email'?: string | null;
    /**
     * The phone number of the contact
     * @type {string}
     * @memberof Contact
     */
    'phone'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateCaseSetRequestBody
 */
export interface CreateCaseSetRequestBody {
    /**
     * 
     * @type {CaseSet}
     * @memberof CreateCaseSetRequestBody
     */
    'case_set': CaseSet;
    /**
     * The data collections in which the case set will be put initially
     * @type {Array<string>}
     * @memberof CreateCaseSetRequestBody
     */
    'data_collection_ids'?: Array<string>;
    /**
     * The cases to be added to the case set, if any.
     * @type {Array<string>}
     * @memberof CreateCaseSetRequestBody
     */
    'case_ids'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface CreateCasesRequestBody
 */
export interface CreateCasesRequestBody {
    /**
     * 
     * @type {Array<Case>}
     * @memberof CreateCasesRequestBody
     */
    'cases': Array<Case>;
    /**
     * The data collections in which the cases will be put initially
     * @type {Array<string>}
     * @memberof CreateCasesRequestBody
     */
    'data_collection_ids'?: Array<string>;
}
/**
 * Represents a collection of data.
 * @export
 * @interface DataCollection
 */
export interface DataCollection {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof DataCollection
     */
    'id'?: string | null;
    /**
     * The name of a data collection, UNIQUE
     * @type {string}
     * @memberof DataCollection
     */
    'name': string;
    /**
     * The description of the data collection.
     * @type {string}
     * @memberof DataCollection
     */
    'description'?: string | null;
}
/**
 * Represents a directional relationship between two data collections.
 * @export
 * @interface DataCollectionRelation
 */
export interface DataCollectionRelation {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof DataCollectionRelation
     */
    'id'?: string | null;
    /**
     * The ID of the data collection the relation originates from. FOREIGN KEY
     * @type {string}
     * @memberof DataCollectionRelation
     */
    'from_data_collection_id': string;
    /**
     * 
     * @type {DataCollection}
     * @memberof DataCollectionRelation
     */
    'from_data_collection'?: DataCollection;
    /**
     * The ID of the data collection the relation points to. FOREIGN KEY
     * @type {string}
     * @memberof DataCollectionRelation
     */
    'to_data_collection_id': string;
    /**
     * 
     * @type {DataCollection}
     * @memberof DataCollectionRelation
     */
    'to_data_collection'?: DataCollection;
    /**
     * Whether a case can be shared from one data collection to the other
     * @type {boolean}
     * @memberof DataCollectionRelation
     */
    'share_case': boolean;
}
/**
 * 
 * @export
 * @interface DataCollectionSet
 */
export interface DataCollectionSet {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof DataCollectionSet
     */
    'id'?: string | null;
    /**
     * The name of the data collection set
     * @type {string}
     * @memberof DataCollectionSet
     */
    'name': string;
    /**
     * The description of the data collection set.
     * @type {string}
     * @memberof DataCollectionSet
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface DataCollectionSetMember
 */
export interface DataCollectionSetMember {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof DataCollectionSetMember
     */
    'id'?: string | null;
    /**
     * The ID of the data collection set. FOREIGN KEY
     * @type {string}
     * @memberof DataCollectionSetMember
     */
    'data_collection_set_id': string;
    /**
     * 
     * @type {DataCollectionSet}
     * @memberof DataCollectionSetMember
     */
    'data_collection_set'?: DataCollectionSet;
    /**
     * The ID of the data collection. FOREIGN KEY
     * @type {string}
     * @memberof DataCollectionSetMember
     */
    'data_collection_id': string;
    /**
     * 
     * @type {DataCollection}
     * @memberof DataCollectionSetMember
     */
    'data_collection'?: DataCollection;
}
/**
 * @type Detail
 * @export
 */
export type Detail = object | string;

/**
 * 
 * @export
 * @interface Dim
 */
export interface Dim {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof Dim
     */
    'id'?: string | null;
    /**
     * 
     * @type {DimType}
     * @memberof Dim
     */
    'dim_type': DimType;
    /**
     * The code for the dimension.
     * @type {string}
     * @memberof Dim
     */
    'code': string;
    /**
     * The label for the dimension.
     * @type {string}
     * @memberof Dim
     */
    'label': string;
    /**
     * The rank of the dimension, if relevant.
     * @type {number}
     * @memberof Dim
     */
    'rank'?: number | null;
    /**
     * The column code prefix used to compose a full column code, if different from the code field.
     * @type {string}
     * @memberof Dim
     */
    'col_code_prefix'?: string | null;
    /**
     * Description of the dimension.
     * @type {string}
     * @memberof Dim
     */
    'description'?: string | null;
    /**
     * Additional properties of the dimension.
     * @type {object}
     * @memberof Dim
     */
    'props'?: object;
}


/**
 * 
 * @export
 * @ {string}
 */

export const DimType = {
    TEXT: 'TEXT',
    IDENTIFIER: 'IDENTIFIER',
    NUMBER: 'NUMBER',
    TIME: 'TIME',
    GEO: 'GEO',
    ORGANIZATION: 'ORGANIZATION',
    OTHER: 'OTHER'
} as const;

export type DimType = typeof DimType[keyof typeof DimType];


/**
 * 
 * @export
 * @interface Disease
 */
export interface Disease {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof Disease
     */
    'id'?: string | null;
    /**
     * The name of the disease
     * @type {string}
     * @memberof Disease
     */
    'name': string;
    /**
     * The ICD code of the disease, if available
     * @type {string}
     * @memberof Disease
     */
    'icd_code'?: string | null;
}
/**
 * 
 * @export
 * @interface EtiologicalAgent
 */
export interface EtiologicalAgent {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof EtiologicalAgent
     */
    'id'?: string | null;
    /**
     * The name of the etiological agent
     * @type {string}
     * @memberof EtiologicalAgent
     */
    'name': string;
    /**
     * The type of the etiological agent
     * @type {string}
     * @memberof EtiologicalAgent
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface Etiology
 */
export interface Etiology {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof Etiology
     */
    'id'?: string | null;
    /**
     * The ID of the disease. FOREIGN KEY
     * @type {string}
     * @memberof Etiology
     */
    'disease_id': string;
    /**
     * 
     * @type {Disease}
     * @memberof Etiology
     */
    'disease'?: Disease;
    /**
     * The ID of the etiological agent. FOREIGN KEY
     * @type {string}
     * @memberof Etiology
     */
    'etiological_agent_id': string;
    /**
     * 
     * @type {EtiologicalAgent}
     * @memberof Etiology
     */
    'etiological_agent'?: EtiologicalAgent;
}
/**
 * @type Filter
 * @export
 */
export type Filter = { type: 'COMPOSITE' } & TypedCompositeFilter | { type: 'DATETIME_RANGE' } & TypedDatetimeRangeFilter | { type: 'DATE_RANGE' } & TypedDateRangeFilter | { type: 'EQUALS_BOOLEAN' } & TypedEqualsBooleanFilter | { type: 'EQUALS_NUMBER' } & TypedEqualsNumberFilter | { type: 'EQUALS_STRING' } & TypedEqualsStringFilter | { type: 'EQUALS_UUID' } & TypedEqualsUuidFilter | { type: 'EXISTS' } & TypedExistsFilter | { type: 'NO_FILTER' } & TypedNoFilter | { type: 'NUMBER_RANGE' } & TypedNumberRangeFilter | { type: 'NUMBER_SET' } & TypedNumberSetFilter | { type: 'PARTIAL_DATE_RANGE' } & TypedPartialDateRangeFilter | { type: 'REGEX' } & TypedRegexFilter | { type: 'STRING_SET' } & TypedStringSetFilter | { type: 'UUID_SET' } & TypedUuidSetFilter;

/**
 * @type FiltersInner
 * @export
 */
export type FiltersInner = { type: 'COMPOSITE' } & TypedCompositeFilter | { type: 'DATETIME_RANGE' } & TypedDatetimeRangeFilter | { type: 'DATE_RANGE' } & TypedDateRangeFilter | { type: 'EQUALS_BOOLEAN' } & TypedEqualsBooleanFilter | { type: 'EQUALS_NUMBER' } & TypedEqualsNumberFilter | { type: 'EQUALS_STRING' } & TypedEqualsStringFilter | { type: 'EQUALS_UUID' } & TypedEqualsUuidFilter | { type: 'EXISTS' } & TypedExistsFilter | { type: 'NO_FILTER' } & TypedNoFilter | { type: 'NUMBER_RANGE' } & TypedNumberRangeFilter | { type: 'NUMBER_SET' } & TypedNumberSetFilter | { type: 'PARTIAL_DATE_RANGE' } & TypedPartialDateRangeFilter | { type: 'REGEX' } & TypedRegexFilter | { type: 'STRING_SET' } & TypedStringSetFilter | { type: 'UUID_SET' } & TypedUuidSetFilter;

/**
 * 
 * @export
 * @interface GeneticDistanceProtocol
 */
export interface GeneticDistanceProtocol {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof GeneticDistanceProtocol
     */
    'id'?: string | null;
    /**
     * The ID of the protocol in seqdb
     * @type {string}
     * @memberof GeneticDistanceProtocol
     */
    'seqdb_seq_distance_protocol_id': string;
    /**
     * The name of the protocol
     * @type {string}
     * @memberof GeneticDistanceProtocol
     */
    'name': string;
    /**
     * The description of the protocol
     * @type {string}
     * @memberof GeneticDistanceProtocol
     */
    'description'?: string | null;
    /**
     * The maximum distance that is stored in seqdb for this protocol
     * @type {number}
     * @memberof GeneticDistanceProtocol
     */
    'seqdb_max_stored_distance'?: number | null;
    /**
     * The minimum unit to be shown in a scale
     * @type {number}
     * @memberof GeneticDistanceProtocol
     */
    'min_scale_unit': number;
}
/**
 * A class representing a genetic sequence. Temporary implementation.
 * @export
 * @interface GeneticSequence
 */
export interface GeneticSequence {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof GeneticSequence
     */
    'id'?: string | null;
    /**
     * The nucleotide sequence
     * @type {string}
     * @memberof GeneticSequence
     */
    'nucleotide_sequence'?: string | null;
    /**
     * The distances to other sequences
     * @type {{ [key: string]: number; }}
     * @memberof GeneticSequence
     */
    'distances'?: { [key: string]: number; } | null;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface HealthReponseBody
 */
export interface HealthReponseBody {
    /**
     * 
     * @type {HealthStatus}
     * @memberof HealthReponseBody
     */
    'status': HealthStatus;
}


/**
 * 
 * @export
 * @ {string}
 */

export const HealthStatus = {
    HEALTHY: 'HEALTHY',
    UNHEALTHY: 'UNHEALTHY'
} as const;

export type HealthStatus = typeof HealthStatus[keyof typeof HealthStatus];


/**
 * A system or process that issues identifiers. The combination (identifier_issuer, issued_identifier) is universally unique.
 * @export
 * @interface IdentifierIssuer
 */
export interface IdentifierIssuer {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof IdentifierIssuer
     */
    'id'?: string | null;
    /**
     * The name of the issuer
     * @type {string}
     * @memberof IdentifierIssuer
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface IdentityProvider
 */
export interface IdentityProvider {
    /**
     * Name of the identity provider
     * @type {string}
     * @memberof IdentityProvider
     */
    'name': string;
    /**
     * Label of the identity provider
     * @type {string}
     * @memberof IdentityProvider
     */
    'label': string;
    /**
     * The issuer URL of the identity provider
     * @type {string}
     * @memberof IdentityProvider
     */
    'issuer': string;
    /**
     * 
     * @type {AuthProtocol}
     * @memberof IdentityProvider
     */
    'auth_protocol': AuthProtocol;
    /**
     * 
     * @type {OauthFlowType}
     * @memberof IdentityProvider
     */
    'oauth_flow'?: OauthFlowType;
    /**
     * The discovery URL of the identity provider
     * @type {string}
     * @memberof IdentityProvider
     */
    'discovery_url'?: string | null;
    /**
     * The client ID of the identity provider
     * @type {string}
     * @memberof IdentityProvider
     */
    'client_id'?: string | null;
    /**
     * The client secret of the identity provider
     * @type {string}
     * @memberof IdentityProvider
     */
    'client_secret'?: string | null;
    /**
     * The scope of the identity provider
     * @type {string}
     * @memberof IdentityProvider
     */
    'scope'?: string | null;
}


/**
 * @type LocationInner
 * @export
 */
export type LocationInner = number | string;

/**
 * 
 * @export
 * @interface LogItem
 */
export interface LogItem {
    /**
     * 
     * @type {LogLevel}
     * @memberof LogItem
     */
    'level': LogLevel;
    /**
     * 
     * @type {string}
     * @memberof LogItem
     */
    'command_id': string;
    /**
     * 
     * @type {string}
     * @memberof LogItem
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof LogItem
     */
    'duration'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof LogItem
     */
    'software_version': string;
    /**
     * 
     * @type {string}
     * @memberof LogItem
     */
    'topic': string;
    /**
     * 
     * @type {Detail}
     * @memberof LogItem
     */
    'detail'?: Detail | null;
}


/**
 * 
 * @export
 * @ {string}
 */

export const LogLevel = {
    FATAL: 'FATAL',
    ERROR: 'ERROR',
    WARN: 'WARN',
    INFO: 'INFO',
    DEBUG: 'DEBUG',
    TRACE: 'TRACE'
} as const;

export type LogLevel = typeof LogLevel[keyof typeof LogLevel];


/**
 * 
 * @export
 * @interface LogRequestBody
 */
export interface LogRequestBody {
    /**
     * 
     * @type {Array<LogItem>}
     * @memberof LogRequestBody
     */
    'log_items': Array<LogItem>;
}
/**
 * @type MembersInner
 * @export
 */
export type MembersInner = number | string;

/**
 * 
 * @export
 * @ {string}
 */

export const OauthFlowType = {
    AUTHORIZATION_CODE: 'AUTHORIZATION_CODE',
    CLIENT_CREDENTIALS: 'CLIENT_CREDENTIALS',
    RESOURCE_OWNER: 'RESOURCE_OWNER',
    HYBRID: 'HYBRID',
    DEVICE_AUTHORIZATION: 'DEVICE_AUTHORIZATION',
    PKCE: 'PKCE'
} as const;

export type OauthFlowType = typeof OauthFlowType[keyof typeof OauthFlowType];


/**
 * Represents an organization.
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof Organization
     */
    'id'?: string | null;
    /**
     * The name of the organization, UNIQUE
     * @type {string}
     * @memberof Organization
     */
    'name': string;
    /**
     * The legal entity code of the organization, UNIQUE
     * @type {string}
     * @memberof Organization
     */
    'legal_entity_code': string;
    /**
     * The ID of the region that the organization is legally responsible for. FOREIGN KEY
     * @type {string}
     * @memberof Organization
     */
    'legal_region_id'?: string | null;
    /**
     * 
     * @type {Region}
     * @memberof Organization
     */
    'legal_region'?: Region;
}
/**
 * Stores the access rights of an organization to a particular data collection. If an organization does not have a policy to a data collection, it has no access rights to that data collection.  The access rights are limited to the case types in the case type set. If a case type is not in the case type set, the organization has no access rights to that data collection for that case type.
 * @export
 * @interface OrganizationAccessCasePolicy
 */
export interface OrganizationAccessCasePolicy {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof OrganizationAccessCasePolicy
     */
    'id'?: string | null;
    /**
     * The ID of the data collection. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationAccessCasePolicy
     */
    'data_collection_id': string;
    /**
     * 
     * @type {DataCollection}
     * @memberof OrganizationAccessCasePolicy
     */
    'data_collection'?: DataCollection;
    /**
     * The ID of the case type set. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationAccessCasePolicy
     */
    'case_type_set_id': string;
    /**
     * 
     * @type {CaseTypeSet}
     * @memberof OrganizationAccessCasePolicy
     */
    'case_type_set'?: CaseTypeSet;
    /**
     * Whether the right is active
     * @type {boolean}
     * @memberof OrganizationAccessCasePolicy
     */
    'is_active': boolean;
    /**
     * Whether cases may be added to the data collection
     * @type {boolean}
     * @memberof OrganizationAccessCasePolicy
     */
    'add_case': boolean;
    /**
     * Whether cases may be removed from the data collection
     * @type {boolean}
     * @memberof OrganizationAccessCasePolicy
     */
    'remove_case': boolean;
    /**
     * Whether case sets may be added to the data collection
     * @type {boolean}
     * @memberof OrganizationAccessCasePolicy
     */
    'add_case_set': boolean;
    /**
     * Whether case sets may be removed from the data collection
     * @type {boolean}
     * @memberof OrganizationAccessCasePolicy
     */
    'remove_case_set': boolean;
    /**
     * The ID of the organization. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationAccessCasePolicy
     */
    'organization_id': string;
    /**
     * 
     * @type {Organization}
     * @memberof OrganizationAccessCasePolicy
     */
    'organization'?: Organization;
    /**
     * Whether the data collection is private, limited to the case types in the case type set. When true, add/remove case and add/remove case set are considered (i) as the right to create/delete a case or case set in this data collection (setting case.created_in_data_collection to this data collection) and (ii) as the right to share the case or case set further in other data collections. Deleting a case or case set is only allowed when it can or has been removed from all other data collections as well.
     * @type {boolean}
     * @memberof OrganizationAccessCasePolicy
     */
    'is_private': boolean;
    /**
     * The ID of the case type column set for which values can be read, limited to the case types in the case type set. If empty, there are no read rights. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationAccessCasePolicy
     */
    'read_case_type_col_set_id'?: string | null;
    /**
     * 
     * @type {CaseTypeColSet}
     * @memberof OrganizationAccessCasePolicy
     */
    'read_case_type_col_set'?: CaseTypeColSet;
    /**
     * The ID of the case type column set for which values can be updated, limited to the case types in the case type set.  If empty, there are no write rights. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationAccessCasePolicy
     */
    'write_case_type_col_set_id'?: string | null;
    /**
     * 
     * @type {CaseTypeColSet}
     * @memberof OrganizationAccessCasePolicy
     */
    'write_case_type_col_set'?: CaseTypeColSet;
    /**
     * Whether case set be read, limited to the case types in the case type set
     * @type {boolean}
     * @memberof OrganizationAccessCasePolicy
     */
    'read_case_set': boolean;
    /**
     * Whether case set be updated, limited to the case types in the case type set
     * @type {boolean}
     * @memberof OrganizationAccessCasePolicy
     */
    'write_case_set': boolean;
}
/**
 * 
 * @export
 * @interface OrganizationAdminPolicy
 */
export interface OrganizationAdminPolicy {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof OrganizationAdminPolicy
     */
    'id'?: string | null;
    /**
     * The ID of the organization. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationAdminPolicy
     */
    'organization_id': string;
    /**
     * 
     * @type {Organization}
     * @memberof OrganizationAdminPolicy
     */
    'organization'?: Organization;
    /**
     * The ID of the user. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationAdminPolicy
     */
    'user_id': string;
    /**
     * 
     * @type {User}
     * @memberof OrganizationAdminPolicy
     */
    'user'?: User;
    /**
     * Whether the user is an admin for the organization
     * @type {boolean}
     * @memberof OrganizationAdminPolicy
     */
    'is_active': boolean;
}
/**
 * 
 * @export
 * @interface OrganizationSet
 */
export interface OrganizationSet {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof OrganizationSet
     */
    'id'?: string | null;
    /**
     * The name of the organization set
     * @type {string}
     * @memberof OrganizationSet
     */
    'name': string;
    /**
     * The description of the organization set.
     * @type {string}
     * @memberof OrganizationSet
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface OrganizationSetMember
 */
export interface OrganizationSetMember {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof OrganizationSetMember
     */
    'id'?: string | null;
    /**
     * The ID of the organization set. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationSetMember
     */
    'organization_set_id': string;
    /**
     * 
     * @type {OrganizationSet}
     * @memberof OrganizationSetMember
     */
    'organization_set'?: OrganizationSet;
    /**
     * The ID of the organization. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationSetMember
     */
    'organization_id': string;
    /**
     * 
     * @type {Organization}
     * @memberof OrganizationSetMember
     */
    'organization'?: Organization;
}
/**
 * Stores any additional case or case set share rights of an organization to a particular data collection, if the case or case set is already in a particular other data collection.  The share rights are limited to the case types in the case type set. If a case type is not in the case type set, the organization has no share rights to that data collection for that case type.
 * @export
 * @interface OrganizationShareCasePolicy
 */
export interface OrganizationShareCasePolicy {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof OrganizationShareCasePolicy
     */
    'id'?: string | null;
    /**
     * The ID of the data collection. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationShareCasePolicy
     */
    'data_collection_id': string;
    /**
     * 
     * @type {DataCollection}
     * @memberof OrganizationShareCasePolicy
     */
    'data_collection'?: DataCollection;
    /**
     * The ID of the case type set. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationShareCasePolicy
     */
    'case_type_set_id': string;
    /**
     * 
     * @type {CaseTypeSet}
     * @memberof OrganizationShareCasePolicy
     */
    'case_type_set'?: CaseTypeSet;
    /**
     * Whether the right is active
     * @type {boolean}
     * @memberof OrganizationShareCasePolicy
     */
    'is_active': boolean;
    /**
     * Whether cases may be added to the data collection
     * @type {boolean}
     * @memberof OrganizationShareCasePolicy
     */
    'add_case': boolean;
    /**
     * Whether cases may be removed from the data collection
     * @type {boolean}
     * @memberof OrganizationShareCasePolicy
     */
    'remove_case': boolean;
    /**
     * Whether case sets may be added to the data collection
     * @type {boolean}
     * @memberof OrganizationShareCasePolicy
     */
    'add_case_set': boolean;
    /**
     * Whether case sets may be removed from the data collection
     * @type {boolean}
     * @memberof OrganizationShareCasePolicy
     */
    'remove_case_set': boolean;
    /**
     * The ID of the organization. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationShareCasePolicy
     */
    'organization_id': string;
    /**
     * 
     * @type {Organization}
     * @memberof OrganizationShareCasePolicy
     */
    'organization'?: Organization;
    /**
     * The ID of the data collection from which the case type set is shared. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationShareCasePolicy
     */
    'from_data_collection_id': string;
    /**
     * 
     * @type {DataCollection}
     * @memberof OrganizationShareCasePolicy
     */
    'from_data_collection'?: DataCollection;
}
/**
 * Represents a system outage.
 * @export
 * @interface Outage
 */
export interface Outage {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof Outage
     */
    'id'?: string | null;
    /**
     * Description of the system outage.
     * @type {string}
     * @memberof Outage
     */
    'description'?: string | null;
    /**
     * The date-time when the system outage starts.
     * @type {string}
     * @memberof Outage
     */
    'active_from'?: string | null;
    /**
     * The date-time when the system outage ends.
     * @type {string}
     * @memberof Outage
     */
    'active_to'?: string | null;
    /**
     * The date-time when the system outage is announced.
     * @type {string}
     * @memberof Outage
     */
    'visible_from'?: string | null;
    /**
     * The date-time when the system outage is no longer announced.
     * @type {string}
     * @memberof Outage
     */
    'visible_to'?: string | null;
    /**
     * Whether the system outage is currently active, this overrides active_from and active_to.
     * @type {boolean}
     * @memberof Outage
     */
    'is_active'?: boolean | null;
    /**
     * Whether the system outage is currently visible, this overrides visible_from and visible_to.
     * @type {boolean}
     * @memberof Outage
     */
    'is_visible'?: boolean | null;
}
/**
 * 
 * @export
 * @interface Permission
 */
export interface Permission {
    /**
     * 
     * @type {CommandName}
     * @memberof Permission
     */
    'command_name': CommandName;
    /**
     * 
     * @type {PermissionType}
     * @memberof Permission
     */
    'permission_type': PermissionType;
}


/**
 * 
 * @export
 * @ {string}
 */

export const PermissionType = {
    CREATE: 'CREATE',
    READ: 'READ',
    UPDATE: 'UPDATE',
    DELETE: 'DELETE',
    EXECUTE: 'EXECUTE'
} as const;

export type PermissionType = typeof PermissionType[keyof typeof PermissionType];


/**
 * 
 * @export
 * @interface PhylogeneticTree
 */
export interface PhylogeneticTree {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof PhylogeneticTree
     */
    'id'?: string | null;
    /**
     * The ID of the tree algorithm. FOREIGN KEY
     * @type {string}
     * @memberof PhylogeneticTree
     */
    'tree_algorithm_id'?: string | null;
    /**
     * 
     * @type {TreeAlgorithm}
     * @memberof PhylogeneticTree
     */
    'tree_algorithm'?: TreeAlgorithm;
    /**
     * 
     * @type {TreeAlgorithmType}
     * @memberof PhylogeneticTree
     */
    'tree_algorithm_code': TreeAlgorithmType;
    /**
     * The ID of the genetic distance protocol. FOREIGN KEY
     * @type {string}
     * @memberof PhylogeneticTree
     */
    'genetic_distance_protocol_id'?: string | null;
    /**
     * 
     * @type {GeneticDistanceProtocol}
     * @memberof PhylogeneticTree
     */
    'genetic_distance_protocol'?: GeneticDistanceProtocol;
    /**
     * The list of unique identifiers of the leaves of the phylogenetic tree.
     * @type {Array<string>}
     * @memberof PhylogeneticTree
     */
    'leaf_ids'?: Array<string> | null;
    /**
     * The list of unique identifiers of the sequence of each leaf of the phylogenetic tree.
     * @type {Array<string>}
     * @memberof PhylogeneticTree
     */
    'sequence_ids'?: Array<string> | null;
    /**
     * The Newick representation of the phylogenetic tree.
     * @type {string}
     * @memberof PhylogeneticTree
     */
    'newick_repr': string;
}


/**
 * 
 * @export
 * @interface Region
 */
export interface Region {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof Region
     */
    'id'?: string | null;
    /**
     * The ID of the region set. FOREIGN KEY
     * @type {string}
     * @memberof Region
     */
    'region_set_id': string;
    /**
     * 
     * @type {RegionSet}
     * @memberof Region
     */
    'region_set'?: RegionSet;
    /**
     * The code of the region.
     * @type {string}
     * @memberof Region
     */
    'code': string;
    /**
     * The name of the region.
     * @type {string}
     * @memberof Region
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof Region
     */
    'centroid_lat': number;
    /**
     * 
     * @type {number}
     * @memberof Region
     */
    'centroid_lon': number;
    /**
     * 
     * @type {number}
     * @memberof Region
     */
    'center_lat': number;
    /**
     * 
     * @type {number}
     * @memberof Region
     */
    'center_lon': number;
}
/**
 * 
 * @export
 * @interface RegionRelation
 */
export interface RegionRelation {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof RegionRelation
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RegionRelation
     */
    'from_region_id': string;
    /**
     * 
     * @type {Region}
     * @memberof RegionRelation
     */
    'from_region'?: Region;
    /**
     * 
     * @type {string}
     * @memberof RegionRelation
     */
    'to_region_id': string;
    /**
     * 
     * @type {Region}
     * @memberof RegionRelation
     */
    'to_region'?: Region;
    /**
     * 
     * @type {RegionRelationType}
     * @memberof RegionRelation
     */
    'relation': RegionRelationType;
}


/**
 * 
 * @export
 * @ {string}
 */

export const RegionRelationType = {
    IS_SEPARATE_FROM: 'IS_SEPARATE_FROM',
    IS_ADJACENT_TO: 'IS_ADJACENT_TO',
    IS_CONTAINED_IN: 'IS_CONTAINED_IN',
    OVERLAPS_WITH: 'OVERLAPS_WITH',
    CONTAINS: 'CONTAINS'
} as const;

export type RegionRelationType = typeof RegionRelationType[keyof typeof RegionRelationType];


/**
 * Set of regions that do not overlap geographically or otherwise did not exist at the same moment in time.
 * @export
 * @interface RegionSet
 */
export interface RegionSet {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof RegionSet
     */
    'id'?: string | null;
    /**
     * The code of the region set.
     * @type {string}
     * @memberof RegionSet
     */
    'code': string;
    /**
     * The name of the region set.
     * @type {string}
     * @memberof RegionSet
     */
    'name': string;
    /**
     * Whether the region\'s code should be used as the label. E.g. in case of postal code the code could be used instead of the name of the region.
     * @type {boolean}
     * @memberof RegionSet
     */
    'region_code_as_label': boolean;
}
/**
 * 
 * @export
 * @interface RegionSetShape
 */
export interface RegionSetShape {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof RegionSetShape
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RegionSetShape
     */
    'region_set_id': string;
    /**
     * 
     * @type {RegionSet}
     * @memberof RegionSetShape
     */
    'region_set'?: RegionSet;
    /**
     * 
     * @type {number}
     * @memberof RegionSetShape
     */
    'scale': number;
    /**
     * 
     * @type {string}
     * @memberof RegionSetShape
     */
    'geo_json': string;
}
/**
 * 
 * @export
 * @interface RetrieveCaseTypeStatsCommand
 */
export interface RetrieveCaseTypeStatsCommand {
    /**
     * The ID of the command
     * @type {string}
     * @memberof RetrieveCaseTypeStatsCommand
     */
    'id'?: string;
    /**
     * 
     * @type {User}
     * @memberof RetrieveCaseTypeStatsCommand
     */
    'user'?: User;
    /**
     * The created timestamp of the command
     * @type {string}
     * @memberof RetrieveCaseTypeStatsCommand
     */
    'created_at'?: string;
    /**
     * 
     * @type {object}
     * @memberof RetrieveCaseTypeStatsCommand
     */
    'props'?: object;
    /**
     * The case type ids to retrieve stats for, if not all.
     * @type {Array<string>}
     * @memberof RetrieveCaseTypeStatsCommand
     */
    'case_type_ids'?: Array<string> | null;
    /**
     * 
     * @type {TypedDatetimeRangeFilter}
     * @memberof RetrieveCaseTypeStatsCommand
     */
    'datetime_range_filter'?: TypedDatetimeRangeFilter;
}
/**
 * 
 * @export
 * @interface RetrieveGeneticSequenceRequestBody
 */
export interface RetrieveGeneticSequenceRequestBody {
    /**
     * 
     * @type {string}
     * @memberof RetrieveGeneticSequenceRequestBody
     */
    'genetic_sequence_case_type_col_id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RetrieveGeneticSequenceRequestBody
     */
    'case_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface RetrieveOrganizationContactRequestBody
 */
export interface RetrieveOrganizationContactRequestBody {
    /**
     * 
     * @type {Array<string>}
     * @memberof RetrieveOrganizationContactRequestBody
     */
    'organization_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof RetrieveOrganizationContactRequestBody
     */
    'site_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof RetrieveOrganizationContactRequestBody
     */
    'contact_ids'?: Array<string> | null;
    /**
     * 
     * @type {object}
     * @memberof RetrieveOrganizationContactRequestBody
     */
    'props'?: object;
}
/**
 * 
 * @export
 * @interface RetrievePhylogeneticTreeRequestBody
 */
export interface RetrievePhylogeneticTreeRequestBody {
    /**
     * 
     * @type {string}
     * @memberof RetrievePhylogeneticTreeRequestBody
     */
    'genetic_distance_case_type_col_id': string;
    /**
     * 
     * @type {TreeAlgorithmType}
     * @memberof RetrievePhylogeneticTreeRequestBody
     */
    'tree_algorithm_code': TreeAlgorithmType;
    /**
     * 
     * @type {Array<string>}
     * @memberof RetrievePhylogeneticTreeRequestBody
     */
    'case_ids': Array<string>;
}


/**
 * 
 * @export
 * @ {string}
 */

export const Role = {
    ROOT: 'ROOT',
    APP_ADMIN: 'APP_ADMIN',
    ORG_ADMIN: 'ORG_ADMIN',
    METADATA_ADMIN: 'METADATA_ADMIN',
    ORG_USER: 'ORG_USER',
    GUEST: 'GUEST',
    ROLE1: 'ROLE1'
} as const;

export type Role = typeof Role[keyof typeof Role];


/**
 * Represents a physical site of an organization.
 * @export
 * @interface Site
 */
export interface Site {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof Site
     */
    'id'?: string | null;
    /**
     * The ID of the organization. FOREIGN KEY
     * @type {string}
     * @memberof Site
     */
    'organization_id': string;
    /**
     * 
     * @type {Organization}
     * @memberof Site
     */
    'organization'?: Organization;
    /**
     * The name of an organization, UNIQUE
     * @type {string}
     * @memberof Site
     */
    'name': string;
    /**
     * The ID of the region within which the site is located. FOREIGN KEY
     * @type {string}
     * @memberof Site
     */
    'location_region_id': string;
    /**
     * 
     * @type {Region}
     * @memberof Site
     */
    'location_region'?: Region;
}
/**
 * Represents a person context bound to a particular data collection.
 * @export
 * @interface Subject
 */
export interface Subject {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof Subject
     */
    'id'?: string | null;
    /**
     * The ID of the data collection. FOREIGN KEY
     * @type {string}
     * @memberof Subject
     */
    'data_collection_id': string;
    /**
     * 
     * @type {DataCollection}
     * @memberof Subject
     */
    'data_collection'?: DataCollection;
    /**
     * A dictionary of external identifiers for the subject
     * @type {{ [key: string]: string; }}
     * @memberof Subject
     */
    'external_ids'?: { [key: string]: string; } | null;
    /**
     * A dictionary containing the content of the subject
     * @type {object}
     * @memberof Subject
     */
    'content': object;
}
/**
 * See https://en.wikipedia.org/wiki/Hierarchical_clustering, https://en.wikipedia.org/wiki/Neighbor_joining,  https://en.wikipedia.org/wiki/Computational_phylogenetics,  https://en.wikipedia.org/wiki/Spanning_tree
 * @export
 * @interface TreeAlgorithm
 */
export interface TreeAlgorithm {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof TreeAlgorithm
     */
    'id'?: string | null;
    /**
     * The ID of the tree algorithm class. FOREIGN KEY
     * @type {string}
     * @memberof TreeAlgorithm
     */
    'tree_algorithm_class_id': string;
    /**
     * 
     * @type {TreeAlgorithmClass}
     * @memberof TreeAlgorithm
     */
    'tree_algorithm_class'?: TreeAlgorithmClass;
    /**
     * The ID of the tree algorithm in seqdb
     * @type {string}
     * @memberof TreeAlgorithm
     */
    'seqdb_tree_algorithm_id': string;
    /**
     * 
     * @type {TreeAlgorithmType}
     * @memberof TreeAlgorithm
     */
    'code': TreeAlgorithmType;
    /**
     * The name of the tree algorithm
     * @type {string}
     * @memberof TreeAlgorithm
     */
    'name': string;
    /**
     * The description of the tree algorithm
     * @type {string}
     * @memberof TreeAlgorithm
     */
    'description'?: string | null;
    /**
     * Whether the tree is ultrametric
     * @type {boolean}
     * @memberof TreeAlgorithm
     */
    'is_ultrametric': boolean;
    /**
     * The rank of the tree algorithm, if relevant.
     * @type {number}
     * @memberof TreeAlgorithm
     */
    'rank'?: number | null;
}


/**
 * 
 * @export
 * @interface TreeAlgorithmClass
 */
export interface TreeAlgorithmClass {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof TreeAlgorithmClass
     */
    'id'?: string | null;
    /**
     * The code of the tree algorithm class
     * @type {string}
     * @memberof TreeAlgorithmClass
     */
    'code': string;
    /**
     * The name of the tree algorithm class
     * @type {string}
     * @memberof TreeAlgorithmClass
     */
    'name': string;
    /**
     * Whether the sequence or alignment is needed as input
     * @type {boolean}
     * @memberof TreeAlgorithmClass
     */
    'is_seq_based': boolean;
    /**
     * Whether the distance between sequences is needed as input
     * @type {boolean}
     * @memberof TreeAlgorithmClass
     */
    'is_dist_based': boolean;
    /**
     * The rank of the tree algorithm class, if relevant.
     * @type {number}
     * @memberof TreeAlgorithmClass
     */
    'rank'?: number | null;
}
/**
 * 
 * @export
 * @ {string}
 */

export const TreeAlgorithmType = {
    SLINK: 'SLINK',
    CLINK: 'CLINK',
    UPGMA: 'UPGMA',
    WPGMA: 'WPGMA',
    UPGMC: 'UPGMC',
    WPGMC: 'WPGMC',
    VERSATILE: 'VERSATILE',
    MISSQ: 'MISSQ',
    MNSSQ: 'MNSSQ',
    MIVAR: 'MIVAR',
    MNVAR: 'MNVAR',
    MINI_MAX: 'MINI_MAX',
    HAUSDORFF: 'HAUSDORFF',
    MIN_SUM_MEDOID: 'MIN_SUM_MEDOID',
    MIN_SUM_INCREASE_MEDOID: 'MIN_SUM_INCREASE_MEDOID',
    MEDOID: 'MEDOID',
    MIN_ENERGY: 'MIN_ENERGY',
    FITCH_MARGOLIASH: 'FITCH_MARGOLIASH',
    MAX_PARSIMONY: 'MAX_PARSIMONY',
    ML: 'ML',
    BAYESIAN_INFERENCE: 'BAYESIAN_INFERENCE',
    MIN_SPANNING: 'MIN_SPANNING',
    NJ: 'NJ'
} as const;

export type TreeAlgorithmType = typeof TreeAlgorithmType[keyof typeof TreeAlgorithmType];


/**
 * 
 * @export
 * @interface TypedCompositeFilter
 */
export interface TypedCompositeFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedCompositeFilter
     */
    'invert'?: boolean;
    /**
     * 
     * @type {Null}
     * @memberof TypedCompositeFilter
     */
    'key'?: Null;
    /**
     * The list of filters.
     * @type {Array<FiltersInner>}
     * @memberof TypedCompositeFilter
     */
    'filters': Array<FiltersInner>;
    /**
     * 
     * @type {BooleanOperator}
     * @memberof TypedCompositeFilter
     */
    'operator'?: BooleanOperator;
    /**
     * 
     * @type {string}
     * @memberof TypedCompositeFilter
     */
    'type': TypedCompositeFilterType;
}

export const TypedCompositeFilterType = {
    COMPOSITE: 'COMPOSITE'
} as const;

export type TypedCompositeFilterType = typeof TypedCompositeFilterType[keyof typeof TypedCompositeFilterType];

/**
 * 
 * @export
 * @interface TypedDateRangeFilter
 */
export interface TypedDateRangeFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedDateRangeFilter
     */
    'invert'?: boolean;
    /**
     * The column key to apply the filter to, when applied to a row. If None, the filter cannot be applied to a row, only to a column.
     * @type {string}
     * @memberof TypedDateRangeFilter
     */
    'key'?: string;
    /**
     * The lower bound of the range.
     * @type {string}
     * @memberof TypedDateRangeFilter
     */
    'lower_bound'?: string;
    /**
     * 
     * @type {ComparisonOperator}
     * @memberof TypedDateRangeFilter
     */
    'lower_bound_censor'?: ComparisonOperator;
    /**
     * The upper bound of the range.
     * @type {string}
     * @memberof TypedDateRangeFilter
     */
    'upper_bound'?: string;
    /**
     * 
     * @type {ComparisonOperator}
     * @memberof TypedDateRangeFilter
     */
    'upper_bound_censor'?: ComparisonOperator;
    /**
     * 
     * @type {string}
     * @memberof TypedDateRangeFilter
     */
    'type': TypedDateRangeFilterType;
}

export const TypedDateRangeFilterType = {
    DATE_RANGE: 'DATE_RANGE'
} as const;

export type TypedDateRangeFilterType = typeof TypedDateRangeFilterType[keyof typeof TypedDateRangeFilterType];

/**
 * 
 * @export
 * @interface TypedDatetimeRangeFilter
 */
export interface TypedDatetimeRangeFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedDatetimeRangeFilter
     */
    'invert'?: boolean;
    /**
     * The column key to apply the filter to, when applied to a row. If None, the filter cannot be applied to a row, only to a column.
     * @type {string}
     * @memberof TypedDatetimeRangeFilter
     */
    'key'?: string;
    /**
     * The lower bound of the range.
     * @type {string}
     * @memberof TypedDatetimeRangeFilter
     */
    'lower_bound'?: string;
    /**
     * 
     * @type {ComparisonOperator}
     * @memberof TypedDatetimeRangeFilter
     */
    'lower_bound_censor'?: ComparisonOperator;
    /**
     * The upper bound of the range.
     * @type {string}
     * @memberof TypedDatetimeRangeFilter
     */
    'upper_bound'?: string;
    /**
     * 
     * @type {ComparisonOperator}
     * @memberof TypedDatetimeRangeFilter
     */
    'upper_bound_censor'?: ComparisonOperator;
    /**
     * 
     * @type {string}
     * @memberof TypedDatetimeRangeFilter
     */
    'type': TypedDatetimeRangeFilterType;
}

export const TypedDatetimeRangeFilterType = {
    DATETIME_RANGE: 'DATETIME_RANGE'
} as const;

export type TypedDatetimeRangeFilterType = typeof TypedDatetimeRangeFilterType[keyof typeof TypedDatetimeRangeFilterType];

/**
 * 
 * @export
 * @interface TypedEqualsBooleanFilter
 */
export interface TypedEqualsBooleanFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedEqualsBooleanFilter
     */
    'invert'?: boolean;
    /**
     * The column key to apply the filter to, when applied to a row. If None, the filter cannot be applied to a row, only to a column.
     * @type {string}
     * @memberof TypedEqualsBooleanFilter
     */
    'key'?: string;
    /**
     * The boolean value to match.
     * @type {boolean}
     * @memberof TypedEqualsBooleanFilter
     */
    'value': boolean;
    /**
     * 
     * @type {string}
     * @memberof TypedEqualsBooleanFilter
     */
    'type': TypedEqualsBooleanFilterType;
}

export const TypedEqualsBooleanFilterType = {
    EQUALS_BOOLEAN: 'EQUALS_BOOLEAN'
} as const;

export type TypedEqualsBooleanFilterType = typeof TypedEqualsBooleanFilterType[keyof typeof TypedEqualsBooleanFilterType];

/**
 * 
 * @export
 * @interface TypedEqualsNumberFilter
 */
export interface TypedEqualsNumberFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedEqualsNumberFilter
     */
    'invert'?: boolean;
    /**
     * The column key to apply the filter to, when applied to a row. If None, the filter cannot be applied to a row, only to a column.
     * @type {string}
     * @memberof TypedEqualsNumberFilter
     */
    'key'?: string;
    /**
     * 
     * @type {Value}
     * @memberof TypedEqualsNumberFilter
     */
    'value': Value;
    /**
     * 
     * @type {string}
     * @memberof TypedEqualsNumberFilter
     */
    'type': TypedEqualsNumberFilterType;
}

export const TypedEqualsNumberFilterType = {
    EQUALS_NUMBER: 'EQUALS_NUMBER'
} as const;

export type TypedEqualsNumberFilterType = typeof TypedEqualsNumberFilterType[keyof typeof TypedEqualsNumberFilterType];

/**
 * 
 * @export
 * @interface TypedEqualsStringFilter
 */
export interface TypedEqualsStringFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedEqualsStringFilter
     */
    'invert'?: boolean;
    /**
     * The column key to apply the filter to, when applied to a row. If None, the filter cannot be applied to a row, only to a column.
     * @type {string}
     * @memberof TypedEqualsStringFilter
     */
    'key'?: string;
    /**
     * The string to match.
     * @type {string}
     * @memberof TypedEqualsStringFilter
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof TypedEqualsStringFilter
     */
    'type': TypedEqualsStringFilterType;
}

export const TypedEqualsStringFilterType = {
    EQUALS_STRING: 'EQUALS_STRING'
} as const;

export type TypedEqualsStringFilterType = typeof TypedEqualsStringFilterType[keyof typeof TypedEqualsStringFilterType];

/**
 * 
 * @export
 * @interface TypedEqualsUuidFilter
 */
export interface TypedEqualsUuidFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedEqualsUuidFilter
     */
    'invert'?: boolean;
    /**
     * The column key to apply the filter to, when applied to a row. If None, the filter cannot be applied to a row, only to a column.
     * @type {string}
     * @memberof TypedEqualsUuidFilter
     */
    'key'?: string;
    /**
     * The UUID to match.
     * @type {string}
     * @memberof TypedEqualsUuidFilter
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof TypedEqualsUuidFilter
     */
    'type': TypedEqualsUuidFilterType;
}

export const TypedEqualsUuidFilterType = {
    EQUALS_UUID: 'EQUALS_UUID'
} as const;

export type TypedEqualsUuidFilterType = typeof TypedEqualsUuidFilterType[keyof typeof TypedEqualsUuidFilterType];

/**
 * 
 * @export
 * @interface TypedExistsFilter
 */
export interface TypedExistsFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedExistsFilter
     */
    'invert'?: boolean;
    /**
     * The column key to apply the filter to, when applied to a row. If None, the filter cannot be applied to a row, only to a column.
     * @type {string}
     * @memberof TypedExistsFilter
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof TypedExistsFilter
     */
    'type': TypedExistsFilterType;
}

export const TypedExistsFilterType = {
    EXISTS: 'EXISTS'
} as const;

export type TypedExistsFilterType = typeof TypedExistsFilterType[keyof typeof TypedExistsFilterType];

/**
 * 
 * @export
 * @interface TypedNoFilter
 */
export interface TypedNoFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedNoFilter
     */
    'invert'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TypedNoFilter
     */
    'key'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TypedNoFilter
     */
    'type': TypedNoFilterType;
}

export const TypedNoFilterType = {
    NO_FILTER: 'NO_FILTER'
} as const;

export type TypedNoFilterType = typeof TypedNoFilterType[keyof typeof TypedNoFilterType];

/**
 * 
 * @export
 * @interface TypedNumberRangeFilter
 */
export interface TypedNumberRangeFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedNumberRangeFilter
     */
    'invert'?: boolean;
    /**
     * The column key to apply the filter to, when applied to a row. If None, the filter cannot be applied to a row, only to a column.
     * @type {string}
     * @memberof TypedNumberRangeFilter
     */
    'key'?: string;
    /**
     * The lower bound of the range.
     * @type {number}
     * @memberof TypedNumberRangeFilter
     */
    'lower_bound'?: number;
    /**
     * 
     * @type {ComparisonOperator}
     * @memberof TypedNumberRangeFilter
     */
    'lower_bound_censor'?: ComparisonOperator;
    /**
     * The upper bound of the range.
     * @type {number}
     * @memberof TypedNumberRangeFilter
     */
    'upper_bound'?: number;
    /**
     * 
     * @type {ComparisonOperator}
     * @memberof TypedNumberRangeFilter
     */
    'upper_bound_censor'?: ComparisonOperator;
    /**
     * 
     * @type {string}
     * @memberof TypedNumberRangeFilter
     */
    'type': TypedNumberRangeFilterType;
}

export const TypedNumberRangeFilterType = {
    NUMBER_RANGE: 'NUMBER_RANGE'
} as const;

export type TypedNumberRangeFilterType = typeof TypedNumberRangeFilterType[keyof typeof TypedNumberRangeFilterType];

/**
 * 
 * @export
 * @interface TypedNumberSetFilter
 */
export interface TypedNumberSetFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedNumberSetFilter
     */
    'invert'?: boolean;
    /**
     * The column key to apply the filter to, when applied to a row. If None, the filter cannot be applied to a row, only to a column.
     * @type {string}
     * @memberof TypedNumberSetFilter
     */
    'key'?: string;
    /**
     * The numbers to match.
     * @type {Array<MembersInner>}
     * @memberof TypedNumberSetFilter
     */
    'members'?: Array<MembersInner>;
    /**
     * 
     * @type {string}
     * @memberof TypedNumberSetFilter
     */
    'type': TypedNumberSetFilterType;
}

export const TypedNumberSetFilterType = {
    NUMBER_SET: 'NUMBER_SET'
} as const;

export type TypedNumberSetFilterType = typeof TypedNumberSetFilterType[keyof typeof TypedNumberSetFilterType];

/**
 * 
 * @export
 * @interface TypedPartialDateRangeFilter
 */
export interface TypedPartialDateRangeFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedPartialDateRangeFilter
     */
    'invert'?: boolean;
    /**
     * The column key to apply the filter to, when applied to a row. If None, the filter cannot be applied to a row, only to a column.
     * @type {string}
     * @memberof TypedPartialDateRangeFilter
     */
    'key'?: string;
    /**
     * The lower bound of the range.
     * @type {string}
     * @memberof TypedPartialDateRangeFilter
     */
    'lower_bound'?: string | null;
    /**
     * 
     * @type {ComparisonOperator}
     * @memberof TypedPartialDateRangeFilter
     */
    'lower_bound_censor'?: ComparisonOperator;
    /**
     * The upper bound of the range.
     * @type {string}
     * @memberof TypedPartialDateRangeFilter
     */
    'upper_bound'?: string | null;
    /**
     * 
     * @type {ComparisonOperator}
     * @memberof TypedPartialDateRangeFilter
     */
    'upper_bound_censor'?: ComparisonOperator;
    /**
     * 
     * @type {string}
     * @memberof TypedPartialDateRangeFilter
     */
    'type': TypedPartialDateRangeFilterType;
}

export const TypedPartialDateRangeFilterType = {
    PARTIAL_DATE_RANGE: 'PARTIAL_DATE_RANGE'
} as const;

export type TypedPartialDateRangeFilterType = typeof TypedPartialDateRangeFilterType[keyof typeof TypedPartialDateRangeFilterType];

/**
 * 
 * @export
 * @interface TypedRegexFilter
 */
export interface TypedRegexFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedRegexFilter
     */
    'invert'?: boolean;
    /**
     * The column key to apply the filter to, when applied to a row. If None, the filter cannot be applied to a row, only to a column.
     * @type {string}
     * @memberof TypedRegexFilter
     */
    'key'?: string;
    /**
     * The regular expression to match.
     * @type {string}
     * @memberof TypedRegexFilter
     */
    'pattern': string;
    /**
     * 
     * @type {string}
     * @memberof TypedRegexFilter
     */
    'type': TypedRegexFilterType;
}

export const TypedRegexFilterType = {
    REGEX: 'REGEX'
} as const;

export type TypedRegexFilterType = typeof TypedRegexFilterType[keyof typeof TypedRegexFilterType];

/**
 * 
 * @export
 * @interface TypedStringSetFilter
 */
export interface TypedStringSetFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedStringSetFilter
     */
    'invert'?: boolean;
    /**
     * The column key to apply the filter to, when applied to a row. If None, the filter cannot be applied to a row, only to a column.
     * @type {string}
     * @memberof TypedStringSetFilter
     */
    'key'?: string;
    /**
     * The strings to match.
     * @type {Array<string>}
     * @memberof TypedStringSetFilter
     */
    'members'?: Array<string>;
    /**
     * Whether the match is case sensitive.
     * @type {boolean}
     * @memberof TypedStringSetFilter
     */
    'case_sensitive'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TypedStringSetFilter
     */
    'type': TypedStringSetFilterType;
}

export const TypedStringSetFilterType = {
    STRING_SET: 'STRING_SET'
} as const;

export type TypedStringSetFilterType = typeof TypedStringSetFilterType[keyof typeof TypedStringSetFilterType];

/**
 * 
 * @export
 * @interface TypedUuidSetFilter
 */
export interface TypedUuidSetFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedUuidSetFilter
     */
    'invert'?: boolean;
    /**
     * The column key to apply the filter to, when applied to a row. If None, the filter cannot be applied to a row, only to a column.
     * @type {string}
     * @memberof TypedUuidSetFilter
     */
    'key'?: string;
    /**
     * The UUIDs to match.
     * @type {Array<string>}
     * @memberof TypedUuidSetFilter
     */
    'members'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TypedUuidSetFilter
     */
    'type': TypedUuidSetFilterType;
}

export const TypedUuidSetFilterType = {
    UUID_SET: 'UUID_SET'
} as const;

export type TypedUuidSetFilterType = typeof TypedUuidSetFilterType[keyof typeof TypedUuidSetFilterType];

/**
 * 
 * @export
 * @interface UpdateCaseTypeColSetCaseTypeColsRequestBody
 */
export interface UpdateCaseTypeColSetCaseTypeColsRequestBody {
    /**
     * 
     * @type {Array<CaseTypeColSetMember>}
     * @memberof UpdateCaseTypeColSetCaseTypeColsRequestBody
     */
    'case_type_col_set_members': Array<CaseTypeColSetMember>;
}
/**
 * 
 * @export
 * @interface UpdateCaseTypeSetCaseTypesRequestBody
 */
export interface UpdateCaseTypeSetCaseTypesRequestBody {
    /**
     * 
     * @type {Array<CaseTypeSetMember>}
     * @memberof UpdateCaseTypeSetCaseTypesRequestBody
     */
    'case_type_set_members': Array<CaseTypeSetMember>;
}
/**
 * 
 * @export
 * @interface UpdateConceptSetConceptRequestBody
 */
export interface UpdateConceptSetConceptRequestBody {
    /**
     * 
     * @type {Array<ConceptSetMember>}
     * @memberof UpdateConceptSetConceptRequestBody
     */
    'concept_set_members': Array<ConceptSetMember>;
}
/**
 * 
 * @export
 * @interface UpdateDataCollectionSetDataCollectionRequestBody
 */
export interface UpdateDataCollectionSetDataCollectionRequestBody {
    /**
     * 
     * @type {Array<DataCollectionSetMember>}
     * @memberof UpdateDataCollectionSetDataCollectionRequestBody
     */
    'data_collection_set_members': Array<DataCollectionSetMember>;
}
/**
 * 
 * @export
 * @interface UpdateDiseaseEtiologicalAgentRequestBody
 */
export interface UpdateDiseaseEtiologicalAgentRequestBody {
    /**
     * 
     * @type {Array<Etiology>}
     * @memberof UpdateDiseaseEtiologicalAgentRequestBody
     */
    'etiologies': Array<Etiology>;
}
/**
 * 
 * @export
 * @interface UpdateOrganizationSetOrganizationRequestBody
 */
export interface UpdateOrganizationSetOrganizationRequestBody {
    /**
     * 
     * @type {Array<OrganizationSetMember>}
     * @memberof UpdateOrganizationSetOrganizationRequestBody
     */
    'organization_set_members': Array<OrganizationSetMember>;
}
/**
 * 
 * @export
 * @interface UpdateUserOwnOrganizationRequestBody
 */
export interface UpdateUserOwnOrganizationRequestBody {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserOwnOrganizationRequestBody
     */
    'organization_id': string;
}
/**
 * 
 * @export
 * @interface UpdateUserRequestBody
 */
export interface UpdateUserRequestBody {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserRequestBody
     */
    'is_active': boolean | null;
    /**
     * 
     * @type {Array<Role>}
     * @memberof UpdateUserRequestBody
     */
    'roles': Array<Role> | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequestBody
     */
    'organization_id': string | null;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * The ID of the user
     * @type {string}
     * @memberof User
     */
    'id'?: string | null;
    /**
     * The email of the user, UNIQUE
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * The full name of the user
     * @type {string}
     * @memberof User
     */
    'name'?: string | null;
    /**
     * Whether the user is active or not. An inactive user cannot perform any actions that require authorization.
     * @type {boolean}
     * @memberof User
     */
    'is_active'?: boolean;
    /**
     * The roles of the user
     * @type {Array<Role>}
     * @memberof User
     */
    'roles': Array<Role>;
    /**
     * The ID of the organization of the user. FOREIGN KEY
     * @type {string}
     * @memberof User
     */
    'organization_id': string;
    /**
     * 
     * @type {Organization}
     * @memberof User
     */
    'organization'?: Organization;
}
/**
 * Stores the maximum access rights of a user to a particular data collection, analogous to the organization access case policy.  The actual access rights of a user are derived as the intersection of their maximum access rights stored here, and the access rights of the organization to which they belong.
 * @export
 * @interface UserAccessCasePolicy
 */
export interface UserAccessCasePolicy {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof UserAccessCasePolicy
     */
    'id'?: string | null;
    /**
     * The ID of the data collection. FOREIGN KEY
     * @type {string}
     * @memberof UserAccessCasePolicy
     */
    'data_collection_id': string;
    /**
     * 
     * @type {DataCollection}
     * @memberof UserAccessCasePolicy
     */
    'data_collection'?: DataCollection;
    /**
     * The ID of the case type set. FOREIGN KEY
     * @type {string}
     * @memberof UserAccessCasePolicy
     */
    'case_type_set_id': string;
    /**
     * 
     * @type {CaseTypeSet}
     * @memberof UserAccessCasePolicy
     */
    'case_type_set'?: CaseTypeSet;
    /**
     * Whether the right is active
     * @type {boolean}
     * @memberof UserAccessCasePolicy
     */
    'is_active': boolean;
    /**
     * Whether cases may be added to the data collection
     * @type {boolean}
     * @memberof UserAccessCasePolicy
     */
    'add_case': boolean;
    /**
     * Whether cases may be removed from the data collection
     * @type {boolean}
     * @memberof UserAccessCasePolicy
     */
    'remove_case': boolean;
    /**
     * Whether case sets may be added to the data collection
     * @type {boolean}
     * @memberof UserAccessCasePolicy
     */
    'add_case_set': boolean;
    /**
     * Whether case sets may be removed from the data collection
     * @type {boolean}
     * @memberof UserAccessCasePolicy
     */
    'remove_case_set': boolean;
    /**
     * The ID of the user. FOREIGN KEY
     * @type {string}
     * @memberof UserAccessCasePolicy
     */
    'user_id': string;
    /**
     * 
     * @type {User}
     * @memberof UserAccessCasePolicy
     */
    'user'?: User;
    /**
     * The ID of the case type column set for which values can be read, limited to the case types in the case type set.  If empty, there are no read rights. FOREIGN KEY
     * @type {string}
     * @memberof UserAccessCasePolicy
     */
    'read_case_type_col_set_id'?: string | null;
    /**
     * 
     * @type {CaseTypeColSet}
     * @memberof UserAccessCasePolicy
     */
    'read_case_type_col_set'?: CaseTypeColSet;
    /**
     * The ID of the case type column set for which values can be updated, limited to the case types in the case type set.  If empty, there are no write rights. FOREIGN KEY
     * @type {string}
     * @memberof UserAccessCasePolicy
     */
    'write_case_type_col_set_id'?: string | null;
    /**
     * 
     * @type {CaseTypeColSet}
     * @memberof UserAccessCasePolicy
     */
    'write_case_type_col_set'?: CaseTypeColSet;
    /**
     * Whether case set be read, limited to the case types in the case type set
     * @type {boolean}
     * @memberof UserAccessCasePolicy
     */
    'read_case_set': boolean;
    /**
     * Whether case set be updated, limited to the case types in the case type set
     * @type {boolean}
     * @memberof UserAccessCasePolicy
     */
    'write_case_set': boolean;
}
/**
 * 
 * @export
 * @interface UserInvitation
 */
export interface UserInvitation {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof UserInvitation
     */
    'id'?: string | null;
    /**
     * The email of the user, UNIQUE
     * @type {string}
     * @memberof UserInvitation
     */
    'email': string;
    /**
     * The token of the invitation
     * @type {string}
     * @memberof UserInvitation
     */
    'token': string;
    /**
     * The expiry date of the invitation
     * @type {string}
     * @memberof UserInvitation
     */
    'expires_at': string;
    /**
     * The identifiers of the initial roles of the user
     * @type {Array<Role>}
     * @memberof UserInvitation
     */
    'roles': Array<Role>;
    /**
     * The ID of the user who invited the user. FOREIGN KEY
     * @type {string}
     * @memberof UserInvitation
     */
    'invited_by_user_id': string;
    /**
     * 
     * @type {User}
     * @memberof UserInvitation
     */
    'invited_by_user'?: User;
    /**
     * The ID of the organization of the user. FOREIGN KEY
     * @type {string}
     * @memberof UserInvitation
     */
    'organization_id': string;
    /**
     * 
     * @type {Organization}
     * @memberof UserInvitation
     */
    'organization'?: Organization;
}
/**
 * 
 * @export
 * @interface UserInvitationRequestBody
 */
export interface UserInvitationRequestBody {
    /**
     * 
     * @type {string}
     * @memberof UserInvitationRequestBody
     */
    'email': string;
    /**
     * The roles of the user
     * @type {Array<Role>}
     * @memberof UserInvitationRequestBody
     */
    'roles': Array<Role>;
    /**
     * 
     * @type {string}
     * @memberof UserInvitationRequestBody
     */
    'organization_id': string;
}
/**
 * 
 * @export
 * @interface UserNameEmail
 */
export interface UserNameEmail {
    /**
     * The ID of the user
     * @type {string}
     * @memberof UserNameEmail
     */
    'id'?: string | null;
    /**
     * The full name of the user
     * @type {string}
     * @memberof UserNameEmail
     */
    'name'?: string | null;
    /**
     * The email of the user
     * @type {string}
     * @memberof UserNameEmail
     */
    'email': string;
}
/**
 * Stores the maximum share rights of a user to a particular data collection, analogous to the organization share case policy.  The actual share rights of a user are derived as the intersection of their maximum share rights stored here, and the share rights of the organization to which they belong.
 * @export
 * @interface UserShareCasePolicy
 */
export interface UserShareCasePolicy {
    /**
     * The unique identifier for the obj.
     * @type {string}
     * @memberof UserShareCasePolicy
     */
    'id'?: string | null;
    /**
     * The ID of the data collection. FOREIGN KEY
     * @type {string}
     * @memberof UserShareCasePolicy
     */
    'data_collection_id': string;
    /**
     * 
     * @type {DataCollection}
     * @memberof UserShareCasePolicy
     */
    'data_collection'?: DataCollection;
    /**
     * The ID of the case type set. FOREIGN KEY
     * @type {string}
     * @memberof UserShareCasePolicy
     */
    'case_type_set_id': string;
    /**
     * 
     * @type {CaseTypeSet}
     * @memberof UserShareCasePolicy
     */
    'case_type_set'?: CaseTypeSet;
    /**
     * Whether the right is active
     * @type {boolean}
     * @memberof UserShareCasePolicy
     */
    'is_active': boolean;
    /**
     * Whether cases may be added to the data collection
     * @type {boolean}
     * @memberof UserShareCasePolicy
     */
    'add_case': boolean;
    /**
     * Whether cases may be removed from the data collection
     * @type {boolean}
     * @memberof UserShareCasePolicy
     */
    'remove_case': boolean;
    /**
     * Whether case sets may be added to the data collection
     * @type {boolean}
     * @memberof UserShareCasePolicy
     */
    'add_case_set': boolean;
    /**
     * Whether case sets may be removed from the data collection
     * @type {boolean}
     * @memberof UserShareCasePolicy
     */
    'remove_case_set': boolean;
    /**
     * The ID of the user. FOREIGN KEY
     * @type {string}
     * @memberof UserShareCasePolicy
     */
    'user_id': string;
    /**
     * 
     * @type {User}
     * @memberof UserShareCasePolicy
     */
    'user'?: User;
    /**
     * The ID of the data collection from which the case type set is shared. FOREIGN KEY
     * @type {string}
     * @memberof UserShareCasePolicy
     */
    'from_data_collection_id': string;
    /**
     * 
     * @type {DataCollection}
     * @memberof UserShareCasePolicy
     */
    'from_data_collection'?: DataCollection;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<LocationInner>}
     * @memberof ValidationError
     */
    'loc': Array<LocationInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * @type Value
 * The number to match.
 * @export
 */
export type Value = number | string;


/**
 * AbacApi - axios parameter creator
 * @export
 */
const AbacApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
         * @summary Organization Access Case Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAccessCasePoliciesDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organization_access_case_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
         * @summary Organization Access Case Policies
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAccessCasePoliciesDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationAccessCasePoliciesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/organization_access_case_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
         * @summary Organization Access Case Policies
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAccessCasePoliciesDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('organizationAccessCasePoliciesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/organization_access_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
         * @summary Organization Access Case Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAccessCasePoliciesGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organization_access_case_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
         * @summary Organization Access Case Policies
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAccessCasePoliciesGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationAccessCasePoliciesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/organization_access_case_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
         * @summary Organization Access Case Policies
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAccessCasePoliciesGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('organizationAccessCasePoliciesGetSome', 'ids', ids)
            const localVarPath = `/v1/organization_access_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
         * @summary Organization Access Case Policies
         * @param {OrganizationAccessCasePolicy} organizationAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAccessCasePoliciesPostOne: async (organizationAccessCasePolicy: OrganizationAccessCasePolicy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationAccessCasePolicy' is not null or undefined
            assertParamExists('organizationAccessCasePoliciesPostOne', 'organizationAccessCasePolicy', organizationAccessCasePolicy)
            const localVarPath = `/v1/organization_access_case_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationAccessCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
         * @summary Organization Access Case Policies
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAccessCasePoliciesPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('organizationAccessCasePoliciesPostQuery', 'filter', filter)
            const localVarPath = `/v1/organization_access_case_policies/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
         * @summary Organization Access Case Policies
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAccessCasePoliciesPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('organizationAccessCasePoliciesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/organization_access_case_policies/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
         * @summary Organization Access Case Policies
         * @param {Array<OrganizationAccessCasePolicy>} organizationAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAccessCasePoliciesPostSome: async (organizationAccessCasePolicy: Array<OrganizationAccessCasePolicy>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationAccessCasePolicy' is not null or undefined
            assertParamExists('organizationAccessCasePoliciesPostSome', 'organizationAccessCasePolicy', organizationAccessCasePolicy)
            const localVarPath = `/v1/organization_access_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationAccessCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
         * @summary Organization Access Case Policies
         * @param {string} objectId 
         * @param {OrganizationAccessCasePolicy} organizationAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAccessCasePoliciesPutOne: async (objectId: string, organizationAccessCasePolicy: OrganizationAccessCasePolicy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationAccessCasePoliciesPutOne', 'objectId', objectId)
            // verify required parameter 'organizationAccessCasePolicy' is not null or undefined
            assertParamExists('organizationAccessCasePoliciesPutOne', 'organizationAccessCasePolicy', organizationAccessCasePolicy)
            const localVarPath = `/v1/organization_access_case_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationAccessCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
         * @summary Organization Access Case Policies
         * @param {Array<OrganizationAccessCasePolicy>} organizationAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAccessCasePoliciesPutSome: async (organizationAccessCasePolicy: Array<OrganizationAccessCasePolicy>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationAccessCasePolicy' is not null or undefined
            assertParamExists('organizationAccessCasePoliciesPutSome', 'organizationAccessCasePolicy', organizationAccessCasePolicy)
            const localVarPath = `/v1/organization_access_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationAccessCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Admin Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAdminPoliciesDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organization_admin_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Admin Policies
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAdminPoliciesDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationAdminPoliciesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/organization_admin_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Admin Policies
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAdminPoliciesDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('organizationAdminPoliciesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/organization_admin_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Admin Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAdminPoliciesGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organization_admin_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Admin Policies
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAdminPoliciesGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationAdminPoliciesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/organization_admin_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Admin Policies
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAdminPoliciesGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('organizationAdminPoliciesGetSome', 'ids', ids)
            const localVarPath = `/v1/organization_admin_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Admin Policies
         * @param {OrganizationAdminPolicy} organizationAdminPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAdminPoliciesPostOne: async (organizationAdminPolicy: OrganizationAdminPolicy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationAdminPolicy' is not null or undefined
            assertParamExists('organizationAdminPoliciesPostOne', 'organizationAdminPolicy', organizationAdminPolicy)
            const localVarPath = `/v1/organization_admin_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationAdminPolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Admin Policies
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAdminPoliciesPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('organizationAdminPoliciesPostQuery', 'filter', filter)
            const localVarPath = `/v1/organization_admin_policies/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Admin Policies
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAdminPoliciesPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('organizationAdminPoliciesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/organization_admin_policies/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Admin Policies
         * @param {Array<OrganizationAdminPolicy>} organizationAdminPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAdminPoliciesPostSome: async (organizationAdminPolicy: Array<OrganizationAdminPolicy>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationAdminPolicy' is not null or undefined
            assertParamExists('organizationAdminPoliciesPostSome', 'organizationAdminPolicy', organizationAdminPolicy)
            const localVarPath = `/v1/organization_admin_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationAdminPolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Admin Policies
         * @param {string} objectId 
         * @param {OrganizationAdminPolicy} organizationAdminPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAdminPoliciesPutOne: async (objectId: string, organizationAdminPolicy: OrganizationAdminPolicy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationAdminPoliciesPutOne', 'objectId', objectId)
            // verify required parameter 'organizationAdminPolicy' is not null or undefined
            assertParamExists('organizationAdminPoliciesPutOne', 'organizationAdminPolicy', organizationAdminPolicy)
            const localVarPath = `/v1/organization_admin_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationAdminPolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Admin Policies
         * @param {Array<OrganizationAdminPolicy>} organizationAdminPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAdminPoliciesPutSome: async (organizationAdminPolicy: Array<OrganizationAdminPolicy>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationAdminPolicy' is not null or undefined
            assertParamExists('organizationAdminPoliciesPutSome', 'organizationAdminPolicy', organizationAdminPolicy)
            const localVarPath = `/v1/organization_admin_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationAdminPolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
         * @summary Organization Share Case Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationShareCasePoliciesDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organization_share_case_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
         * @summary Organization Share Case Policies
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationShareCasePoliciesDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationShareCasePoliciesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/organization_share_case_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
         * @summary Organization Share Case Policies
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationShareCasePoliciesDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('organizationShareCasePoliciesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/organization_share_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
         * @summary Organization Share Case Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationShareCasePoliciesGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organization_share_case_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
         * @summary Organization Share Case Policies
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationShareCasePoliciesGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationShareCasePoliciesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/organization_share_case_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
         * @summary Organization Share Case Policies
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationShareCasePoliciesGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('organizationShareCasePoliciesGetSome', 'ids', ids)
            const localVarPath = `/v1/organization_share_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
         * @summary Organization Share Case Policies
         * @param {OrganizationShareCasePolicy} organizationShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationShareCasePoliciesPostOne: async (organizationShareCasePolicy: OrganizationShareCasePolicy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationShareCasePolicy' is not null or undefined
            assertParamExists('organizationShareCasePoliciesPostOne', 'organizationShareCasePolicy', organizationShareCasePolicy)
            const localVarPath = `/v1/organization_share_case_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationShareCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
         * @summary Organization Share Case Policies
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationShareCasePoliciesPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('organizationShareCasePoliciesPostQuery', 'filter', filter)
            const localVarPath = `/v1/organization_share_case_policies/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
         * @summary Organization Share Case Policies
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationShareCasePoliciesPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('organizationShareCasePoliciesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/organization_share_case_policies/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
         * @summary Organization Share Case Policies
         * @param {Array<OrganizationShareCasePolicy>} organizationShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationShareCasePoliciesPostSome: async (organizationShareCasePolicy: Array<OrganizationShareCasePolicy>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationShareCasePolicy' is not null or undefined
            assertParamExists('organizationShareCasePoliciesPostSome', 'organizationShareCasePolicy', organizationShareCasePolicy)
            const localVarPath = `/v1/organization_share_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationShareCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
         * @summary Organization Share Case Policies
         * @param {string} objectId 
         * @param {OrganizationShareCasePolicy} organizationShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationShareCasePoliciesPutOne: async (objectId: string, organizationShareCasePolicy: OrganizationShareCasePolicy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationShareCasePoliciesPutOne', 'objectId', objectId)
            // verify required parameter 'organizationShareCasePolicy' is not null or undefined
            assertParamExists('organizationShareCasePoliciesPutOne', 'organizationShareCasePolicy', organizationShareCasePolicy)
            const localVarPath = `/v1/organization_share_case_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationShareCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
         * @summary Organization Share Case Policies
         * @param {Array<OrganizationShareCasePolicy>} organizationShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationShareCasePoliciesPutSome: async (organizationShareCasePolicy: Array<OrganizationShareCasePolicy>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationShareCasePolicy' is not null or undefined
            assertParamExists('organizationShareCasePoliciesPutSome', 'organizationShareCasePolicy', organizationShareCasePolicy)
            const localVarPath = `/v1/organization_share_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationShareCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
         * @summary User Access Case Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccessCasePoliciesDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user_access_case_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
         * @summary User Access Case Policies
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccessCasePoliciesDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('userAccessCasePoliciesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/user_access_case_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
         * @summary User Access Case Policies
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccessCasePoliciesDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('userAccessCasePoliciesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/user_access_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
         * @summary User Access Case Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccessCasePoliciesGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user_access_case_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
         * @summary User Access Case Policies
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccessCasePoliciesGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('userAccessCasePoliciesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/user_access_case_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
         * @summary User Access Case Policies
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccessCasePoliciesGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('userAccessCasePoliciesGetSome', 'ids', ids)
            const localVarPath = `/v1/user_access_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
         * @summary User Access Case Policies
         * @param {UserAccessCasePolicy} userAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccessCasePoliciesPostOne: async (userAccessCasePolicy: UserAccessCasePolicy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAccessCasePolicy' is not null or undefined
            assertParamExists('userAccessCasePoliciesPostOne', 'userAccessCasePolicy', userAccessCasePolicy)
            const localVarPath = `/v1/user_access_case_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAccessCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
         * @summary User Access Case Policies
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccessCasePoliciesPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('userAccessCasePoliciesPostQuery', 'filter', filter)
            const localVarPath = `/v1/user_access_case_policies/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
         * @summary User Access Case Policies
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccessCasePoliciesPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('userAccessCasePoliciesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/user_access_case_policies/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
         * @summary User Access Case Policies
         * @param {Array<UserAccessCasePolicy>} userAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccessCasePoliciesPostSome: async (userAccessCasePolicy: Array<UserAccessCasePolicy>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAccessCasePolicy' is not null or undefined
            assertParamExists('userAccessCasePoliciesPostSome', 'userAccessCasePolicy', userAccessCasePolicy)
            const localVarPath = `/v1/user_access_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAccessCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
         * @summary User Access Case Policies
         * @param {string} objectId 
         * @param {UserAccessCasePolicy} userAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccessCasePoliciesPutOne: async (objectId: string, userAccessCasePolicy: UserAccessCasePolicy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('userAccessCasePoliciesPutOne', 'objectId', objectId)
            // verify required parameter 'userAccessCasePolicy' is not null or undefined
            assertParamExists('userAccessCasePoliciesPutOne', 'userAccessCasePolicy', userAccessCasePolicy)
            const localVarPath = `/v1/user_access_case_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAccessCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
         * @summary User Access Case Policies
         * @param {Array<UserAccessCasePolicy>} userAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccessCasePoliciesPutSome: async (userAccessCasePolicy: Array<UserAccessCasePolicy>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAccessCasePolicy' is not null or undefined
            assertParamExists('userAccessCasePoliciesPutSome', 'userAccessCasePolicy', userAccessCasePolicy)
            const localVarPath = `/v1/user_access_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAccessCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
         * @summary User Share Case Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareCasePoliciesDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user_share_case_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
         * @summary User Share Case Policies
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareCasePoliciesDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('userShareCasePoliciesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/user_share_case_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
         * @summary User Share Case Policies
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareCasePoliciesDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('userShareCasePoliciesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/user_share_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
         * @summary User Share Case Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareCasePoliciesGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user_share_case_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
         * @summary User Share Case Policies
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareCasePoliciesGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('userShareCasePoliciesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/user_share_case_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
         * @summary User Share Case Policies
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareCasePoliciesGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('userShareCasePoliciesGetSome', 'ids', ids)
            const localVarPath = `/v1/user_share_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
         * @summary User Share Case Policies
         * @param {UserShareCasePolicy} userShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareCasePoliciesPostOne: async (userShareCasePolicy: UserShareCasePolicy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userShareCasePolicy' is not null or undefined
            assertParamExists('userShareCasePoliciesPostOne', 'userShareCasePolicy', userShareCasePolicy)
            const localVarPath = `/v1/user_share_case_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userShareCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
         * @summary User Share Case Policies
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareCasePoliciesPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('userShareCasePoliciesPostQuery', 'filter', filter)
            const localVarPath = `/v1/user_share_case_policies/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
         * @summary User Share Case Policies
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareCasePoliciesPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('userShareCasePoliciesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/user_share_case_policies/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
         * @summary User Share Case Policies
         * @param {Array<UserShareCasePolicy>} userShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareCasePoliciesPostSome: async (userShareCasePolicy: Array<UserShareCasePolicy>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userShareCasePolicy' is not null or undefined
            assertParamExists('userShareCasePoliciesPostSome', 'userShareCasePolicy', userShareCasePolicy)
            const localVarPath = `/v1/user_share_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userShareCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
         * @summary User Share Case Policies
         * @param {string} objectId 
         * @param {UserShareCasePolicy} userShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareCasePoliciesPutOne: async (objectId: string, userShareCasePolicy: UserShareCasePolicy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('userShareCasePoliciesPutOne', 'objectId', objectId)
            // verify required parameter 'userShareCasePolicy' is not null or undefined
            assertParamExists('userShareCasePoliciesPutOne', 'userShareCasePolicy', userShareCasePolicy)
            const localVarPath = `/v1/user_share_case_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userShareCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
         * @summary User Share Case Policies
         * @param {Array<UserShareCasePolicy>} userShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareCasePoliciesPutSome: async (userShareCasePolicy: Array<UserShareCasePolicy>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userShareCasePolicy' is not null or undefined
            assertParamExists('userShareCasePoliciesPutSome', 'userShareCasePolicy', userShareCasePolicy)
            const localVarPath = `/v1/user_share_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userShareCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AbacApi - functional programming interface
 * @export
 */
const AbacApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AbacApiAxiosParamCreator(configuration)
    return {
        /**
         * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
         * @summary Organization Access Case Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAccessCasePoliciesDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAccessCasePoliciesDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
         * @summary Organization Access Case Policies
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAccessCasePoliciesDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAccessCasePoliciesDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
         * @summary Organization Access Case Policies
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAccessCasePoliciesDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAccessCasePoliciesDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
         * @summary Organization Access Case Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAccessCasePoliciesGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationAccessCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAccessCasePoliciesGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
         * @summary Organization Access Case Policies
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAccessCasePoliciesGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAccessCasePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAccessCasePoliciesGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
         * @summary Organization Access Case Policies
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAccessCasePoliciesGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationAccessCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAccessCasePoliciesGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
         * @summary Organization Access Case Policies
         * @param {OrganizationAccessCasePolicy} organizationAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAccessCasePoliciesPostOne(organizationAccessCasePolicy: OrganizationAccessCasePolicy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAccessCasePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAccessCasePoliciesPostOne(organizationAccessCasePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
         * @summary Organization Access Case Policies
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAccessCasePoliciesPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationAccessCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAccessCasePoliciesPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
         * @summary Organization Access Case Policies
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAccessCasePoliciesPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAccessCasePoliciesPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
         * @summary Organization Access Case Policies
         * @param {Array<OrganizationAccessCasePolicy>} organizationAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAccessCasePoliciesPostSome(organizationAccessCasePolicy: Array<OrganizationAccessCasePolicy>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationAccessCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAccessCasePoliciesPostSome(organizationAccessCasePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
         * @summary Organization Access Case Policies
         * @param {string} objectId 
         * @param {OrganizationAccessCasePolicy} organizationAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAccessCasePoliciesPutOne(objectId: string, organizationAccessCasePolicy: OrganizationAccessCasePolicy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAccessCasePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAccessCasePoliciesPutOne(objectId, organizationAccessCasePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
         * @summary Organization Access Case Policies
         * @param {Array<OrganizationAccessCasePolicy>} organizationAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAccessCasePoliciesPutSome(organizationAccessCasePolicy: Array<OrganizationAccessCasePolicy>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationAccessCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAccessCasePoliciesPutSome(organizationAccessCasePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Admin Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAdminPoliciesDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAdminPoliciesDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Admin Policies
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAdminPoliciesDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAdminPoliciesDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Admin Policies
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAdminPoliciesDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAdminPoliciesDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Admin Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAdminPoliciesGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationAdminPolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAdminPoliciesGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Admin Policies
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAdminPoliciesGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAdminPolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAdminPoliciesGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Admin Policies
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAdminPoliciesGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationAdminPolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAdminPoliciesGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Admin Policies
         * @param {OrganizationAdminPolicy} organizationAdminPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAdminPoliciesPostOne(organizationAdminPolicy: OrganizationAdminPolicy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAdminPolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAdminPoliciesPostOne(organizationAdminPolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Admin Policies
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAdminPoliciesPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationAdminPolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAdminPoliciesPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Admin Policies
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAdminPoliciesPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAdminPoliciesPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Admin Policies
         * @param {Array<OrganizationAdminPolicy>} organizationAdminPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAdminPoliciesPostSome(organizationAdminPolicy: Array<OrganizationAdminPolicy>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationAdminPolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAdminPoliciesPostSome(organizationAdminPolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Admin Policies
         * @param {string} objectId 
         * @param {OrganizationAdminPolicy} organizationAdminPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAdminPoliciesPutOne(objectId: string, organizationAdminPolicy: OrganizationAdminPolicy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAdminPolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAdminPoliciesPutOne(objectId, organizationAdminPolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Admin Policies
         * @param {Array<OrganizationAdminPolicy>} organizationAdminPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAdminPoliciesPutSome(organizationAdminPolicy: Array<OrganizationAdminPolicy>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationAdminPolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAdminPoliciesPutSome(organizationAdminPolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
         * @summary Organization Share Case Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationShareCasePoliciesDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationShareCasePoliciesDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
         * @summary Organization Share Case Policies
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationShareCasePoliciesDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationShareCasePoliciesDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
         * @summary Organization Share Case Policies
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationShareCasePoliciesDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationShareCasePoliciesDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
         * @summary Organization Share Case Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationShareCasePoliciesGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationShareCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationShareCasePoliciesGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
         * @summary Organization Share Case Policies
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationShareCasePoliciesGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationShareCasePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationShareCasePoliciesGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
         * @summary Organization Share Case Policies
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationShareCasePoliciesGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationShareCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationShareCasePoliciesGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
         * @summary Organization Share Case Policies
         * @param {OrganizationShareCasePolicy} organizationShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationShareCasePoliciesPostOne(organizationShareCasePolicy: OrganizationShareCasePolicy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationShareCasePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationShareCasePoliciesPostOne(organizationShareCasePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
         * @summary Organization Share Case Policies
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationShareCasePoliciesPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationShareCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationShareCasePoliciesPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
         * @summary Organization Share Case Policies
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationShareCasePoliciesPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationShareCasePoliciesPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
         * @summary Organization Share Case Policies
         * @param {Array<OrganizationShareCasePolicy>} organizationShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationShareCasePoliciesPostSome(organizationShareCasePolicy: Array<OrganizationShareCasePolicy>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationShareCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationShareCasePoliciesPostSome(organizationShareCasePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
         * @summary Organization Share Case Policies
         * @param {string} objectId 
         * @param {OrganizationShareCasePolicy} organizationShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationShareCasePoliciesPutOne(objectId: string, organizationShareCasePolicy: OrganizationShareCasePolicy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationShareCasePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationShareCasePoliciesPutOne(objectId, organizationShareCasePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
         * @summary Organization Share Case Policies
         * @param {Array<OrganizationShareCasePolicy>} organizationShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationShareCasePoliciesPutSome(organizationShareCasePolicy: Array<OrganizationShareCasePolicy>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationShareCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationShareCasePoliciesPutSome(organizationShareCasePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
         * @summary User Access Case Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccessCasePoliciesDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccessCasePoliciesDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
         * @summary User Access Case Policies
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccessCasePoliciesDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccessCasePoliciesDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
         * @summary User Access Case Policies
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccessCasePoliciesDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccessCasePoliciesDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
         * @summary User Access Case Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccessCasePoliciesGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAccessCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccessCasePoliciesGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
         * @summary User Access Case Policies
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccessCasePoliciesGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAccessCasePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccessCasePoliciesGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
         * @summary User Access Case Policies
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccessCasePoliciesGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAccessCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccessCasePoliciesGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
         * @summary User Access Case Policies
         * @param {UserAccessCasePolicy} userAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccessCasePoliciesPostOne(userAccessCasePolicy: UserAccessCasePolicy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAccessCasePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccessCasePoliciesPostOne(userAccessCasePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
         * @summary User Access Case Policies
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccessCasePoliciesPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAccessCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccessCasePoliciesPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
         * @summary User Access Case Policies
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccessCasePoliciesPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccessCasePoliciesPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
         * @summary User Access Case Policies
         * @param {Array<UserAccessCasePolicy>} userAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccessCasePoliciesPostSome(userAccessCasePolicy: Array<UserAccessCasePolicy>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAccessCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccessCasePoliciesPostSome(userAccessCasePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
         * @summary User Access Case Policies
         * @param {string} objectId 
         * @param {UserAccessCasePolicy} userAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccessCasePoliciesPutOne(objectId: string, userAccessCasePolicy: UserAccessCasePolicy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAccessCasePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccessCasePoliciesPutOne(objectId, userAccessCasePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
         * @summary User Access Case Policies
         * @param {Array<UserAccessCasePolicy>} userAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccessCasePoliciesPutSome(userAccessCasePolicy: Array<UserAccessCasePolicy>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAccessCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccessCasePoliciesPutSome(userAccessCasePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
         * @summary User Share Case Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareCasePoliciesDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareCasePoliciesDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
         * @summary User Share Case Policies
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareCasePoliciesDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareCasePoliciesDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
         * @summary User Share Case Policies
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareCasePoliciesDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareCasePoliciesDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
         * @summary User Share Case Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareCasePoliciesGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserShareCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareCasePoliciesGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
         * @summary User Share Case Policies
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareCasePoliciesGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserShareCasePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareCasePoliciesGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
         * @summary User Share Case Policies
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareCasePoliciesGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserShareCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareCasePoliciesGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
         * @summary User Share Case Policies
         * @param {UserShareCasePolicy} userShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareCasePoliciesPostOne(userShareCasePolicy: UserShareCasePolicy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserShareCasePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareCasePoliciesPostOne(userShareCasePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
         * @summary User Share Case Policies
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareCasePoliciesPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserShareCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareCasePoliciesPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
         * @summary User Share Case Policies
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareCasePoliciesPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareCasePoliciesPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
         * @summary User Share Case Policies
         * @param {Array<UserShareCasePolicy>} userShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareCasePoliciesPostSome(userShareCasePolicy: Array<UserShareCasePolicy>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserShareCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareCasePoliciesPostSome(userShareCasePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
         * @summary User Share Case Policies
         * @param {string} objectId 
         * @param {UserShareCasePolicy} userShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareCasePoliciesPutOne(objectId: string, userShareCasePolicy: UserShareCasePolicy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserShareCasePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareCasePoliciesPutOne(objectId, userShareCasePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
         * @summary User Share Case Policies
         * @param {Array<UserShareCasePolicy>} userShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareCasePoliciesPutSome(userShareCasePolicy: Array<UserShareCasePolicy>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserShareCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareCasePoliciesPutSome(userShareCasePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
    }
};

/**
 * AbacApi - factory interface
 * @export
 */

/**
 * AbacApi - object-oriented interface

 * @export
 * @class AbacApi
 * @extends {BaseAPI}
 */
export class AbacApi extends BaseAPI {
  public static instance: AbacApi;
  public static getInstance(): AbacApi {
    this.instance = this.instance || new AbacApi();
    return this.instance;
  }

    /**
     * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
     * @summary Organization Access Case Policies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAccessCasePoliciesDeleteAll(options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAccessCasePoliciesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
     * @summary Organization Access Case Policies
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAccessCasePoliciesDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAccessCasePoliciesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
     * @summary Organization Access Case Policies
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAccessCasePoliciesDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAccessCasePoliciesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
     * @summary Organization Access Case Policies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAccessCasePoliciesGetAll(options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAccessCasePoliciesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
     * @summary Organization Access Case Policies
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAccessCasePoliciesGetOne(objectId: string, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAccessCasePoliciesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
     * @summary Organization Access Case Policies
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAccessCasePoliciesGetSome(ids: string, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAccessCasePoliciesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
     * @summary Organization Access Case Policies
     * @param {OrganizationAccessCasePolicy} organizationAccessCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAccessCasePoliciesPostOne(organizationAccessCasePolicy: OrganizationAccessCasePolicy, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAccessCasePoliciesPostOne(organizationAccessCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
     * @summary Organization Access Case Policies
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAccessCasePoliciesPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAccessCasePoliciesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
     * @summary Organization Access Case Policies
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAccessCasePoliciesPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAccessCasePoliciesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
     * @summary Organization Access Case Policies
     * @param {Array<OrganizationAccessCasePolicy>} organizationAccessCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAccessCasePoliciesPostSome(organizationAccessCasePolicy: Array<OrganizationAccessCasePolicy>, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAccessCasePoliciesPostSome(organizationAccessCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
     * @summary Organization Access Case Policies
     * @param {string} objectId 
     * @param {OrganizationAccessCasePolicy} organizationAccessCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAccessCasePoliciesPutOne(objectId: string, organizationAccessCasePolicy: OrganizationAccessCasePolicy, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAccessCasePoliciesPutOne(objectId, organizationAccessCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the access rights of an organization to a particular data collection.     If an organization does not have a policy to a data collection, it has no access     rights to that data collection.      The access rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no access rights to that data     collection for that case type.
     * @summary Organization Access Case Policies
     * @param {Array<OrganizationAccessCasePolicy>} organizationAccessCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAccessCasePoliciesPutSome(organizationAccessCasePolicy: Array<OrganizationAccessCasePolicy>, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAccessCasePoliciesPutSome(organizationAccessCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Admin Policies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAdminPoliciesDeleteAll(options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAdminPoliciesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Admin Policies
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAdminPoliciesDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAdminPoliciesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Admin Policies
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAdminPoliciesDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAdminPoliciesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Admin Policies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAdminPoliciesGetAll(options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAdminPoliciesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Admin Policies
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAdminPoliciesGetOne(objectId: string, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAdminPoliciesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Admin Policies
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAdminPoliciesGetSome(ids: string, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAdminPoliciesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Admin Policies
     * @param {OrganizationAdminPolicy} organizationAdminPolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAdminPoliciesPostOne(organizationAdminPolicy: OrganizationAdminPolicy, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAdminPoliciesPostOne(organizationAdminPolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Admin Policies
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAdminPoliciesPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAdminPoliciesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Admin Policies
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAdminPoliciesPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAdminPoliciesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Admin Policies
     * @param {Array<OrganizationAdminPolicy>} organizationAdminPolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAdminPoliciesPostSome(organizationAdminPolicy: Array<OrganizationAdminPolicy>, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAdminPoliciesPostSome(organizationAdminPolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Admin Policies
     * @param {string} objectId 
     * @param {OrganizationAdminPolicy} organizationAdminPolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAdminPoliciesPutOne(objectId: string, organizationAdminPolicy: OrganizationAdminPolicy, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAdminPoliciesPutOne(objectId, organizationAdminPolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Admin Policies
     * @param {Array<OrganizationAdminPolicy>} organizationAdminPolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAdminPoliciesPutSome(organizationAdminPolicy: Array<OrganizationAdminPolicy>, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAdminPoliciesPutSome(organizationAdminPolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
     * @summary Organization Share Case Policies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationShareCasePoliciesDeleteAll(options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationShareCasePoliciesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
     * @summary Organization Share Case Policies
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationShareCasePoliciesDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationShareCasePoliciesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
     * @summary Organization Share Case Policies
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationShareCasePoliciesDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationShareCasePoliciesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
     * @summary Organization Share Case Policies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationShareCasePoliciesGetAll(options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationShareCasePoliciesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
     * @summary Organization Share Case Policies
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationShareCasePoliciesGetOne(objectId: string, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationShareCasePoliciesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
     * @summary Organization Share Case Policies
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationShareCasePoliciesGetSome(ids: string, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationShareCasePoliciesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
     * @summary Organization Share Case Policies
     * @param {OrganizationShareCasePolicy} organizationShareCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationShareCasePoliciesPostOne(organizationShareCasePolicy: OrganizationShareCasePolicy, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationShareCasePoliciesPostOne(organizationShareCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
     * @summary Organization Share Case Policies
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationShareCasePoliciesPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationShareCasePoliciesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
     * @summary Organization Share Case Policies
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationShareCasePoliciesPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationShareCasePoliciesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
     * @summary Organization Share Case Policies
     * @param {Array<OrganizationShareCasePolicy>} organizationShareCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationShareCasePoliciesPostSome(organizationShareCasePolicy: Array<OrganizationShareCasePolicy>, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationShareCasePoliciesPostSome(organizationShareCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
     * @summary Organization Share Case Policies
     * @param {string} objectId 
     * @param {OrganizationShareCasePolicy} organizationShareCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationShareCasePoliciesPutOne(objectId: string, organizationShareCasePolicy: OrganizationShareCasePolicy, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationShareCasePoliciesPutOne(objectId, organizationShareCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores any additional case or case set share rights of an organization to a     particular data collection, if the case or case set is already in a particular     other data collection.      The share rights are limited to the case types in the case type set. If a case type     is not in the case type set, the organization has no share rights to that data     collection for that case type.
     * @summary Organization Share Case Policies
     * @param {Array<OrganizationShareCasePolicy>} organizationShareCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationShareCasePoliciesPutSome(organizationShareCasePolicy: Array<OrganizationShareCasePolicy>, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationShareCasePoliciesPutSome(organizationShareCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
     * @summary User Access Case Policies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userAccessCasePoliciesDeleteAll(options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).userAccessCasePoliciesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
     * @summary User Access Case Policies
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userAccessCasePoliciesDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).userAccessCasePoliciesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
     * @summary User Access Case Policies
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userAccessCasePoliciesDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).userAccessCasePoliciesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
     * @summary User Access Case Policies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userAccessCasePoliciesGetAll(options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).userAccessCasePoliciesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
     * @summary User Access Case Policies
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userAccessCasePoliciesGetOne(objectId: string, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).userAccessCasePoliciesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
     * @summary User Access Case Policies
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userAccessCasePoliciesGetSome(ids: string, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).userAccessCasePoliciesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
     * @summary User Access Case Policies
     * @param {UserAccessCasePolicy} userAccessCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userAccessCasePoliciesPostOne(userAccessCasePolicy: UserAccessCasePolicy, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).userAccessCasePoliciesPostOne(userAccessCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
     * @summary User Access Case Policies
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userAccessCasePoliciesPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).userAccessCasePoliciesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
     * @summary User Access Case Policies
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userAccessCasePoliciesPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).userAccessCasePoliciesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
     * @summary User Access Case Policies
     * @param {Array<UserAccessCasePolicy>} userAccessCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userAccessCasePoliciesPostSome(userAccessCasePolicy: Array<UserAccessCasePolicy>, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).userAccessCasePoliciesPostSome(userAccessCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
     * @summary User Access Case Policies
     * @param {string} objectId 
     * @param {UserAccessCasePolicy} userAccessCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userAccessCasePoliciesPutOne(objectId: string, userAccessCasePolicy: UserAccessCasePolicy, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).userAccessCasePoliciesPutOne(objectId, userAccessCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the maximum access rights of a user to a particular data collection,     analogous to the organization access case policy.      The actual access rights of a user are derived as the intersection of their maximum     access rights stored here, and the access rights of the organization to which they     belong.
     * @summary User Access Case Policies
     * @param {Array<UserAccessCasePolicy>} userAccessCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userAccessCasePoliciesPutSome(userAccessCasePolicy: Array<UserAccessCasePolicy>, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).userAccessCasePoliciesPutSome(userAccessCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
     * @summary User Share Case Policies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userShareCasePoliciesDeleteAll(options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).userShareCasePoliciesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
     * @summary User Share Case Policies
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userShareCasePoliciesDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).userShareCasePoliciesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
     * @summary User Share Case Policies
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userShareCasePoliciesDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).userShareCasePoliciesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
     * @summary User Share Case Policies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userShareCasePoliciesGetAll(options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).userShareCasePoliciesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
     * @summary User Share Case Policies
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userShareCasePoliciesGetOne(objectId: string, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).userShareCasePoliciesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
     * @summary User Share Case Policies
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userShareCasePoliciesGetSome(ids: string, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).userShareCasePoliciesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
     * @summary User Share Case Policies
     * @param {UserShareCasePolicy} userShareCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userShareCasePoliciesPostOne(userShareCasePolicy: UserShareCasePolicy, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).userShareCasePoliciesPostOne(userShareCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
     * @summary User Share Case Policies
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userShareCasePoliciesPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).userShareCasePoliciesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
     * @summary User Share Case Policies
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userShareCasePoliciesPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).userShareCasePoliciesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
     * @summary User Share Case Policies
     * @param {Array<UserShareCasePolicy>} userShareCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userShareCasePoliciesPostSome(userShareCasePolicy: Array<UserShareCasePolicy>, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).userShareCasePoliciesPostSome(userShareCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
     * @summary User Share Case Policies
     * @param {string} objectId 
     * @param {UserShareCasePolicy} userShareCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userShareCasePoliciesPutOne(objectId: string, userShareCasePolicy: UserShareCasePolicy, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).userShareCasePoliciesPutOne(objectId, userShareCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Stores the maximum share rights of a user to a particular data collection,     analogous to the organization share case policy.      The actual share rights of a user are derived as the intersection of their maximum     share rights stored here, and the share rights of the organization to which they     belong.
     * @summary User Share Case Policies
     * @param {Array<UserShareCasePolicy>} userShareCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userShareCasePoliciesPutSome(userShareCasePolicy: Array<UserShareCasePolicy>, options?: AxiosRequestConfig) {
        return AbacApiFp(this.configuration).userShareCasePoliciesPutSome(userShareCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Identityprovider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityProvidersGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/identity_providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Userinvitations
         * @param {UserInvitationRequestBody} userInvitationRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationsPostOne: async (userInvitationRequestBody: UserInvitationRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userInvitationRequestBody' is not null or undefined
            assertParamExists('userInvitationsPostOne', 'userInvitationRequestBody', userInvitationRequestBody)
            const localVarPath = `/v1/user_invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInvitationRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Registerinviteduser
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRegistrationsPostOne: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('userRegistrationsPostOne', 'token', token)
            const localVarPath = `/v1/user_registrations/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Identityprovider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identityProvidersGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityProvider>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identityProvidersGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Userinvitations
         * @param {UserInvitationRequestBody} userInvitationRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInvitationsPostOne(userInvitationRequestBody: UserInvitationRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInvitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInvitationsPostOne(userInvitationRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Registerinviteduser
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userRegistrationsPostOne(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userRegistrationsPostOne(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */

/**
 * AuthApi - object-oriented interface

 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  public static instance: AuthApi;
  public static getInstance(): AuthApi {
    this.instance = this.instance || new AuthApi();
    return this.instance;
  }

    /**
     * 
     * @summary Identityprovider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public identityProvidersGetAll(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).identityProvidersGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Userinvitations
     * @param {UserInvitationRequestBody} userInvitationRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public userInvitationsPostOne(userInvitationRequestBody: UserInvitationRequestBody, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).userInvitationsPostOne(userInvitationRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Registerinviteduser
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public userRegistrationsPostOne(token: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).userRegistrationsPostOne(token, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }
}



/**
 * CaseApi - axios parameter creator
 * @export
 */
const CaseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Case Data Collection Links
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseDataCollectionLinksDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_data_collection_links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Data Collection Links
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseDataCollectionLinksDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseDataCollectionLinksDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_data_collection_links/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Data Collection Links
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseDataCollectionLinksDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseDataCollectionLinksDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_data_collection_links/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Data Collection Links
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseDataCollectionLinksGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_data_collection_links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Data Collection Links
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseDataCollectionLinksGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseDataCollectionLinksGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_data_collection_links/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Data Collection Links
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseDataCollectionLinksGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseDataCollectionLinksGetSome', 'ids', ids)
            const localVarPath = `/v1/case_data_collection_links/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Data Collection Links
         * @param {CaseDataCollectionLink} caseDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseDataCollectionLinksPostOne: async (caseDataCollectionLink: CaseDataCollectionLink, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseDataCollectionLink' is not null or undefined
            assertParamExists('caseDataCollectionLinksPostOne', 'caseDataCollectionLink', caseDataCollectionLink)
            const localVarPath = `/v1/case_data_collection_links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseDataCollectionLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Data Collection Links
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseDataCollectionLinksPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseDataCollectionLinksPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_data_collection_links/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Data Collection Links
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseDataCollectionLinksPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseDataCollectionLinksPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_data_collection_links/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Data Collection Links
         * @param {Array<CaseDataCollectionLink>} caseDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseDataCollectionLinksPostSome: async (caseDataCollectionLink: Array<CaseDataCollectionLink>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseDataCollectionLink' is not null or undefined
            assertParamExists('caseDataCollectionLinksPostSome', 'caseDataCollectionLink', caseDataCollectionLink)
            const localVarPath = `/v1/case_data_collection_links/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseDataCollectionLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Data Collection Links
         * @param {string} objectId 
         * @param {CaseDataCollectionLink} caseDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseDataCollectionLinksPutOne: async (objectId: string, caseDataCollectionLink: CaseDataCollectionLink, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseDataCollectionLinksPutOne', 'objectId', objectId)
            // verify required parameter 'caseDataCollectionLink' is not null or undefined
            assertParamExists('caseDataCollectionLinksPutOne', 'caseDataCollectionLink', caseDataCollectionLink)
            const localVarPath = `/v1/case_data_collection_links/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseDataCollectionLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Data Collection Links
         * @param {Array<CaseDataCollectionLink>} caseDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseDataCollectionLinksPutSome: async (caseDataCollectionLink: Array<CaseDataCollectionLink>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseDataCollectionLink' is not null or undefined
            assertParamExists('caseDataCollectionLinksPutSome', 'caseDataCollectionLink', caseDataCollectionLink)
            const localVarPath = `/v1/case_data_collection_links/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseDataCollectionLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetCategoriesDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_set_categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Categories
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetCategoriesDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetCategoriesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_set_categories/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Categories
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetCategoriesDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseSetCategoriesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_set_categories/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetCategoriesGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_set_categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Categories
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetCategoriesGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetCategoriesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_set_categories/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Categories
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetCategoriesGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseSetCategoriesGetSome', 'ids', ids)
            const localVarPath = `/v1/case_set_categories/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Categories
         * @param {CaseSetCategory} caseSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetCategoriesPostOne: async (caseSetCategory: CaseSetCategory, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSetCategory' is not null or undefined
            assertParamExists('caseSetCategoriesPostOne', 'caseSetCategory', caseSetCategory)
            const localVarPath = `/v1/case_set_categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Categories
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetCategoriesPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseSetCategoriesPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_set_categories/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Categories
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetCategoriesPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseSetCategoriesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_set_categories/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Categories
         * @param {Array<CaseSetCategory>} caseSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetCategoriesPostSome: async (caseSetCategory: Array<CaseSetCategory>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSetCategory' is not null or undefined
            assertParamExists('caseSetCategoriesPostSome', 'caseSetCategory', caseSetCategory)
            const localVarPath = `/v1/case_set_categories/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Categories
         * @param {string} objectId 
         * @param {CaseSetCategory} caseSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetCategoriesPutOne: async (objectId: string, caseSetCategory: CaseSetCategory, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetCategoriesPutOne', 'objectId', objectId)
            // verify required parameter 'caseSetCategory' is not null or undefined
            assertParamExists('caseSetCategoriesPutOne', 'caseSetCategory', caseSetCategory)
            const localVarPath = `/v1/case_set_categories/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Categories
         * @param {Array<CaseSetCategory>} caseSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetCategoriesPutSome: async (caseSetCategory: Array<CaseSetCategory>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSetCategory' is not null or undefined
            assertParamExists('caseSetCategoriesPutSome', 'caseSetCategory', caseSetCategory)
            const localVarPath = `/v1/case_set_categories/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Data Collection Links
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetDataCollectionLinksDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_set_data_collection_links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Data Collection Links
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetDataCollectionLinksDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetDataCollectionLinksDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_set_data_collection_links/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Data Collection Links
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetDataCollectionLinksDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseSetDataCollectionLinksDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_set_data_collection_links/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Data Collection Links
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetDataCollectionLinksGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_set_data_collection_links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Data Collection Links
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetDataCollectionLinksGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetDataCollectionLinksGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_set_data_collection_links/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Data Collection Links
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetDataCollectionLinksGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseSetDataCollectionLinksGetSome', 'ids', ids)
            const localVarPath = `/v1/case_set_data_collection_links/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Data Collection Links
         * @param {CaseSetDataCollectionLink} caseSetDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetDataCollectionLinksPostOne: async (caseSetDataCollectionLink: CaseSetDataCollectionLink, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSetDataCollectionLink' is not null or undefined
            assertParamExists('caseSetDataCollectionLinksPostOne', 'caseSetDataCollectionLink', caseSetDataCollectionLink)
            const localVarPath = `/v1/case_set_data_collection_links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetDataCollectionLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Data Collection Links
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetDataCollectionLinksPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseSetDataCollectionLinksPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_set_data_collection_links/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Data Collection Links
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetDataCollectionLinksPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseSetDataCollectionLinksPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_set_data_collection_links/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Data Collection Links
         * @param {Array<CaseSetDataCollectionLink>} caseSetDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetDataCollectionLinksPostSome: async (caseSetDataCollectionLink: Array<CaseSetDataCollectionLink>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSetDataCollectionLink' is not null or undefined
            assertParamExists('caseSetDataCollectionLinksPostSome', 'caseSetDataCollectionLink', caseSetDataCollectionLink)
            const localVarPath = `/v1/case_set_data_collection_links/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetDataCollectionLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Data Collection Links
         * @param {string} objectId 
         * @param {CaseSetDataCollectionLink} caseSetDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetDataCollectionLinksPutOne: async (objectId: string, caseSetDataCollectionLink: CaseSetDataCollectionLink, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetDataCollectionLinksPutOne', 'objectId', objectId)
            // verify required parameter 'caseSetDataCollectionLink' is not null or undefined
            assertParamExists('caseSetDataCollectionLinksPutOne', 'caseSetDataCollectionLink', caseSetDataCollectionLink)
            const localVarPath = `/v1/case_set_data_collection_links/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetDataCollectionLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Data Collection Links
         * @param {Array<CaseSetDataCollectionLink>} caseSetDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetDataCollectionLinksPutSome: async (caseSetDataCollectionLink: Array<CaseSetDataCollectionLink>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSetDataCollectionLink' is not null or undefined
            assertParamExists('caseSetDataCollectionLinksPutSome', 'caseSetDataCollectionLink', caseSetDataCollectionLink)
            const localVarPath = `/v1/case_set_data_collection_links/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetDataCollectionLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetMembersDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Members
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetMembersDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetMembersDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Members
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetMembersDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseSetMembersDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetMembersGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Members
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetMembersGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetMembersGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Members
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetMembersGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseSetMembersGetSome', 'ids', ids)
            const localVarPath = `/v1/case_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Members
         * @param {CaseSetMember} caseSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetMembersPostOne: async (caseSetMember: CaseSetMember, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSetMember' is not null or undefined
            assertParamExists('caseSetMembersPostOne', 'caseSetMember', caseSetMember)
            const localVarPath = `/v1/case_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Members
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetMembersPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseSetMembersPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_set_members/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Members
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetMembersPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseSetMembersPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_set_members/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Members
         * @param {Array<CaseSetMember>} caseSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetMembersPostSome: async (caseSetMember: Array<CaseSetMember>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSetMember' is not null or undefined
            assertParamExists('caseSetMembersPostSome', 'caseSetMember', caseSetMember)
            const localVarPath = `/v1/case_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Members
         * @param {string} objectId 
         * @param {CaseSetMember} caseSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetMembersPutOne: async (objectId: string, caseSetMember: CaseSetMember, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetMembersPutOne', 'objectId', objectId)
            // verify required parameter 'caseSetMember' is not null or undefined
            assertParamExists('caseSetMembersPutOne', 'caseSetMember', caseSetMember)
            const localVarPath = `/v1/case_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Members
         * @param {Array<CaseSetMember>} caseSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetMembersPutSome: async (caseSetMember: Array<CaseSetMember>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSetMember' is not null or undefined
            assertParamExists('caseSetMembersPutSome', 'caseSetMember', caseSetMember)
            const localVarPath = `/v1/case_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Statuses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetStatusesDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_set_statuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Statuses
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetStatusesDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetStatusesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_set_statuses/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Statuses
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetStatusesDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseSetStatusesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_set_statuses/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Statuses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetStatusesGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_set_statuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Statuses
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetStatusesGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetStatusesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_set_statuses/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Statuses
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetStatusesGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseSetStatusesGetSome', 'ids', ids)
            const localVarPath = `/v1/case_set_statuses/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Statuses
         * @param {CaseSetStatus} caseSetStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetStatusesPostOne: async (caseSetStatus: CaseSetStatus, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSetStatus' is not null or undefined
            assertParamExists('caseSetStatusesPostOne', 'caseSetStatus', caseSetStatus)
            const localVarPath = `/v1/case_set_statuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetStatus, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Statuses
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetStatusesPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseSetStatusesPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_set_statuses/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Statuses
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetStatusesPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseSetStatusesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_set_statuses/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Statuses
         * @param {Array<CaseSetStatus>} caseSetStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetStatusesPostSome: async (caseSetStatus: Array<CaseSetStatus>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSetStatus' is not null or undefined
            assertParamExists('caseSetStatusesPostSome', 'caseSetStatus', caseSetStatus)
            const localVarPath = `/v1/case_set_statuses/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetStatus, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Statuses
         * @param {string} objectId 
         * @param {CaseSetStatus} caseSetStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetStatusesPutOne: async (objectId: string, caseSetStatus: CaseSetStatus, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetStatusesPutOne', 'objectId', objectId)
            // verify required parameter 'caseSetStatus' is not null or undefined
            assertParamExists('caseSetStatusesPutOne', 'caseSetStatus', caseSetStatus)
            const localVarPath = `/v1/case_set_statuses/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetStatus, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Statuses
         * @param {Array<CaseSetStatus>} caseSetStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetStatusesPutSome: async (caseSetStatus: Array<CaseSetStatus>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSetStatus' is not null or undefined
            assertParamExists('caseSetStatusesPutSome', 'caseSetStatus', caseSetStatus)
            const localVarPath = `/v1/case_set_statuses/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetStatus, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetsDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Sets
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetsDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetsDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseSetsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetsGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Sets
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetsGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetsGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseSetsGetSome', 'ids', ids)
            const localVarPath = `/v1/case_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetsPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseSetsPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_sets/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetsPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseSetsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_sets/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Sets
         * @param {string} objectId 
         * @param {CaseSet} caseSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetsPutOne: async (objectId: string, caseSet: CaseSet, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetsPutOne', 'objectId', objectId)
            // verify required parameter 'caseSet' is not null or undefined
            assertParamExists('caseSetsPutOne', 'caseSet', caseSet)
            const localVarPath = `/v1/case_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Sets
         * @param {Array<CaseSet>} caseSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetsPutSome: async (caseSet: Array<CaseSet>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSet' is not null or undefined
            assertParamExists('caseSetsPutSome', 'caseSet', caseSet)
            const localVarPath = `/v1/case_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Set Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetMembersDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_type_col_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Set Members
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetMembersDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeColSetMembersDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_type_col_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Set Members
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetMembersDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypeColSetMembersDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_type_col_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Set Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetMembersGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_type_col_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Set Members
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetMembersGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeColSetMembersGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_type_col_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Set Members
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetMembersGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypeColSetMembersGetSome', 'ids', ids)
            const localVarPath = `/v1/case_type_col_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Set Members
         * @param {CaseTypeColSetMember} caseTypeColSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetMembersPostOne: async (caseTypeColSetMember: CaseTypeColSetMember, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeColSetMember' is not null or undefined
            assertParamExists('caseTypeColSetMembersPostOne', 'caseTypeColSetMember', caseTypeColSetMember)
            const localVarPath = `/v1/case_type_col_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeColSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Set Members
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetMembersPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypeColSetMembersPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_type_col_set_members/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Set Members
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetMembersPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypeColSetMembersPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_type_col_set_members/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Set Members
         * @param {Array<CaseTypeColSetMember>} caseTypeColSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetMembersPostSome: async (caseTypeColSetMember: Array<CaseTypeColSetMember>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeColSetMember' is not null or undefined
            assertParamExists('caseTypeColSetMembersPostSome', 'caseTypeColSetMember', caseTypeColSetMember)
            const localVarPath = `/v1/case_type_col_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeColSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Set Members
         * @param {string} objectId 
         * @param {CaseTypeColSetMember} caseTypeColSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetMembersPutOne: async (objectId: string, caseTypeColSetMember: CaseTypeColSetMember, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeColSetMembersPutOne', 'objectId', objectId)
            // verify required parameter 'caseTypeColSetMember' is not null or undefined
            assertParamExists('caseTypeColSetMembersPutOne', 'caseTypeColSetMember', caseTypeColSetMember)
            const localVarPath = `/v1/case_type_col_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeColSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Set Members
         * @param {Array<CaseTypeColSetMember>} caseTypeColSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetMembersPutSome: async (caseTypeColSetMember: Array<CaseTypeColSetMember>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeColSetMember' is not null or undefined
            assertParamExists('caseTypeColSetMembersPutSome', 'caseTypeColSetMember', caseTypeColSetMember)
            const localVarPath = `/v1/case_type_col_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeColSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetsDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_type_col_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Sets
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetsDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeColSetsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_type_col_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetsDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypeColSetsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_type_col_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetsGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_type_col_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Sets
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetsGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeColSetsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_type_col_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetsGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypeColSetsGetSome', 'ids', ids)
            const localVarPath = `/v1/case_type_col_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Sets
         * @param {CaseTypeColSet} caseTypeColSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetsPostOne: async (caseTypeColSet: CaseTypeColSet, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeColSet' is not null or undefined
            assertParamExists('caseTypeColSetsPostOne', 'caseTypeColSet', caseTypeColSet)
            const localVarPath = `/v1/case_type_col_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeColSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetsPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypeColSetsPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_type_col_sets/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetsPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypeColSetsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_type_col_sets/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Sets
         * @param {Array<CaseTypeColSet>} caseTypeColSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetsPostSome: async (caseTypeColSet: Array<CaseTypeColSet>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeColSet' is not null or undefined
            assertParamExists('caseTypeColSetsPostSome', 'caseTypeColSet', caseTypeColSet)
            const localVarPath = `/v1/case_type_col_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeColSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Casetypecolset Casetypecol
         * @param {string} caseTypeColSetId 
         * @param {UpdateCaseTypeColSetCaseTypeColsRequestBody} updateCaseTypeColSetCaseTypeColsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetsPutCaseTypeCols: async (caseTypeColSetId: string, updateCaseTypeColSetCaseTypeColsRequestBody: UpdateCaseTypeColSetCaseTypeColsRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeColSetId' is not null or undefined
            assertParamExists('caseTypeColSetsPutCaseTypeCols', 'caseTypeColSetId', caseTypeColSetId)
            // verify required parameter 'updateCaseTypeColSetCaseTypeColsRequestBody' is not null or undefined
            assertParamExists('caseTypeColSetsPutCaseTypeCols', 'updateCaseTypeColSetCaseTypeColsRequestBody', updateCaseTypeColSetCaseTypeColsRequestBody)
            const localVarPath = `/v1/case_type_col_sets/{case_type_col_set_id}/case_type_cols`
                .replace(`{${"case_type_col_set_id"}}`, encodeURIComponent(String(caseTypeColSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCaseTypeColSetCaseTypeColsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Sets
         * @param {string} objectId 
         * @param {CaseTypeColSet} caseTypeColSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetsPutOne: async (objectId: string, caseTypeColSet: CaseTypeColSet, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeColSetsPutOne', 'objectId', objectId)
            // verify required parameter 'caseTypeColSet' is not null or undefined
            assertParamExists('caseTypeColSetsPutOne', 'caseTypeColSet', caseTypeColSet)
            const localVarPath = `/v1/case_type_col_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeColSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Sets
         * @param {Array<CaseTypeColSet>} caseTypeColSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetsPutSome: async (caseTypeColSet: Array<CaseTypeColSet>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeColSet' is not null or undefined
            assertParamExists('caseTypeColSetsPutSome', 'caseTypeColSet', caseTypeColSet)
            const localVarPath = `/v1/case_type_col_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeColSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Cols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColsDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_type_cols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Cols
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColsDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeColsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_type_cols/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Cols
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColsDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypeColsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_type_cols/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Cols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColsGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_type_cols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Cols
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColsGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeColsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_type_cols/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Cols
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColsGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypeColsGetSome', 'ids', ids)
            const localVarPath = `/v1/case_type_cols/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Cols
         * @param {CaseTypeCol} caseTypeCol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColsPostOne: async (caseTypeCol: CaseTypeCol, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeCol' is not null or undefined
            assertParamExists('caseTypeColsPostOne', 'caseTypeCol', caseTypeCol)
            const localVarPath = `/v1/case_type_cols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeCol, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Cols
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColsPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypeColsPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_type_cols/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Cols
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColsPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypeColsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_type_cols/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Cols
         * @param {Array<CaseTypeCol>} caseTypeCol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColsPostSome: async (caseTypeCol: Array<CaseTypeCol>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeCol' is not null or undefined
            assertParamExists('caseTypeColsPostSome', 'caseTypeCol', caseTypeCol)
            const localVarPath = `/v1/case_type_cols/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeCol, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Cols
         * @param {string} objectId 
         * @param {CaseTypeCol} caseTypeCol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColsPutOne: async (objectId: string, caseTypeCol: CaseTypeCol, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeColsPutOne', 'objectId', objectId)
            // verify required parameter 'caseTypeCol' is not null or undefined
            assertParamExists('caseTypeColsPutOne', 'caseTypeCol', caseTypeCol)
            const localVarPath = `/v1/case_type_cols/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeCol, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Cols
         * @param {Array<CaseTypeCol>} caseTypeCol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColsPutSome: async (caseTypeCol: Array<CaseTypeCol>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeCol' is not null or undefined
            assertParamExists('caseTypeColsPutSome', 'caseTypeCol', caseTypeCol)
            const localVarPath = `/v1/case_type_cols/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeCol, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetCategoriesDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_type_set_categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Categories
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetCategoriesDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeSetCategoriesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_type_set_categories/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Categories
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetCategoriesDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypeSetCategoriesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_type_set_categories/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetCategoriesGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_type_set_categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Categories
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetCategoriesGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeSetCategoriesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_type_set_categories/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Categories
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetCategoriesGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypeSetCategoriesGetSome', 'ids', ids)
            const localVarPath = `/v1/case_type_set_categories/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Categories
         * @param {CaseTypeSetCategory} caseTypeSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetCategoriesPostOne: async (caseTypeSetCategory: CaseTypeSetCategory, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeSetCategory' is not null or undefined
            assertParamExists('caseTypeSetCategoriesPostOne', 'caseTypeSetCategory', caseTypeSetCategory)
            const localVarPath = `/v1/case_type_set_categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeSetCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Categories
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetCategoriesPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypeSetCategoriesPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_type_set_categories/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Categories
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetCategoriesPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypeSetCategoriesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_type_set_categories/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Categories
         * @param {Array<CaseTypeSetCategory>} caseTypeSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetCategoriesPostSome: async (caseTypeSetCategory: Array<CaseTypeSetCategory>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeSetCategory' is not null or undefined
            assertParamExists('caseTypeSetCategoriesPostSome', 'caseTypeSetCategory', caseTypeSetCategory)
            const localVarPath = `/v1/case_type_set_categories/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeSetCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Categories
         * @param {string} objectId 
         * @param {CaseTypeSetCategory} caseTypeSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetCategoriesPutOne: async (objectId: string, caseTypeSetCategory: CaseTypeSetCategory, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeSetCategoriesPutOne', 'objectId', objectId)
            // verify required parameter 'caseTypeSetCategory' is not null or undefined
            assertParamExists('caseTypeSetCategoriesPutOne', 'caseTypeSetCategory', caseTypeSetCategory)
            const localVarPath = `/v1/case_type_set_categories/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeSetCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Categories
         * @param {Array<CaseTypeSetCategory>} caseTypeSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetCategoriesPutSome: async (caseTypeSetCategory: Array<CaseTypeSetCategory>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeSetCategory' is not null or undefined
            assertParamExists('caseTypeSetCategoriesPutSome', 'caseTypeSetCategory', caseTypeSetCategory)
            const localVarPath = `/v1/case_type_set_categories/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeSetCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetMembersDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_type_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Members
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetMembersDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeSetMembersDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_type_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Members
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetMembersDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypeSetMembersDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_type_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetMembersGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_type_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Members
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetMembersGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeSetMembersGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_type_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Members
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetMembersGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypeSetMembersGetSome', 'ids', ids)
            const localVarPath = `/v1/case_type_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Members
         * @param {CaseTypeSetMember} caseTypeSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetMembersPostOne: async (caseTypeSetMember: CaseTypeSetMember, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeSetMember' is not null or undefined
            assertParamExists('caseTypeSetMembersPostOne', 'caseTypeSetMember', caseTypeSetMember)
            const localVarPath = `/v1/case_type_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Members
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetMembersPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypeSetMembersPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_type_set_members/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Members
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetMembersPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypeSetMembersPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_type_set_members/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Members
         * @param {Array<CaseTypeSetMember>} caseTypeSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetMembersPostSome: async (caseTypeSetMember: Array<CaseTypeSetMember>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeSetMember' is not null or undefined
            assertParamExists('caseTypeSetMembersPostSome', 'caseTypeSetMember', caseTypeSetMember)
            const localVarPath = `/v1/case_type_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Members
         * @param {string} objectId 
         * @param {CaseTypeSetMember} caseTypeSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetMembersPutOne: async (objectId: string, caseTypeSetMember: CaseTypeSetMember, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeSetMembersPutOne', 'objectId', objectId)
            // verify required parameter 'caseTypeSetMember' is not null or undefined
            assertParamExists('caseTypeSetMembersPutOne', 'caseTypeSetMember', caseTypeSetMember)
            const localVarPath = `/v1/case_type_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Members
         * @param {Array<CaseTypeSetMember>} caseTypeSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetMembersPutSome: async (caseTypeSetMember: Array<CaseTypeSetMember>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeSetMember' is not null or undefined
            assertParamExists('caseTypeSetMembersPutSome', 'caseTypeSetMember', caseTypeSetMember)
            const localVarPath = `/v1/case_type_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetsDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_type_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Sets
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetsDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeSetsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_type_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetsDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypeSetsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_type_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetsGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_type_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Sets
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetsGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeSetsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_type_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetsGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypeSetsGetSome', 'ids', ids)
            const localVarPath = `/v1/case_type_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Sets
         * @param {CaseTypeSet} caseTypeSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetsPostOne: async (caseTypeSet: CaseTypeSet, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeSet' is not null or undefined
            assertParamExists('caseTypeSetsPostOne', 'caseTypeSet', caseTypeSet)
            const localVarPath = `/v1/case_type_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetsPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypeSetsPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_type_sets/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetsPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypeSetsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_type_sets/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Sets
         * @param {Array<CaseTypeSet>} caseTypeSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetsPostSome: async (caseTypeSet: Array<CaseTypeSet>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeSet' is not null or undefined
            assertParamExists('caseTypeSetsPostSome', 'caseTypeSet', caseTypeSet)
            const localVarPath = `/v1/case_type_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Casetypeset Casetype
         * @param {string} caseTypeSetId 
         * @param {UpdateCaseTypeSetCaseTypesRequestBody} updateCaseTypeSetCaseTypesRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetsPutCaseTypes: async (caseTypeSetId: string, updateCaseTypeSetCaseTypesRequestBody: UpdateCaseTypeSetCaseTypesRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeSetId' is not null or undefined
            assertParamExists('caseTypeSetsPutCaseTypes', 'caseTypeSetId', caseTypeSetId)
            // verify required parameter 'updateCaseTypeSetCaseTypesRequestBody' is not null or undefined
            assertParamExists('caseTypeSetsPutCaseTypes', 'updateCaseTypeSetCaseTypesRequestBody', updateCaseTypeSetCaseTypesRequestBody)
            const localVarPath = `/v1/case_type_sets/{case_type_set_id}/case_types`
                .replace(`{${"case_type_set_id"}}`, encodeURIComponent(String(caseTypeSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCaseTypeSetCaseTypesRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Sets
         * @param {string} objectId 
         * @param {CaseTypeSet} caseTypeSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetsPutOne: async (objectId: string, caseTypeSet: CaseTypeSet, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeSetsPutOne', 'objectId', objectId)
            // verify required parameter 'caseTypeSet' is not null or undefined
            assertParamExists('caseTypeSetsPutOne', 'caseTypeSet', caseTypeSet)
            const localVarPath = `/v1/case_type_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Sets
         * @param {Array<CaseTypeSet>} caseTypeSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetsPutSome: async (caseTypeSet: Array<CaseTypeSet>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeSet' is not null or undefined
            assertParamExists('caseTypeSetsPutSome', 'caseTypeSet', caseTypeSet)
            const localVarPath = `/v1/case_type_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypesDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Types
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypesDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_types/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Types
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypesDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_types/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypesGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Types
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypesGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_types/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Types
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypesGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypesGetSome', 'ids', ids)
            const localVarPath = `/v1/case_types/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Types
         * @param {CaseType} caseType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypesPostOne: async (caseType: CaseType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseType' is not null or undefined
            assertParamExists('caseTypesPostOne', 'caseType', caseType)
            const localVarPath = `/v1/case_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Types
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypesPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypesPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_types/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Types
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypesPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_types/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Types
         * @param {Array<CaseType>} caseType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypesPostSome: async (caseType: Array<CaseType>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseType' is not null or undefined
            assertParamExists('caseTypesPostSome', 'caseType', caseType)
            const localVarPath = `/v1/case_types/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Types
         * @param {string} objectId 
         * @param {CaseType} caseType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypesPutOne: async (objectId: string, caseType: CaseType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypesPutOne', 'objectId', objectId)
            // verify required parameter 'caseType' is not null or undefined
            assertParamExists('caseTypesPutOne', 'caseType', caseType)
            const localVarPath = `/v1/case_types/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Types
         * @param {Array<CaseType>} caseType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypesPutSome: async (caseType: Array<CaseType>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseType' is not null or undefined
            assertParamExists('caseTypesPutSome', 'caseType', caseType)
            const localVarPath = `/v1/case_types/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A class representing a case.
         * @summary Cases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/cases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A class representing a case.
         * @summary Cases
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('casesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/cases/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A class representing a case.
         * @summary Cases
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('casesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/cases/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A class representing a case.
         * @summary Cases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/cases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A class representing a case.
         * @summary Cases
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('casesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/cases/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A class representing a case.
         * @summary Cases
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('casesGetSome', 'ids', ids)
            const localVarPath = `/v1/cases/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A class representing a case.
         * @summary Cases
         * @param {Case} _case 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesPostOne: async (_case: Case, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_case' is not null or undefined
            assertParamExists('casesPostOne', '_case', _case)
            const localVarPath = `/v1/cases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(_case, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A class representing a case.
         * @summary Cases
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('casesPostQuery', 'filter', filter)
            const localVarPath = `/v1/cases/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A class representing a case.
         * @summary Cases
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('casesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/cases/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A class representing a case.
         * @summary Cases
         * @param {Array<Case>} _case 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesPostSome: async (_case: Array<Case>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_case' is not null or undefined
            assertParamExists('casesPostSome', '_case', _case)
            const localVarPath = `/v1/cases/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(_case, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A class representing a case.
         * @summary Cases
         * @param {string} objectId 
         * @param {Case} _case 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesPutOne: async (objectId: string, _case: Case, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('casesPutOne', 'objectId', objectId)
            // verify required parameter '_case' is not null or undefined
            assertParamExists('casesPutOne', '_case', _case)
            const localVarPath = `/v1/cases/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(_case, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A class representing a case.
         * @summary Cases
         * @param {Array<Case>} _case 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesPutSome: async (_case: Array<Case>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_case' is not null or undefined
            assertParamExists('casesPutSome', '_case', _case)
            const localVarPath = `/v1/cases/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(_case, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colsDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/cols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cols
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colsDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('colsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/cols/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cols
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colsDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('colsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/cols/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colsGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/cols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cols
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colsGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('colsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/cols/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cols
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colsGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('colsGetSome', 'ids', ids)
            const localVarPath = `/v1/cols/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cols
         * @param {Col} col 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colsPostOne: async (col: Col, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'col' is not null or undefined
            assertParamExists('colsPostOne', 'col', col)
            const localVarPath = `/v1/cols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(col, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cols
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colsPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('colsPostQuery', 'filter', filter)
            const localVarPath = `/v1/cols/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cols
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colsPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('colsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/cols/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cols
         * @param {Array<Col>} col 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colsPostSome: async (col: Array<Col>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'col' is not null or undefined
            assertParamExists('colsPostSome', 'col', col)
            const localVarPath = `/v1/cols/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(col, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cols
         * @param {string} objectId 
         * @param {Col} col 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colsPutOne: async (objectId: string, col: Col, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('colsPutOne', 'objectId', objectId)
            // verify required parameter 'col' is not null or undefined
            assertParamExists('colsPutOne', 'col', col)
            const localVarPath = `/v1/cols/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(col, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cols
         * @param {Array<Col>} col 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colsPutSome: async (col: Array<Col>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'col' is not null or undefined
            assertParamExists('colsPutSome', 'col', col)
            const localVarPath = `/v1/cols/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(col, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Completecasetype
         * @param {string} caseTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeCaseTypesGetOne: async (caseTypeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeId' is not null or undefined
            assertParamExists('completeCaseTypesGetOne', 'caseTypeId', caseTypeId)
            const localVarPath = `/v1/complete_case_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (caseTypeId !== undefined) {
                localVarQueryParameter['case_type_id'] = caseTypeId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Caseset
         * @param {CreateCaseSetRequestBody} createCaseSetRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCaseSet: async (createCaseSetRequestBody: CreateCaseSetRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCaseSetRequestBody' is not null or undefined
            assertParamExists('createCaseSet', 'createCaseSetRequestBody', createCaseSetRequestBody)
            const localVarPath = `/v1/create/case_set`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCaseSetRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cases
         * @param {CreateCasesRequestBody} createCasesRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCases: async (createCasesRequestBody: CreateCasesRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCasesRequestBody' is not null or undefined
            assertParamExists('createCases', 'createCasesRequestBody', createCasesRequestBody)
            const localVarPath = `/v1/create/cases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCasesRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dims
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dimsDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/dims`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dims
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dimsDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dimsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/dims/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dims
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dimsDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('dimsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/dims/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dims
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dimsGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/dims`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dims
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dimsGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dimsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/dims/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dims
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dimsGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('dimsGetSome', 'ids', ids)
            const localVarPath = `/v1/dims/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dims
         * @param {Dim} dim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dimsPostOne: async (dim: Dim, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dim' is not null or undefined
            assertParamExists('dimsPostOne', 'dim', dim)
            const localVarPath = `/v1/dims`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dim, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dims
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dimsPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('dimsPostQuery', 'filter', filter)
            const localVarPath = `/v1/dims/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dims
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dimsPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('dimsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/dims/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dims
         * @param {Array<Dim>} dim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dimsPostSome: async (dim: Array<Dim>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dim' is not null or undefined
            assertParamExists('dimsPostSome', 'dim', dim)
            const localVarPath = `/v1/dims/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dim, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dims
         * @param {string} objectId 
         * @param {Dim} dim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dimsPutOne: async (objectId: string, dim: Dim, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dimsPutOne', 'objectId', objectId)
            // verify required parameter 'dim' is not null or undefined
            assertParamExists('dimsPutOne', 'dim', dim)
            const localVarPath = `/v1/dims/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dim, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dims
         * @param {Array<Dim>} dim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dimsPutSome: async (dim: Array<Dim>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dim' is not null or undefined
            assertParamExists('dimsPutSome', 'dim', dim)
            const localVarPath = `/v1/dims/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dim, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Genetic Distance Protocols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneticDistanceProtocolsDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/genetic_distance_protocols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Genetic Distance Protocols
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneticDistanceProtocolsDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('geneticDistanceProtocolsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/genetic_distance_protocols/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Genetic Distance Protocols
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneticDistanceProtocolsDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('geneticDistanceProtocolsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/genetic_distance_protocols/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Genetic Distance Protocols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneticDistanceProtocolsGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/genetic_distance_protocols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Genetic Distance Protocols
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneticDistanceProtocolsGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('geneticDistanceProtocolsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/genetic_distance_protocols/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Genetic Distance Protocols
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneticDistanceProtocolsGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('geneticDistanceProtocolsGetSome', 'ids', ids)
            const localVarPath = `/v1/genetic_distance_protocols/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Genetic Distance Protocols
         * @param {GeneticDistanceProtocol} geneticDistanceProtocol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneticDistanceProtocolsPostOne: async (geneticDistanceProtocol: GeneticDistanceProtocol, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'geneticDistanceProtocol' is not null or undefined
            assertParamExists('geneticDistanceProtocolsPostOne', 'geneticDistanceProtocol', geneticDistanceProtocol)
            const localVarPath = `/v1/genetic_distance_protocols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(geneticDistanceProtocol, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Genetic Distance Protocols
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneticDistanceProtocolsPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('geneticDistanceProtocolsPostQuery', 'filter', filter)
            const localVarPath = `/v1/genetic_distance_protocols/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Genetic Distance Protocols
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneticDistanceProtocolsPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('geneticDistanceProtocolsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/genetic_distance_protocols/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Genetic Distance Protocols
         * @param {Array<GeneticDistanceProtocol>} geneticDistanceProtocol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneticDistanceProtocolsPostSome: async (geneticDistanceProtocol: Array<GeneticDistanceProtocol>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'geneticDistanceProtocol' is not null or undefined
            assertParamExists('geneticDistanceProtocolsPostSome', 'geneticDistanceProtocol', geneticDistanceProtocol)
            const localVarPath = `/v1/genetic_distance_protocols/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(geneticDistanceProtocol, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Genetic Distance Protocols
         * @param {string} objectId 
         * @param {GeneticDistanceProtocol} geneticDistanceProtocol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneticDistanceProtocolsPutOne: async (objectId: string, geneticDistanceProtocol: GeneticDistanceProtocol, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('geneticDistanceProtocolsPutOne', 'objectId', objectId)
            // verify required parameter 'geneticDistanceProtocol' is not null or undefined
            assertParamExists('geneticDistanceProtocolsPutOne', 'geneticDistanceProtocol', geneticDistanceProtocol)
            const localVarPath = `/v1/genetic_distance_protocols/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(geneticDistanceProtocol, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Genetic Distance Protocols
         * @param {Array<GeneticDistanceProtocol>} geneticDistanceProtocol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneticDistanceProtocolsPutSome: async (geneticDistanceProtocol: Array<GeneticDistanceProtocol>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'geneticDistanceProtocol' is not null or undefined
            assertParamExists('geneticDistanceProtocolsPutSome', 'geneticDistanceProtocol', geneticDistanceProtocol)
            const localVarPath = `/v1/genetic_distance_protocols/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(geneticDistanceProtocol, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve  Case Ids By Query
         * @param {CaseQuery} caseQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCaseIdsByQuery: async (caseQuery: CaseQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseQuery' is not null or undefined
            assertParamExists('retrieveCaseIdsByQuery', 'caseQuery', caseQuery)
            const localVarPath = `/v1/retrieve/case_ids_by_query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve  Case Rights
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCaseRights: async (requestBody: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('retrieveCaseRights', 'requestBody', requestBody)
            const localVarPath = `/v1/retrieve/case_rights`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve  Case Set Rights
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCaseSetRights: async (requestBody: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('retrieveCaseSetRights', 'requestBody', requestBody)
            const localVarPath = `/v1/retrieve/case_set_rights`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Casesetstats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCaseSetStats: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/retrieve/case_set_stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Casetypestats
         * @param {RetrieveCaseTypeStatsCommand} retrieveCaseTypeStatsCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCaseTypeStats: async (retrieveCaseTypeStatsCommand: RetrieveCaseTypeStatsCommand, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'retrieveCaseTypeStatsCommand' is not null or undefined
            assertParamExists('retrieveCaseTypeStats', 'retrieveCaseTypeStatsCommand', retrieveCaseTypeStatsCommand)
            const localVarPath = `/v1/retrieve/case_type_stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(retrieveCaseTypeStatsCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve  Cases By Ids
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCasesByIds: async (requestBody: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('retrieveCasesByIds', 'requestBody', requestBody)
            const localVarPath = `/v1/retrieve/cases_by_ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve  Genetic Sequence
         * @param {RetrieveGeneticSequenceRequestBody} retrieveGeneticSequenceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGeneticSequence: async (retrieveGeneticSequenceRequestBody: RetrieveGeneticSequenceRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'retrieveGeneticSequenceRequestBody' is not null or undefined
            assertParamExists('retrieveGeneticSequence', 'retrieveGeneticSequenceRequestBody', retrieveGeneticSequenceRequestBody)
            const localVarPath = `/v1/retrieve/genetic_sequence`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(retrieveGeneticSequenceRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve  Organization Contact
         * @param {RetrieveOrganizationContactRequestBody} retrieveOrganizationContactRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveOrganizationContact: async (retrieveOrganizationContactRequestBody: RetrieveOrganizationContactRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'retrieveOrganizationContactRequestBody' is not null or undefined
            assertParamExists('retrieveOrganizationContact', 'retrieveOrganizationContactRequestBody', retrieveOrganizationContactRequestBody)
            const localVarPath = `/v1/retrieve/organization_contact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(retrieveOrganizationContactRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve  Phylogenetic Tree
         * @param {RetrievePhylogeneticTreeRequestBody} retrievePhylogeneticTreeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePhylogeneticTree: async (retrievePhylogeneticTreeRequestBody: RetrievePhylogeneticTreeRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'retrievePhylogeneticTreeRequestBody' is not null or undefined
            assertParamExists('retrievePhylogeneticTree', 'retrievePhylogeneticTreeRequestBody', retrievePhylogeneticTreeRequestBody)
            const localVarPath = `/v1/retrieve/phylogenetic_tree`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(retrievePhylogeneticTreeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithm Classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmClassesDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tree_algorithm_classes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithm Classes
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmClassesDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('treeAlgorithmClassesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/tree_algorithm_classes/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithm Classes
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmClassesDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('treeAlgorithmClassesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/tree_algorithm_classes/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithm Classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmClassesGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tree_algorithm_classes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithm Classes
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmClassesGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('treeAlgorithmClassesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/tree_algorithm_classes/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithm Classes
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmClassesGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('treeAlgorithmClassesGetSome', 'ids', ids)
            const localVarPath = `/v1/tree_algorithm_classes/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithm Classes
         * @param {TreeAlgorithmClass} treeAlgorithmClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmClassesPostOne: async (treeAlgorithmClass: TreeAlgorithmClass, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'treeAlgorithmClass' is not null or undefined
            assertParamExists('treeAlgorithmClassesPostOne', 'treeAlgorithmClass', treeAlgorithmClass)
            const localVarPath = `/v1/tree_algorithm_classes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(treeAlgorithmClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithm Classes
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmClassesPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('treeAlgorithmClassesPostQuery', 'filter', filter)
            const localVarPath = `/v1/tree_algorithm_classes/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithm Classes
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmClassesPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('treeAlgorithmClassesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/tree_algorithm_classes/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithm Classes
         * @param {Array<TreeAlgorithmClass>} treeAlgorithmClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmClassesPostSome: async (treeAlgorithmClass: Array<TreeAlgorithmClass>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'treeAlgorithmClass' is not null or undefined
            assertParamExists('treeAlgorithmClassesPostSome', 'treeAlgorithmClass', treeAlgorithmClass)
            const localVarPath = `/v1/tree_algorithm_classes/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(treeAlgorithmClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithm Classes
         * @param {string} objectId 
         * @param {TreeAlgorithmClass} treeAlgorithmClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmClassesPutOne: async (objectId: string, treeAlgorithmClass: TreeAlgorithmClass, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('treeAlgorithmClassesPutOne', 'objectId', objectId)
            // verify required parameter 'treeAlgorithmClass' is not null or undefined
            assertParamExists('treeAlgorithmClassesPutOne', 'treeAlgorithmClass', treeAlgorithmClass)
            const localVarPath = `/v1/tree_algorithm_classes/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(treeAlgorithmClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithm Classes
         * @param {Array<TreeAlgorithmClass>} treeAlgorithmClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmClassesPutSome: async (treeAlgorithmClass: Array<TreeAlgorithmClass>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'treeAlgorithmClass' is not null or undefined
            assertParamExists('treeAlgorithmClassesPutSome', 'treeAlgorithmClass', treeAlgorithmClass)
            const localVarPath = `/v1/tree_algorithm_classes/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(treeAlgorithmClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
         * @summary Tree Algorithms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmsDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tree_algorithms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
         * @summary Tree Algorithms
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmsDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('treeAlgorithmsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/tree_algorithms/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
         * @summary Tree Algorithms
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmsDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('treeAlgorithmsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/tree_algorithms/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
         * @summary Tree Algorithms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmsGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tree_algorithms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
         * @summary Tree Algorithms
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmsGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('treeAlgorithmsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/tree_algorithms/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
         * @summary Tree Algorithms
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmsGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('treeAlgorithmsGetSome', 'ids', ids)
            const localVarPath = `/v1/tree_algorithms/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
         * @summary Tree Algorithms
         * @param {TreeAlgorithm} treeAlgorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmsPostOne: async (treeAlgorithm: TreeAlgorithm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'treeAlgorithm' is not null or undefined
            assertParamExists('treeAlgorithmsPostOne', 'treeAlgorithm', treeAlgorithm)
            const localVarPath = `/v1/tree_algorithms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(treeAlgorithm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
         * @summary Tree Algorithms
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmsPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('treeAlgorithmsPostQuery', 'filter', filter)
            const localVarPath = `/v1/tree_algorithms/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
         * @summary Tree Algorithms
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmsPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('treeAlgorithmsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/tree_algorithms/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
         * @summary Tree Algorithms
         * @param {Array<TreeAlgorithm>} treeAlgorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmsPostSome: async (treeAlgorithm: Array<TreeAlgorithm>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'treeAlgorithm' is not null or undefined
            assertParamExists('treeAlgorithmsPostSome', 'treeAlgorithm', treeAlgorithm)
            const localVarPath = `/v1/tree_algorithms/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(treeAlgorithm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
         * @summary Tree Algorithms
         * @param {string} objectId 
         * @param {TreeAlgorithm} treeAlgorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmsPutOne: async (objectId: string, treeAlgorithm: TreeAlgorithm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('treeAlgorithmsPutOne', 'objectId', objectId)
            // verify required parameter 'treeAlgorithm' is not null or undefined
            assertParamExists('treeAlgorithmsPutOne', 'treeAlgorithm', treeAlgorithm)
            const localVarPath = `/v1/tree_algorithms/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(treeAlgorithm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
         * @summary Tree Algorithms
         * @param {Array<TreeAlgorithm>} treeAlgorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmsPutSome: async (treeAlgorithm: Array<TreeAlgorithm>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'treeAlgorithm' is not null or undefined
            assertParamExists('treeAlgorithmsPutSome', 'treeAlgorithm', treeAlgorithm)
            const localVarPath = `/v1/tree_algorithms/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(treeAlgorithm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CaseApi - functional programming interface
 * @export
 */
const CaseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CaseApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Case Data Collection Links
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseDataCollectionLinksDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseDataCollectionLinksDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Data Collection Links
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseDataCollectionLinksDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseDataCollectionLinksDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Data Collection Links
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseDataCollectionLinksDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseDataCollectionLinksDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Data Collection Links
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseDataCollectionLinksGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseDataCollectionLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseDataCollectionLinksGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Data Collection Links
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseDataCollectionLinksGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseDataCollectionLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseDataCollectionLinksGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Data Collection Links
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseDataCollectionLinksGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseDataCollectionLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseDataCollectionLinksGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Data Collection Links
         * @param {CaseDataCollectionLink} caseDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseDataCollectionLinksPostOne(caseDataCollectionLink: CaseDataCollectionLink, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseDataCollectionLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseDataCollectionLinksPostOne(caseDataCollectionLink, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Data Collection Links
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseDataCollectionLinksPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseDataCollectionLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseDataCollectionLinksPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Data Collection Links
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseDataCollectionLinksPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseDataCollectionLinksPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Data Collection Links
         * @param {Array<CaseDataCollectionLink>} caseDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseDataCollectionLinksPostSome(caseDataCollectionLink: Array<CaseDataCollectionLink>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseDataCollectionLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseDataCollectionLinksPostSome(caseDataCollectionLink, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Data Collection Links
         * @param {string} objectId 
         * @param {CaseDataCollectionLink} caseDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseDataCollectionLinksPutOne(objectId: string, caseDataCollectionLink: CaseDataCollectionLink, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseDataCollectionLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseDataCollectionLinksPutOne(objectId, caseDataCollectionLink, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Data Collection Links
         * @param {Array<CaseDataCollectionLink>} caseDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseDataCollectionLinksPutSome(caseDataCollectionLink: Array<CaseDataCollectionLink>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseDataCollectionLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseDataCollectionLinksPutSome(caseDataCollectionLink, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetCategoriesDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetCategoriesDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Categories
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetCategoriesDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetCategoriesDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Categories
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetCategoriesDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetCategoriesDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetCategoriesGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetCategoriesGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Categories
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetCategoriesGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSetCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetCategoriesGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Categories
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetCategoriesGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetCategoriesGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Categories
         * @param {CaseSetCategory} caseSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetCategoriesPostOne(caseSetCategory: CaseSetCategory, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSetCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetCategoriesPostOne(caseSetCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Categories
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetCategoriesPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetCategoriesPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Categories
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetCategoriesPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetCategoriesPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Categories
         * @param {Array<CaseSetCategory>} caseSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetCategoriesPostSome(caseSetCategory: Array<CaseSetCategory>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetCategoriesPostSome(caseSetCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Categories
         * @param {string} objectId 
         * @param {CaseSetCategory} caseSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetCategoriesPutOne(objectId: string, caseSetCategory: CaseSetCategory, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSetCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetCategoriesPutOne(objectId, caseSetCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Categories
         * @param {Array<CaseSetCategory>} caseSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetCategoriesPutSome(caseSetCategory: Array<CaseSetCategory>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetCategoriesPutSome(caseSetCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Data Collection Links
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetDataCollectionLinksDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetDataCollectionLinksDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Data Collection Links
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetDataCollectionLinksDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetDataCollectionLinksDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Data Collection Links
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetDataCollectionLinksDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetDataCollectionLinksDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Data Collection Links
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetDataCollectionLinksGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetDataCollectionLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetDataCollectionLinksGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Data Collection Links
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetDataCollectionLinksGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSetDataCollectionLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetDataCollectionLinksGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Data Collection Links
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetDataCollectionLinksGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetDataCollectionLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetDataCollectionLinksGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Data Collection Links
         * @param {CaseSetDataCollectionLink} caseSetDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetDataCollectionLinksPostOne(caseSetDataCollectionLink: CaseSetDataCollectionLink, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSetDataCollectionLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetDataCollectionLinksPostOne(caseSetDataCollectionLink, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Data Collection Links
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetDataCollectionLinksPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetDataCollectionLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetDataCollectionLinksPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Data Collection Links
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetDataCollectionLinksPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetDataCollectionLinksPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Data Collection Links
         * @param {Array<CaseSetDataCollectionLink>} caseSetDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetDataCollectionLinksPostSome(caseSetDataCollectionLink: Array<CaseSetDataCollectionLink>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetDataCollectionLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetDataCollectionLinksPostSome(caseSetDataCollectionLink, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Data Collection Links
         * @param {string} objectId 
         * @param {CaseSetDataCollectionLink} caseSetDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetDataCollectionLinksPutOne(objectId: string, caseSetDataCollectionLink: CaseSetDataCollectionLink, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSetDataCollectionLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetDataCollectionLinksPutOne(objectId, caseSetDataCollectionLink, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Data Collection Links
         * @param {Array<CaseSetDataCollectionLink>} caseSetDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetDataCollectionLinksPutSome(caseSetDataCollectionLink: Array<CaseSetDataCollectionLink>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetDataCollectionLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetDataCollectionLinksPutSome(caseSetDataCollectionLink, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetMembersDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetMembersDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Members
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetMembersDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetMembersDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Members
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetMembersDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetMembersDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetMembersGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetMembersGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Members
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetMembersGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetMembersGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Members
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetMembersGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetMembersGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Members
         * @param {CaseSetMember} caseSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetMembersPostOne(caseSetMember: CaseSetMember, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetMembersPostOne(caseSetMember, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Members
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetMembersPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetMembersPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Members
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetMembersPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetMembersPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Members
         * @param {Array<CaseSetMember>} caseSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetMembersPostSome(caseSetMember: Array<CaseSetMember>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetMembersPostSome(caseSetMember, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Members
         * @param {string} objectId 
         * @param {CaseSetMember} caseSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetMembersPutOne(objectId: string, caseSetMember: CaseSetMember, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetMembersPutOne(objectId, caseSetMember, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Members
         * @param {Array<CaseSetMember>} caseSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetMembersPutSome(caseSetMember: Array<CaseSetMember>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetMembersPutSome(caseSetMember, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Statuses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetStatusesDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetStatusesDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Statuses
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetStatusesDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetStatusesDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Statuses
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetStatusesDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetStatusesDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Statuses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetStatusesGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetStatusesGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Statuses
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetStatusesGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSetStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetStatusesGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Statuses
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetStatusesGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetStatusesGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Statuses
         * @param {CaseSetStatus} caseSetStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetStatusesPostOne(caseSetStatus: CaseSetStatus, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSetStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetStatusesPostOne(caseSetStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Statuses
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetStatusesPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetStatusesPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Statuses
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetStatusesPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetStatusesPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Statuses
         * @param {Array<CaseSetStatus>} caseSetStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetStatusesPostSome(caseSetStatus: Array<CaseSetStatus>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetStatusesPostSome(caseSetStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Statuses
         * @param {string} objectId 
         * @param {CaseSetStatus} caseSetStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetStatusesPutOne(objectId: string, caseSetStatus: CaseSetStatus, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSetStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetStatusesPutOne(objectId, caseSetStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Set Statuses
         * @param {Array<CaseSetStatus>} caseSetStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetStatusesPutSome(caseSetStatus: Array<CaseSetStatus>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetStatusesPutSome(caseSetStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetsDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetsDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Sets
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetsDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetsDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetsDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetsDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetsGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetsGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Sets
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetsGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetsGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetsGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetsGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetsPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetsPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetsPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetsPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Sets
         * @param {string} objectId 
         * @param {CaseSet} caseSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetsPutOne(objectId: string, caseSet: CaseSet, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetsPutOne(objectId, caseSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Sets
         * @param {Array<CaseSet>} caseSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetsPutSome(caseSet: Array<CaseSet>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetsPutSome(caseSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Col Set Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetMembersDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetMembersDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Col Set Members
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetMembersDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetMembersDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Col Set Members
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetMembersDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetMembersDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Col Set Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetMembersGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeColSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetMembersGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Col Set Members
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetMembersGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeColSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetMembersGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Col Set Members
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetMembersGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeColSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetMembersGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Col Set Members
         * @param {CaseTypeColSetMember} caseTypeColSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetMembersPostOne(caseTypeColSetMember: CaseTypeColSetMember, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeColSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetMembersPostOne(caseTypeColSetMember, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Col Set Members
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetMembersPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeColSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetMembersPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Col Set Members
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetMembersPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetMembersPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Col Set Members
         * @param {Array<CaseTypeColSetMember>} caseTypeColSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetMembersPostSome(caseTypeColSetMember: Array<CaseTypeColSetMember>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeColSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetMembersPostSome(caseTypeColSetMember, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Col Set Members
         * @param {string} objectId 
         * @param {CaseTypeColSetMember} caseTypeColSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetMembersPutOne(objectId: string, caseTypeColSetMember: CaseTypeColSetMember, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeColSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetMembersPutOne(objectId, caseTypeColSetMember, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Col Set Members
         * @param {Array<CaseTypeColSetMember>} caseTypeColSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetMembersPutSome(caseTypeColSetMember: Array<CaseTypeColSetMember>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeColSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetMembersPutSome(caseTypeColSetMember, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Col Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetsDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetsDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Col Sets
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetsDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetsDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Col Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetsDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetsDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Col Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetsGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeColSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetsGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Col Sets
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetsGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeColSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetsGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Col Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetsGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeColSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetsGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Col Sets
         * @param {CaseTypeColSet} caseTypeColSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetsPostOne(caseTypeColSet: CaseTypeColSet, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeColSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetsPostOne(caseTypeColSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Col Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetsPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeColSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetsPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Col Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetsPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetsPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Col Sets
         * @param {Array<CaseTypeColSet>} caseTypeColSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetsPostSome(caseTypeColSet: Array<CaseTypeColSet>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeColSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetsPostSome(caseTypeColSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Casetypecolset Casetypecol
         * @param {string} caseTypeColSetId 
         * @param {UpdateCaseTypeColSetCaseTypeColsRequestBody} updateCaseTypeColSetCaseTypeColsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetsPutCaseTypeCols(caseTypeColSetId: string, updateCaseTypeColSetCaseTypeColsRequestBody: UpdateCaseTypeColSetCaseTypeColsRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeColSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetsPutCaseTypeCols(caseTypeColSetId, updateCaseTypeColSetCaseTypeColsRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Col Sets
         * @param {string} objectId 
         * @param {CaseTypeColSet} caseTypeColSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetsPutOne(objectId: string, caseTypeColSet: CaseTypeColSet, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeColSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetsPutOne(objectId, caseTypeColSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Col Sets
         * @param {Array<CaseTypeColSet>} caseTypeColSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetsPutSome(caseTypeColSet: Array<CaseTypeColSet>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeColSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetsPutSome(caseTypeColSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Cols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColsDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColsDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Cols
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColsDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColsDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Cols
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColsDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColsDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Cols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColsGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeCol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColsGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Cols
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColsGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeCol>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColsGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Cols
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColsGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeCol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColsGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Cols
         * @param {CaseTypeCol} caseTypeCol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColsPostOne(caseTypeCol: CaseTypeCol, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeCol>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColsPostOne(caseTypeCol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Cols
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColsPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeCol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColsPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Cols
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColsPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColsPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Cols
         * @param {Array<CaseTypeCol>} caseTypeCol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColsPostSome(caseTypeCol: Array<CaseTypeCol>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeCol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColsPostSome(caseTypeCol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Cols
         * @param {string} objectId 
         * @param {CaseTypeCol} caseTypeCol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColsPutOne(objectId: string, caseTypeCol: CaseTypeCol, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeCol>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColsPutOne(objectId, caseTypeCol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Cols
         * @param {Array<CaseTypeCol>} caseTypeCol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColsPutSome(caseTypeCol: Array<CaseTypeCol>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeCol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColsPutSome(caseTypeCol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Set Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetCategoriesDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetCategoriesDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Set Categories
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetCategoriesDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetCategoriesDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Set Categories
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetCategoriesDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetCategoriesDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Set Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetCategoriesGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSetCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetCategoriesGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Set Categories
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetCategoriesGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeSetCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetCategoriesGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Set Categories
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetCategoriesGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSetCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetCategoriesGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Set Categories
         * @param {CaseTypeSetCategory} caseTypeSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetCategoriesPostOne(caseTypeSetCategory: CaseTypeSetCategory, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeSetCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetCategoriesPostOne(caseTypeSetCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Set Categories
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetCategoriesPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSetCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetCategoriesPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Set Categories
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetCategoriesPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetCategoriesPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Set Categories
         * @param {Array<CaseTypeSetCategory>} caseTypeSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetCategoriesPostSome(caseTypeSetCategory: Array<CaseTypeSetCategory>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSetCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetCategoriesPostSome(caseTypeSetCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Set Categories
         * @param {string} objectId 
         * @param {CaseTypeSetCategory} caseTypeSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetCategoriesPutOne(objectId: string, caseTypeSetCategory: CaseTypeSetCategory, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeSetCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetCategoriesPutOne(objectId, caseTypeSetCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Set Categories
         * @param {Array<CaseTypeSetCategory>} caseTypeSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetCategoriesPutSome(caseTypeSetCategory: Array<CaseTypeSetCategory>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSetCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetCategoriesPutSome(caseTypeSetCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Set Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetMembersDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetMembersDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Set Members
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetMembersDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetMembersDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Set Members
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetMembersDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetMembersDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Set Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetMembersGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetMembersGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Set Members
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetMembersGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetMembersGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Set Members
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetMembersGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetMembersGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Set Members
         * @param {CaseTypeSetMember} caseTypeSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetMembersPostOne(caseTypeSetMember: CaseTypeSetMember, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetMembersPostOne(caseTypeSetMember, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Set Members
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetMembersPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetMembersPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Set Members
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetMembersPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetMembersPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Set Members
         * @param {Array<CaseTypeSetMember>} caseTypeSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetMembersPostSome(caseTypeSetMember: Array<CaseTypeSetMember>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetMembersPostSome(caseTypeSetMember, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Set Members
         * @param {string} objectId 
         * @param {CaseTypeSetMember} caseTypeSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetMembersPutOne(objectId: string, caseTypeSetMember: CaseTypeSetMember, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetMembersPutOne(objectId, caseTypeSetMember, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Set Members
         * @param {Array<CaseTypeSetMember>} caseTypeSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetMembersPutSome(caseTypeSetMember: Array<CaseTypeSetMember>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetMembersPutSome(caseTypeSetMember, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetsDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetsDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Sets
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetsDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetsDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetsDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetsDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetsGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetsGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Sets
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetsGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetsGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetsGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetsGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Sets
         * @param {CaseTypeSet} caseTypeSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetsPostOne(caseTypeSet: CaseTypeSet, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetsPostOne(caseTypeSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetsPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetsPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetsPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetsPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Sets
         * @param {Array<CaseTypeSet>} caseTypeSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetsPostSome(caseTypeSet: Array<CaseTypeSet>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetsPostSome(caseTypeSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Casetypeset Casetype
         * @param {string} caseTypeSetId 
         * @param {UpdateCaseTypeSetCaseTypesRequestBody} updateCaseTypeSetCaseTypesRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetsPutCaseTypes(caseTypeSetId: string, updateCaseTypeSetCaseTypesRequestBody: UpdateCaseTypeSetCaseTypesRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetsPutCaseTypes(caseTypeSetId, updateCaseTypeSetCaseTypesRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Sets
         * @param {string} objectId 
         * @param {CaseTypeSet} caseTypeSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetsPutOne(objectId: string, caseTypeSet: CaseTypeSet, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetsPutOne(objectId, caseTypeSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Type Sets
         * @param {Array<CaseTypeSet>} caseTypeSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetsPutSome(caseTypeSet: Array<CaseTypeSet>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetsPutSome(caseTypeSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypesDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypesDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Types
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypesDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypesDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Types
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypesDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypesDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypesGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypesGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Types
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypesGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypesGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Types
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypesGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypesGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Types
         * @param {CaseType} caseType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypesPostOne(caseType: CaseType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypesPostOne(caseType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Types
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypesPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypesPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Types
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypesPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypesPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Types
         * @param {Array<CaseType>} caseType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypesPostSome(caseType: Array<CaseType>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypesPostSome(caseType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Types
         * @param {string} objectId 
         * @param {CaseType} caseType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypesPutOne(objectId: string, caseType: CaseType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypesPutOne(objectId, caseType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Case Types
         * @param {Array<CaseType>} caseType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypesPutSome(caseType: Array<CaseType>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypesPutSome(caseType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A class representing a case.
         * @summary Cases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A class representing a case.
         * @summary Cases
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A class representing a case.
         * @summary Cases
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A class representing a case.
         * @summary Cases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Case>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A class representing a case.
         * @summary Cases
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Case>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A class representing a case.
         * @summary Cases
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Case>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A class representing a case.
         * @summary Cases
         * @param {Case} _case 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesPostOne(_case: Case, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Case>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesPostOne(_case, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A class representing a case.
         * @summary Cases
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Case>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A class representing a case.
         * @summary Cases
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A class representing a case.
         * @summary Cases
         * @param {Array<Case>} _case 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesPostSome(_case: Array<Case>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Case>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesPostSome(_case, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A class representing a case.
         * @summary Cases
         * @param {string} objectId 
         * @param {Case} _case 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesPutOne(objectId: string, _case: Case, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Case>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesPutOne(objectId, _case, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A class representing a case.
         * @summary Cases
         * @param {Array<Case>} _case 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesPutSome(_case: Array<Case>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Case>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesPutSome(_case, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Cols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async colsDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.colsDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Cols
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async colsDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.colsDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Cols
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async colsDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.colsDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Cols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async colsGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Col>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.colsGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Cols
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async colsGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Col>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.colsGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Cols
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async colsGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Col>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.colsGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Cols
         * @param {Col} col 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async colsPostOne(col: Col, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Col>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.colsPostOne(col, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Cols
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async colsPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Col>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.colsPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Cols
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async colsPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.colsPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Cols
         * @param {Array<Col>} col 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async colsPostSome(col: Array<Col>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Col>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.colsPostSome(col, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Cols
         * @param {string} objectId 
         * @param {Col} col 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async colsPutOne(objectId: string, col: Col, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Col>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.colsPutOne(objectId, col, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Cols
         * @param {Array<Col>} col 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async colsPutSome(col: Array<Col>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Col>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.colsPutSome(col, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Completecasetype
         * @param {string} caseTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeCaseTypesGetOne(caseTypeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompleteCaseType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeCaseTypesGetOne(caseTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Caseset
         * @param {CreateCaseSetRequestBody} createCaseSetRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCaseSet(createCaseSetRequestBody: CreateCaseSetRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCaseSet(createCaseSetRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Cases
         * @param {CreateCasesRequestBody} createCasesRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCases(createCasesRequestBody: CreateCasesRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Case>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCases(createCasesRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Dims
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dimsDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dimsDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Dims
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dimsDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dimsDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Dims
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dimsDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dimsDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Dims
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dimsGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dim>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dimsGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Dims
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dimsGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dimsGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Dims
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dimsGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dim>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dimsGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Dims
         * @param {Dim} dim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dimsPostOne(dim: Dim, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dimsPostOne(dim, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Dims
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dimsPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dim>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dimsPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Dims
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dimsPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dimsPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Dims
         * @param {Array<Dim>} dim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dimsPostSome(dim: Array<Dim>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dim>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dimsPostSome(dim, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Dims
         * @param {string} objectId 
         * @param {Dim} dim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dimsPutOne(objectId: string, dim: Dim, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dimsPutOne(objectId, dim, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Dims
         * @param {Array<Dim>} dim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dimsPutSome(dim: Array<Dim>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dim>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dimsPutSome(dim, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Genetic Distance Protocols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneticDistanceProtocolsDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneticDistanceProtocolsDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Genetic Distance Protocols
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneticDistanceProtocolsDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneticDistanceProtocolsDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Genetic Distance Protocols
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneticDistanceProtocolsDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneticDistanceProtocolsDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Genetic Distance Protocols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneticDistanceProtocolsGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GeneticDistanceProtocol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneticDistanceProtocolsGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Genetic Distance Protocols
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneticDistanceProtocolsGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneticDistanceProtocol>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneticDistanceProtocolsGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Genetic Distance Protocols
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneticDistanceProtocolsGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GeneticDistanceProtocol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneticDistanceProtocolsGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Genetic Distance Protocols
         * @param {GeneticDistanceProtocol} geneticDistanceProtocol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneticDistanceProtocolsPostOne(geneticDistanceProtocol: GeneticDistanceProtocol, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneticDistanceProtocol>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneticDistanceProtocolsPostOne(geneticDistanceProtocol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Genetic Distance Protocols
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneticDistanceProtocolsPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GeneticDistanceProtocol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneticDistanceProtocolsPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Genetic Distance Protocols
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneticDistanceProtocolsPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneticDistanceProtocolsPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Genetic Distance Protocols
         * @param {Array<GeneticDistanceProtocol>} geneticDistanceProtocol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneticDistanceProtocolsPostSome(geneticDistanceProtocol: Array<GeneticDistanceProtocol>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GeneticDistanceProtocol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneticDistanceProtocolsPostSome(geneticDistanceProtocol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Genetic Distance Protocols
         * @param {string} objectId 
         * @param {GeneticDistanceProtocol} geneticDistanceProtocol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneticDistanceProtocolsPutOne(objectId: string, geneticDistanceProtocol: GeneticDistanceProtocol, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneticDistanceProtocol>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneticDistanceProtocolsPutOne(objectId, geneticDistanceProtocol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Genetic Distance Protocols
         * @param {Array<GeneticDistanceProtocol>} geneticDistanceProtocol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneticDistanceProtocolsPutSome(geneticDistanceProtocol: Array<GeneticDistanceProtocol>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GeneticDistanceProtocol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneticDistanceProtocolsPutSome(geneticDistanceProtocol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Retrieve  Case Ids By Query
         * @param {CaseQuery} caseQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCaseIdsByQuery(caseQuery: CaseQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveCaseIdsByQuery(caseQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Retrieve  Case Rights
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCaseRights(requestBody: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseRights>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveCaseRights(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Retrieve  Case Set Rights
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCaseSetRights(requestBody: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetRights>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveCaseSetRights(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Casesetstats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCaseSetStats(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetStat>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveCaseSetStats(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Casetypestats
         * @param {RetrieveCaseTypeStatsCommand} retrieveCaseTypeStatsCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCaseTypeStats(retrieveCaseTypeStatsCommand: RetrieveCaseTypeStatsCommand, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeStat>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveCaseTypeStats(retrieveCaseTypeStatsCommand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Retrieve  Cases By Ids
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCasesByIds(requestBody: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Case>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveCasesByIds(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Retrieve  Genetic Sequence
         * @param {RetrieveGeneticSequenceRequestBody} retrieveGeneticSequenceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveGeneticSequence(retrieveGeneticSequenceRequestBody: RetrieveGeneticSequenceRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GeneticSequence>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveGeneticSequence(retrieveGeneticSequenceRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Retrieve  Organization Contact
         * @param {RetrieveOrganizationContactRequestBody} retrieveOrganizationContactRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveOrganizationContact(retrieveOrganizationContactRequestBody: RetrieveOrganizationContactRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Contact>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveOrganizationContact(retrieveOrganizationContactRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Retrieve  Phylogenetic Tree
         * @param {RetrievePhylogeneticTreeRequestBody} retrievePhylogeneticTreeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrievePhylogeneticTree(retrievePhylogeneticTreeRequestBody: RetrievePhylogeneticTreeRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PhylogeneticTree>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrievePhylogeneticTree(retrievePhylogeneticTreeRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Tree Algorithm Classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmClassesDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmClassesDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Tree Algorithm Classes
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmClassesDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmClassesDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Tree Algorithm Classes
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmClassesDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmClassesDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Tree Algorithm Classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmClassesGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeAlgorithmClass>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmClassesGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Tree Algorithm Classes
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmClassesGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TreeAlgorithmClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmClassesGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Tree Algorithm Classes
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmClassesGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeAlgorithmClass>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmClassesGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Tree Algorithm Classes
         * @param {TreeAlgorithmClass} treeAlgorithmClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmClassesPostOne(treeAlgorithmClass: TreeAlgorithmClass, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TreeAlgorithmClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmClassesPostOne(treeAlgorithmClass, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Tree Algorithm Classes
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmClassesPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeAlgorithmClass>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmClassesPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Tree Algorithm Classes
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmClassesPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmClassesPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Tree Algorithm Classes
         * @param {Array<TreeAlgorithmClass>} treeAlgorithmClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmClassesPostSome(treeAlgorithmClass: Array<TreeAlgorithmClass>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeAlgorithmClass>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmClassesPostSome(treeAlgorithmClass, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Tree Algorithm Classes
         * @param {string} objectId 
         * @param {TreeAlgorithmClass} treeAlgorithmClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmClassesPutOne(objectId: string, treeAlgorithmClass: TreeAlgorithmClass, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TreeAlgorithmClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmClassesPutOne(objectId, treeAlgorithmClass, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Tree Algorithm Classes
         * @param {Array<TreeAlgorithmClass>} treeAlgorithmClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmClassesPutSome(treeAlgorithmClass: Array<TreeAlgorithmClass>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeAlgorithmClass>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmClassesPutSome(treeAlgorithmClass, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
         * @summary Tree Algorithms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmsDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmsDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
         * @summary Tree Algorithms
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmsDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmsDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
         * @summary Tree Algorithms
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmsDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmsDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
         * @summary Tree Algorithms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmsGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeAlgorithm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmsGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
         * @summary Tree Algorithms
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmsGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TreeAlgorithm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmsGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
         * @summary Tree Algorithms
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmsGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeAlgorithm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmsGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
         * @summary Tree Algorithms
         * @param {TreeAlgorithm} treeAlgorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmsPostOne(treeAlgorithm: TreeAlgorithm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TreeAlgorithm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmsPostOne(treeAlgorithm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
         * @summary Tree Algorithms
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmsPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeAlgorithm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmsPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
         * @summary Tree Algorithms
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmsPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmsPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
         * @summary Tree Algorithms
         * @param {Array<TreeAlgorithm>} treeAlgorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmsPostSome(treeAlgorithm: Array<TreeAlgorithm>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeAlgorithm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmsPostSome(treeAlgorithm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
         * @summary Tree Algorithms
         * @param {string} objectId 
         * @param {TreeAlgorithm} treeAlgorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmsPutOne(objectId: string, treeAlgorithm: TreeAlgorithm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TreeAlgorithm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmsPutOne(objectId, treeAlgorithm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
         * @summary Tree Algorithms
         * @param {Array<TreeAlgorithm>} treeAlgorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmsPutSome(treeAlgorithm: Array<TreeAlgorithm>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeAlgorithm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmsPutSome(treeAlgorithm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
    }
};

/**
 * CaseApi - factory interface
 * @export
 */

/**
 * CaseApi - object-oriented interface

 * @export
 * @class CaseApi
 * @extends {BaseAPI}
 */
export class CaseApi extends BaseAPI {
  public static instance: CaseApi;
  public static getInstance(): CaseApi {
    this.instance = this.instance || new CaseApi();
    return this.instance;
  }

    /**
     * 
     * @summary Case Data Collection Links
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseDataCollectionLinksDeleteAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseDataCollectionLinksDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Data Collection Links
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseDataCollectionLinksDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseDataCollectionLinksDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Data Collection Links
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseDataCollectionLinksDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseDataCollectionLinksDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Data Collection Links
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseDataCollectionLinksGetAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseDataCollectionLinksGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Data Collection Links
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseDataCollectionLinksGetOne(objectId: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseDataCollectionLinksGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Data Collection Links
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseDataCollectionLinksGetSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseDataCollectionLinksGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Data Collection Links
     * @param {CaseDataCollectionLink} caseDataCollectionLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseDataCollectionLinksPostOne(caseDataCollectionLink: CaseDataCollectionLink, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseDataCollectionLinksPostOne(caseDataCollectionLink, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Data Collection Links
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseDataCollectionLinksPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseDataCollectionLinksPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Data Collection Links
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseDataCollectionLinksPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseDataCollectionLinksPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Data Collection Links
     * @param {Array<CaseDataCollectionLink>} caseDataCollectionLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseDataCollectionLinksPostSome(caseDataCollectionLink: Array<CaseDataCollectionLink>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseDataCollectionLinksPostSome(caseDataCollectionLink, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Data Collection Links
     * @param {string} objectId 
     * @param {CaseDataCollectionLink} caseDataCollectionLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseDataCollectionLinksPutOne(objectId: string, caseDataCollectionLink: CaseDataCollectionLink, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseDataCollectionLinksPutOne(objectId, caseDataCollectionLink, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Data Collection Links
     * @param {Array<CaseDataCollectionLink>} caseDataCollectionLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseDataCollectionLinksPutSome(caseDataCollectionLink: Array<CaseDataCollectionLink>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseDataCollectionLinksPutSome(caseDataCollectionLink, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetCategoriesDeleteAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetCategoriesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Categories
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetCategoriesDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetCategoriesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Categories
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetCategoriesDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetCategoriesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetCategoriesGetAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetCategoriesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Categories
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetCategoriesGetOne(objectId: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetCategoriesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Categories
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetCategoriesGetSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetCategoriesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Categories
     * @param {CaseSetCategory} caseSetCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetCategoriesPostOne(caseSetCategory: CaseSetCategory, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetCategoriesPostOne(caseSetCategory, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Categories
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetCategoriesPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetCategoriesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Categories
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetCategoriesPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetCategoriesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Categories
     * @param {Array<CaseSetCategory>} caseSetCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetCategoriesPostSome(caseSetCategory: Array<CaseSetCategory>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetCategoriesPostSome(caseSetCategory, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Categories
     * @param {string} objectId 
     * @param {CaseSetCategory} caseSetCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetCategoriesPutOne(objectId: string, caseSetCategory: CaseSetCategory, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetCategoriesPutOne(objectId, caseSetCategory, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Categories
     * @param {Array<CaseSetCategory>} caseSetCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetCategoriesPutSome(caseSetCategory: Array<CaseSetCategory>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetCategoriesPutSome(caseSetCategory, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Data Collection Links
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetDataCollectionLinksDeleteAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetDataCollectionLinksDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Data Collection Links
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetDataCollectionLinksDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetDataCollectionLinksDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Data Collection Links
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetDataCollectionLinksDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetDataCollectionLinksDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Data Collection Links
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetDataCollectionLinksGetAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetDataCollectionLinksGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Data Collection Links
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetDataCollectionLinksGetOne(objectId: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetDataCollectionLinksGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Data Collection Links
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetDataCollectionLinksGetSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetDataCollectionLinksGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Data Collection Links
     * @param {CaseSetDataCollectionLink} caseSetDataCollectionLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetDataCollectionLinksPostOne(caseSetDataCollectionLink: CaseSetDataCollectionLink, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetDataCollectionLinksPostOne(caseSetDataCollectionLink, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Data Collection Links
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetDataCollectionLinksPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetDataCollectionLinksPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Data Collection Links
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetDataCollectionLinksPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetDataCollectionLinksPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Data Collection Links
     * @param {Array<CaseSetDataCollectionLink>} caseSetDataCollectionLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetDataCollectionLinksPostSome(caseSetDataCollectionLink: Array<CaseSetDataCollectionLink>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetDataCollectionLinksPostSome(caseSetDataCollectionLink, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Data Collection Links
     * @param {string} objectId 
     * @param {CaseSetDataCollectionLink} caseSetDataCollectionLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetDataCollectionLinksPutOne(objectId: string, caseSetDataCollectionLink: CaseSetDataCollectionLink, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetDataCollectionLinksPutOne(objectId, caseSetDataCollectionLink, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Data Collection Links
     * @param {Array<CaseSetDataCollectionLink>} caseSetDataCollectionLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetDataCollectionLinksPutSome(caseSetDataCollectionLink: Array<CaseSetDataCollectionLink>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetDataCollectionLinksPutSome(caseSetDataCollectionLink, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetMembersDeleteAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetMembersDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Members
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetMembersDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetMembersDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Members
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetMembersDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetMembersDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetMembersGetAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetMembersGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Members
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetMembersGetOne(objectId: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetMembersGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Members
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetMembersGetSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetMembersGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Members
     * @param {CaseSetMember} caseSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetMembersPostOne(caseSetMember: CaseSetMember, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetMembersPostOne(caseSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Members
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetMembersPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetMembersPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Members
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetMembersPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetMembersPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Members
     * @param {Array<CaseSetMember>} caseSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetMembersPostSome(caseSetMember: Array<CaseSetMember>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetMembersPostSome(caseSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Members
     * @param {string} objectId 
     * @param {CaseSetMember} caseSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetMembersPutOne(objectId: string, caseSetMember: CaseSetMember, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetMembersPutOne(objectId, caseSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Members
     * @param {Array<CaseSetMember>} caseSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetMembersPutSome(caseSetMember: Array<CaseSetMember>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetMembersPutSome(caseSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetStatusesDeleteAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetStatusesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Statuses
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetStatusesDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetStatusesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Statuses
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetStatusesDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetStatusesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetStatusesGetAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetStatusesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Statuses
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetStatusesGetOne(objectId: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetStatusesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Statuses
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetStatusesGetSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetStatusesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Statuses
     * @param {CaseSetStatus} caseSetStatus 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetStatusesPostOne(caseSetStatus: CaseSetStatus, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetStatusesPostOne(caseSetStatus, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Statuses
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetStatusesPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetStatusesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Statuses
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetStatusesPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetStatusesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Statuses
     * @param {Array<CaseSetStatus>} caseSetStatus 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetStatusesPostSome(caseSetStatus: Array<CaseSetStatus>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetStatusesPostSome(caseSetStatus, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Statuses
     * @param {string} objectId 
     * @param {CaseSetStatus} caseSetStatus 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetStatusesPutOne(objectId: string, caseSetStatus: CaseSetStatus, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetStatusesPutOne(objectId, caseSetStatus, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Statuses
     * @param {Array<CaseSetStatus>} caseSetStatus 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetStatusesPutSome(caseSetStatus: Array<CaseSetStatus>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetStatusesPutSome(caseSetStatus, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Sets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetsDeleteAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Sets
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetsDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Sets
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetsDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Sets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetsGetAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Sets
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetsGetOne(objectId: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Sets
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetsGetSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Sets
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetsPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Sets
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetsPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Sets
     * @param {string} objectId 
     * @param {CaseSet} caseSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetsPutOne(objectId: string, caseSet: CaseSet, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetsPutOne(objectId, caseSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Sets
     * @param {Array<CaseSet>} caseSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetsPutSome(caseSet: Array<CaseSet>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetsPutSome(caseSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Set Members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetMembersDeleteAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetMembersDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Set Members
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetMembersDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetMembersDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Set Members
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetMembersDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetMembersDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Set Members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetMembersGetAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetMembersGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Set Members
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetMembersGetOne(objectId: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetMembersGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Set Members
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetMembersGetSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetMembersGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Set Members
     * @param {CaseTypeColSetMember} caseTypeColSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetMembersPostOne(caseTypeColSetMember: CaseTypeColSetMember, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetMembersPostOne(caseTypeColSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Set Members
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetMembersPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetMembersPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Set Members
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetMembersPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetMembersPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Set Members
     * @param {Array<CaseTypeColSetMember>} caseTypeColSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetMembersPostSome(caseTypeColSetMember: Array<CaseTypeColSetMember>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetMembersPostSome(caseTypeColSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Set Members
     * @param {string} objectId 
     * @param {CaseTypeColSetMember} caseTypeColSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetMembersPutOne(objectId: string, caseTypeColSetMember: CaseTypeColSetMember, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetMembersPutOne(objectId, caseTypeColSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Set Members
     * @param {Array<CaseTypeColSetMember>} caseTypeColSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetMembersPutSome(caseTypeColSetMember: Array<CaseTypeColSetMember>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetMembersPutSome(caseTypeColSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Sets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetsDeleteAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Sets
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetsDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Sets
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetsDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Sets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetsGetAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Sets
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetsGetOne(objectId: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Sets
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetsGetSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Sets
     * @param {CaseTypeColSet} caseTypeColSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetsPostOne(caseTypeColSet: CaseTypeColSet, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetsPostOne(caseTypeColSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Sets
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetsPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Sets
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetsPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Sets
     * @param {Array<CaseTypeColSet>} caseTypeColSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetsPostSome(caseTypeColSet: Array<CaseTypeColSet>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetsPostSome(caseTypeColSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Casetypecolset Casetypecol
     * @param {string} caseTypeColSetId 
     * @param {UpdateCaseTypeColSetCaseTypeColsRequestBody} updateCaseTypeColSetCaseTypeColsRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetsPutCaseTypeCols(caseTypeColSetId: string, updateCaseTypeColSetCaseTypeColsRequestBody: UpdateCaseTypeColSetCaseTypeColsRequestBody, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetsPutCaseTypeCols(caseTypeColSetId, updateCaseTypeColSetCaseTypeColsRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Sets
     * @param {string} objectId 
     * @param {CaseTypeColSet} caseTypeColSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetsPutOne(objectId: string, caseTypeColSet: CaseTypeColSet, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetsPutOne(objectId, caseTypeColSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Sets
     * @param {Array<CaseTypeColSet>} caseTypeColSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetsPutSome(caseTypeColSet: Array<CaseTypeColSet>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetsPutSome(caseTypeColSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Cols
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColsDeleteAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Cols
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColsDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Cols
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColsDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Cols
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColsGetAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Cols
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColsGetOne(objectId: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Cols
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColsGetSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Cols
     * @param {CaseTypeCol} caseTypeCol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColsPostOne(caseTypeCol: CaseTypeCol, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColsPostOne(caseTypeCol, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Cols
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColsPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Cols
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColsPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Cols
     * @param {Array<CaseTypeCol>} caseTypeCol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColsPostSome(caseTypeCol: Array<CaseTypeCol>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColsPostSome(caseTypeCol, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Cols
     * @param {string} objectId 
     * @param {CaseTypeCol} caseTypeCol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColsPutOne(objectId: string, caseTypeCol: CaseTypeCol, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColsPutOne(objectId, caseTypeCol, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Cols
     * @param {Array<CaseTypeCol>} caseTypeCol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColsPutSome(caseTypeCol: Array<CaseTypeCol>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColsPutSome(caseTypeCol, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetCategoriesDeleteAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetCategoriesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Categories
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetCategoriesDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetCategoriesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Categories
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetCategoriesDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetCategoriesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetCategoriesGetAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetCategoriesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Categories
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetCategoriesGetOne(objectId: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetCategoriesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Categories
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetCategoriesGetSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetCategoriesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Categories
     * @param {CaseTypeSetCategory} caseTypeSetCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetCategoriesPostOne(caseTypeSetCategory: CaseTypeSetCategory, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetCategoriesPostOne(caseTypeSetCategory, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Categories
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetCategoriesPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetCategoriesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Categories
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetCategoriesPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetCategoriesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Categories
     * @param {Array<CaseTypeSetCategory>} caseTypeSetCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetCategoriesPostSome(caseTypeSetCategory: Array<CaseTypeSetCategory>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetCategoriesPostSome(caseTypeSetCategory, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Categories
     * @param {string} objectId 
     * @param {CaseTypeSetCategory} caseTypeSetCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetCategoriesPutOne(objectId: string, caseTypeSetCategory: CaseTypeSetCategory, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetCategoriesPutOne(objectId, caseTypeSetCategory, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Categories
     * @param {Array<CaseTypeSetCategory>} caseTypeSetCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetCategoriesPutSome(caseTypeSetCategory: Array<CaseTypeSetCategory>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetCategoriesPutSome(caseTypeSetCategory, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetMembersDeleteAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetMembersDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Members
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetMembersDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetMembersDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Members
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetMembersDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetMembersDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetMembersGetAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetMembersGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Members
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetMembersGetOne(objectId: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetMembersGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Members
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetMembersGetSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetMembersGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Members
     * @param {CaseTypeSetMember} caseTypeSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetMembersPostOne(caseTypeSetMember: CaseTypeSetMember, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetMembersPostOne(caseTypeSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Members
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetMembersPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetMembersPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Members
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetMembersPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetMembersPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Members
     * @param {Array<CaseTypeSetMember>} caseTypeSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetMembersPostSome(caseTypeSetMember: Array<CaseTypeSetMember>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetMembersPostSome(caseTypeSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Members
     * @param {string} objectId 
     * @param {CaseTypeSetMember} caseTypeSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetMembersPutOne(objectId: string, caseTypeSetMember: CaseTypeSetMember, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetMembersPutOne(objectId, caseTypeSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Members
     * @param {Array<CaseTypeSetMember>} caseTypeSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetMembersPutSome(caseTypeSetMember: Array<CaseTypeSetMember>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetMembersPutSome(caseTypeSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Sets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetsDeleteAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Sets
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetsDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Sets
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetsDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Sets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetsGetAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Sets
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetsGetOne(objectId: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Sets
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetsGetSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Sets
     * @param {CaseTypeSet} caseTypeSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetsPostOne(caseTypeSet: CaseTypeSet, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetsPostOne(caseTypeSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Sets
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetsPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Sets
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetsPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Sets
     * @param {Array<CaseTypeSet>} caseTypeSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetsPostSome(caseTypeSet: Array<CaseTypeSet>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetsPostSome(caseTypeSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Casetypeset Casetype
     * @param {string} caseTypeSetId 
     * @param {UpdateCaseTypeSetCaseTypesRequestBody} updateCaseTypeSetCaseTypesRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetsPutCaseTypes(caseTypeSetId: string, updateCaseTypeSetCaseTypesRequestBody: UpdateCaseTypeSetCaseTypesRequestBody, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetsPutCaseTypes(caseTypeSetId, updateCaseTypeSetCaseTypesRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Sets
     * @param {string} objectId 
     * @param {CaseTypeSet} caseTypeSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetsPutOne(objectId: string, caseTypeSet: CaseTypeSet, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetsPutOne(objectId, caseTypeSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Sets
     * @param {Array<CaseTypeSet>} caseTypeSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetsPutSome(caseTypeSet: Array<CaseTypeSet>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetsPutSome(caseTypeSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypesDeleteAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Types
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypesDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Types
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypesDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypesGetAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Types
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypesGetOne(objectId: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Types
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypesGetSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Types
     * @param {CaseType} caseType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypesPostOne(caseType: CaseType, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypesPostOne(caseType, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Types
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypesPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Types
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypesPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Types
     * @param {Array<CaseType>} caseType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypesPostSome(caseType: Array<CaseType>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypesPostSome(caseType, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Types
     * @param {string} objectId 
     * @param {CaseType} caseType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypesPutOne(objectId: string, caseType: CaseType, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypesPutOne(objectId, caseType, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Types
     * @param {Array<CaseType>} caseType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypesPutSome(caseType: Array<CaseType>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypesPutSome(caseType, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A class representing a case.
     * @summary Cases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public casesDeleteAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).casesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A class representing a case.
     * @summary Cases
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public casesDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).casesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A class representing a case.
     * @summary Cases
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public casesDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).casesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A class representing a case.
     * @summary Cases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public casesGetAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).casesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A class representing a case.
     * @summary Cases
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public casesGetOne(objectId: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).casesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A class representing a case.
     * @summary Cases
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public casesGetSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).casesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A class representing a case.
     * @summary Cases
     * @param {Case} _case 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public casesPostOne(_case: Case, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).casesPostOne(_case, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A class representing a case.
     * @summary Cases
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public casesPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).casesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A class representing a case.
     * @summary Cases
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public casesPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).casesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A class representing a case.
     * @summary Cases
     * @param {Array<Case>} _case 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public casesPostSome(_case: Array<Case>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).casesPostSome(_case, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A class representing a case.
     * @summary Cases
     * @param {string} objectId 
     * @param {Case} _case 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public casesPutOne(objectId: string, _case: Case, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).casesPutOne(objectId, _case, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A class representing a case.
     * @summary Cases
     * @param {Array<Case>} _case 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public casesPutSome(_case: Array<Case>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).casesPutSome(_case, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cols
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public colsDeleteAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).colsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cols
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public colsDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).colsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cols
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public colsDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).colsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cols
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public colsGetAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).colsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cols
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public colsGetOne(objectId: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).colsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cols
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public colsGetSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).colsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cols
     * @param {Col} col 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public colsPostOne(col: Col, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).colsPostOne(col, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cols
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public colsPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).colsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cols
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public colsPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).colsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cols
     * @param {Array<Col>} col 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public colsPostSome(col: Array<Col>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).colsPostSome(col, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cols
     * @param {string} objectId 
     * @param {Col} col 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public colsPutOne(objectId: string, col: Col, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).colsPutOne(objectId, col, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cols
     * @param {Array<Col>} col 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public colsPutSome(col: Array<Col>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).colsPutSome(col, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Completecasetype
     * @param {string} caseTypeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public completeCaseTypesGetOne(caseTypeId: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).completeCaseTypesGetOne(caseTypeId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Caseset
     * @param {CreateCaseSetRequestBody} createCaseSetRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public createCaseSet(createCaseSetRequestBody: CreateCaseSetRequestBody, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).createCaseSet(createCaseSetRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cases
     * @param {CreateCasesRequestBody} createCasesRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public createCases(createCasesRequestBody: CreateCasesRequestBody, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).createCases(createCasesRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Dims
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public dimsDeleteAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).dimsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Dims
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public dimsDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).dimsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Dims
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public dimsDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).dimsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Dims
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public dimsGetAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).dimsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Dims
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public dimsGetOne(objectId: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).dimsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Dims
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public dimsGetSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).dimsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Dims
     * @param {Dim} dim 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public dimsPostOne(dim: Dim, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).dimsPostOne(dim, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Dims
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public dimsPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).dimsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Dims
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public dimsPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).dimsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Dims
     * @param {Array<Dim>} dim 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public dimsPostSome(dim: Array<Dim>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).dimsPostSome(dim, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Dims
     * @param {string} objectId 
     * @param {Dim} dim 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public dimsPutOne(objectId: string, dim: Dim, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).dimsPutOne(objectId, dim, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Dims
     * @param {Array<Dim>} dim 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public dimsPutSome(dim: Array<Dim>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).dimsPutSome(dim, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Genetic Distance Protocols
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public geneticDistanceProtocolsDeleteAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).geneticDistanceProtocolsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Genetic Distance Protocols
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public geneticDistanceProtocolsDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).geneticDistanceProtocolsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Genetic Distance Protocols
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public geneticDistanceProtocolsDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).geneticDistanceProtocolsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Genetic Distance Protocols
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public geneticDistanceProtocolsGetAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).geneticDistanceProtocolsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Genetic Distance Protocols
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public geneticDistanceProtocolsGetOne(objectId: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).geneticDistanceProtocolsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Genetic Distance Protocols
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public geneticDistanceProtocolsGetSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).geneticDistanceProtocolsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Genetic Distance Protocols
     * @param {GeneticDistanceProtocol} geneticDistanceProtocol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public geneticDistanceProtocolsPostOne(geneticDistanceProtocol: GeneticDistanceProtocol, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).geneticDistanceProtocolsPostOne(geneticDistanceProtocol, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Genetic Distance Protocols
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public geneticDistanceProtocolsPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).geneticDistanceProtocolsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Genetic Distance Protocols
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public geneticDistanceProtocolsPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).geneticDistanceProtocolsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Genetic Distance Protocols
     * @param {Array<GeneticDistanceProtocol>} geneticDistanceProtocol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public geneticDistanceProtocolsPostSome(geneticDistanceProtocol: Array<GeneticDistanceProtocol>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).geneticDistanceProtocolsPostSome(geneticDistanceProtocol, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Genetic Distance Protocols
     * @param {string} objectId 
     * @param {GeneticDistanceProtocol} geneticDistanceProtocol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public geneticDistanceProtocolsPutOne(objectId: string, geneticDistanceProtocol: GeneticDistanceProtocol, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).geneticDistanceProtocolsPutOne(objectId, geneticDistanceProtocol, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Genetic Distance Protocols
     * @param {Array<GeneticDistanceProtocol>} geneticDistanceProtocol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public geneticDistanceProtocolsPutSome(geneticDistanceProtocol: Array<GeneticDistanceProtocol>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).geneticDistanceProtocolsPutSome(geneticDistanceProtocol, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Retrieve  Case Ids By Query
     * @param {CaseQuery} caseQuery 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public retrieveCaseIdsByQuery(caseQuery: CaseQuery, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).retrieveCaseIdsByQuery(caseQuery, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Retrieve  Case Rights
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public retrieveCaseRights(requestBody: Array<string>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).retrieveCaseRights(requestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Retrieve  Case Set Rights
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public retrieveCaseSetRights(requestBody: Array<string>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).retrieveCaseSetRights(requestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Casesetstats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public retrieveCaseSetStats(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).retrieveCaseSetStats(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Casetypestats
     * @param {RetrieveCaseTypeStatsCommand} retrieveCaseTypeStatsCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public retrieveCaseTypeStats(retrieveCaseTypeStatsCommand: RetrieveCaseTypeStatsCommand, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).retrieveCaseTypeStats(retrieveCaseTypeStatsCommand, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Retrieve  Cases By Ids
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public retrieveCasesByIds(requestBody: Array<string>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).retrieveCasesByIds(requestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Retrieve  Genetic Sequence
     * @param {RetrieveGeneticSequenceRequestBody} retrieveGeneticSequenceRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public retrieveGeneticSequence(retrieveGeneticSequenceRequestBody: RetrieveGeneticSequenceRequestBody, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).retrieveGeneticSequence(retrieveGeneticSequenceRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Retrieve  Organization Contact
     * @param {RetrieveOrganizationContactRequestBody} retrieveOrganizationContactRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public retrieveOrganizationContact(retrieveOrganizationContactRequestBody: RetrieveOrganizationContactRequestBody, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).retrieveOrganizationContact(retrieveOrganizationContactRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Retrieve  Phylogenetic Tree
     * @param {RetrievePhylogeneticTreeRequestBody} retrievePhylogeneticTreeRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public retrievePhylogeneticTree(retrievePhylogeneticTreeRequestBody: RetrievePhylogeneticTreeRequestBody, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).retrievePhylogeneticTree(retrievePhylogeneticTreeRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithm Classes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmClassesDeleteAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmClassesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithm Classes
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmClassesDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmClassesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithm Classes
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmClassesDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmClassesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithm Classes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmClassesGetAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmClassesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithm Classes
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmClassesGetOne(objectId: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmClassesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithm Classes
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmClassesGetSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmClassesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithm Classes
     * @param {TreeAlgorithmClass} treeAlgorithmClass 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmClassesPostOne(treeAlgorithmClass: TreeAlgorithmClass, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmClassesPostOne(treeAlgorithmClass, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithm Classes
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmClassesPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmClassesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithm Classes
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmClassesPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmClassesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithm Classes
     * @param {Array<TreeAlgorithmClass>} treeAlgorithmClass 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmClassesPostSome(treeAlgorithmClass: Array<TreeAlgorithmClass>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmClassesPostSome(treeAlgorithmClass, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithm Classes
     * @param {string} objectId 
     * @param {TreeAlgorithmClass} treeAlgorithmClass 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmClassesPutOne(objectId: string, treeAlgorithmClass: TreeAlgorithmClass, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmClassesPutOne(objectId, treeAlgorithmClass, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithm Classes
     * @param {Array<TreeAlgorithmClass>} treeAlgorithmClass 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmClassesPutSome(treeAlgorithmClass: Array<TreeAlgorithmClass>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmClassesPutSome(treeAlgorithmClass, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
     * @summary Tree Algorithms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmsDeleteAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
     * @summary Tree Algorithms
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmsDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
     * @summary Tree Algorithms
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmsDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
     * @summary Tree Algorithms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmsGetAll(options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
     * @summary Tree Algorithms
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmsGetOne(objectId: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
     * @summary Tree Algorithms
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmsGetSome(ids: string, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
     * @summary Tree Algorithms
     * @param {TreeAlgorithm} treeAlgorithm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmsPostOne(treeAlgorithm: TreeAlgorithm, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmsPostOne(treeAlgorithm, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
     * @summary Tree Algorithms
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmsPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
     * @summary Tree Algorithms
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmsPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
     * @summary Tree Algorithms
     * @param {Array<TreeAlgorithm>} treeAlgorithm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmsPostSome(treeAlgorithm: Array<TreeAlgorithm>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmsPostSome(treeAlgorithm, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
     * @summary Tree Algorithms
     * @param {string} objectId 
     * @param {TreeAlgorithm} treeAlgorithm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmsPutOne(objectId: string, treeAlgorithm: TreeAlgorithm, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmsPutOne(objectId, treeAlgorithm, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * See https://en.wikipedia.org/wiki/Hierarchical_clustering,     https://en.wikipedia.org/wiki/Neighbor_joining,      https://en.wikipedia.org/wiki/Computational_phylogenetics,      https://en.wikipedia.org/wiki/Spanning_tree
     * @summary Tree Algorithms
     * @param {Array<TreeAlgorithm>} treeAlgorithm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmsPutSome(treeAlgorithm: Array<TreeAlgorithm>, options?: AxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmsPutSome(treeAlgorithm, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Redirect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Redirect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redirectGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redirectGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */

/**
 * DefaultApi - object-oriented interface

 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  public static instance: DefaultApi;
  public static getInstance(): DefaultApi {
    this.instance = this.instance || new DefaultApi();
    return this.instance;
  }

    /**
     * 
     * @summary Redirect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public redirectGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).redirectGet(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }
}



/**
 * GeoApi - axios parameter creator
 * @export
 */
const GeoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Region Relations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionRelationsDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/region_relations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Relations
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionRelationsDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('regionRelationsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/region_relations/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Relations
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionRelationsDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('regionRelationsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/region_relations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Relations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionRelationsGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/region_relations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Relations
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionRelationsGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('regionRelationsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/region_relations/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Relations
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionRelationsGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('regionRelationsGetSome', 'ids', ids)
            const localVarPath = `/v1/region_relations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Relations
         * @param {RegionRelation} regionRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionRelationsPostOne: async (regionRelation: RegionRelation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionRelation' is not null or undefined
            assertParamExists('regionRelationsPostOne', 'regionRelation', regionRelation)
            const localVarPath = `/v1/region_relations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regionRelation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Relations
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionRelationsPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('regionRelationsPostQuery', 'filter', filter)
            const localVarPath = `/v1/region_relations/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Relations
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionRelationsPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('regionRelationsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/region_relations/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Relations
         * @param {Array<RegionRelation>} regionRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionRelationsPostSome: async (regionRelation: Array<RegionRelation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionRelation' is not null or undefined
            assertParamExists('regionRelationsPostSome', 'regionRelation', regionRelation)
            const localVarPath = `/v1/region_relations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regionRelation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Relations
         * @param {string} objectId 
         * @param {RegionRelation} regionRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionRelationsPutOne: async (objectId: string, regionRelation: RegionRelation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('regionRelationsPutOne', 'objectId', objectId)
            // verify required parameter 'regionRelation' is not null or undefined
            assertParamExists('regionRelationsPutOne', 'regionRelation', regionRelation)
            const localVarPath = `/v1/region_relations/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regionRelation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Relations
         * @param {Array<RegionRelation>} regionRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionRelationsPutSome: async (regionRelation: Array<RegionRelation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionRelation' is not null or undefined
            assertParamExists('regionRelationsPutSome', 'regionRelation', regionRelation)
            const localVarPath = `/v1/region_relations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regionRelation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Set Shapes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetShapesDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/region_set_shapes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Set Shapes
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetShapesDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('regionSetShapesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/region_set_shapes/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Set Shapes
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetShapesDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('regionSetShapesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/region_set_shapes/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Set Shapes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetShapesGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/region_set_shapes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Set Shapes
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetShapesGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('regionSetShapesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/region_set_shapes/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Set Shapes
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetShapesGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('regionSetShapesGetSome', 'ids', ids)
            const localVarPath = `/v1/region_set_shapes/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Set Shapes
         * @param {RegionSetShape} regionSetShape 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetShapesPostOne: async (regionSetShape: RegionSetShape, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionSetShape' is not null or undefined
            assertParamExists('regionSetShapesPostOne', 'regionSetShape', regionSetShape)
            const localVarPath = `/v1/region_set_shapes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regionSetShape, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Set Shapes
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetShapesPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('regionSetShapesPostQuery', 'filter', filter)
            const localVarPath = `/v1/region_set_shapes/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Set Shapes
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetShapesPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('regionSetShapesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/region_set_shapes/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Set Shapes
         * @param {Array<RegionSetShape>} regionSetShape 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetShapesPostSome: async (regionSetShape: Array<RegionSetShape>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionSetShape' is not null or undefined
            assertParamExists('regionSetShapesPostSome', 'regionSetShape', regionSetShape)
            const localVarPath = `/v1/region_set_shapes/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regionSetShape, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Set Shapes
         * @param {string} objectId 
         * @param {RegionSetShape} regionSetShape 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetShapesPutOne: async (objectId: string, regionSetShape: RegionSetShape, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('regionSetShapesPutOne', 'objectId', objectId)
            // verify required parameter 'regionSetShape' is not null or undefined
            assertParamExists('regionSetShapesPutOne', 'regionSetShape', regionSetShape)
            const localVarPath = `/v1/region_set_shapes/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regionSetShape, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Set Shapes
         * @param {Array<RegionSetShape>} regionSetShape 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetShapesPutSome: async (regionSetShape: Array<RegionSetShape>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionSetShape' is not null or undefined
            assertParamExists('regionSetShapesPutSome', 'regionSetShape', regionSetShape)
            const localVarPath = `/v1/region_set_shapes/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regionSetShape, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
         * @summary Region Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetsDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/region_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
         * @summary Region Sets
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetsDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('regionSetsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/region_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
         * @summary Region Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetsDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('regionSetsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/region_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
         * @summary Region Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetsGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/region_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
         * @summary Region Sets
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetsGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('regionSetsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/region_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
         * @summary Region Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetsGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('regionSetsGetSome', 'ids', ids)
            const localVarPath = `/v1/region_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
         * @summary Region Sets
         * @param {RegionSet} regionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetsPostOne: async (regionSet: RegionSet, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionSet' is not null or undefined
            assertParamExists('regionSetsPostOne', 'regionSet', regionSet)
            const localVarPath = `/v1/region_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regionSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
         * @summary Region Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetsPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('regionSetsPostQuery', 'filter', filter)
            const localVarPath = `/v1/region_sets/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
         * @summary Region Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetsPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('regionSetsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/region_sets/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
         * @summary Region Sets
         * @param {Array<RegionSet>} regionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetsPostSome: async (regionSet: Array<RegionSet>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionSet' is not null or undefined
            assertParamExists('regionSetsPostSome', 'regionSet', regionSet)
            const localVarPath = `/v1/region_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regionSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
         * @summary Region Sets
         * @param {string} objectId 
         * @param {RegionSet} regionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetsPutOne: async (objectId: string, regionSet: RegionSet, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('regionSetsPutOne', 'objectId', objectId)
            // verify required parameter 'regionSet' is not null or undefined
            assertParamExists('regionSetsPutOne', 'regionSet', regionSet)
            const localVarPath = `/v1/region_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regionSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
         * @summary Region Sets
         * @param {Array<RegionSet>} regionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetsPutSome: async (regionSet: Array<RegionSet>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionSet' is not null or undefined
            assertParamExists('regionSetsPutSome', 'regionSet', regionSet)
            const localVarPath = `/v1/region_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regionSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/regions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regions
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('regionsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/regions/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regions
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('regionsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/regions/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/regions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regions
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('regionsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/regions/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regions
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('regionsGetSome', 'ids', ids)
            const localVarPath = `/v1/regions/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regions
         * @param {Region} region 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsPostOne: async (region: Region, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('regionsPostOne', 'region', region)
            const localVarPath = `/v1/regions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(region, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regions
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('regionsPostQuery', 'filter', filter)
            const localVarPath = `/v1/regions/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regions
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('regionsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/regions/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regions
         * @param {Array<Region>} region 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsPostSome: async (region: Array<Region>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('regionsPostSome', 'region', region)
            const localVarPath = `/v1/regions/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(region, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regions
         * @param {string} objectId 
         * @param {Region} region 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsPutOne: async (objectId: string, region: Region, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('regionsPutOne', 'objectId', objectId)
            // verify required parameter 'region' is not null or undefined
            assertParamExists('regionsPutOne', 'region', region)
            const localVarPath = `/v1/regions/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(region, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regions
         * @param {Array<Region>} region 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsPutSome: async (region: Array<Region>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('regionsPutSome', 'region', region)
            const localVarPath = `/v1/regions/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(region, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GeoApi - functional programming interface
 * @export
 */
const GeoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GeoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Region Relations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionRelationsDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionRelationsDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Region Relations
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionRelationsDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionRelationsDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Region Relations
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionRelationsDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionRelationsDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Region Relations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionRelationsGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionRelation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionRelationsGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Region Relations
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionRelationsGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegionRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionRelationsGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Region Relations
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionRelationsGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionRelation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionRelationsGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Region Relations
         * @param {RegionRelation} regionRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionRelationsPostOne(regionRelation: RegionRelation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegionRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionRelationsPostOne(regionRelation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Region Relations
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionRelationsPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionRelation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionRelationsPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Region Relations
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionRelationsPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionRelationsPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Region Relations
         * @param {Array<RegionRelation>} regionRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionRelationsPostSome(regionRelation: Array<RegionRelation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionRelation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionRelationsPostSome(regionRelation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Region Relations
         * @param {string} objectId 
         * @param {RegionRelation} regionRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionRelationsPutOne(objectId: string, regionRelation: RegionRelation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegionRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionRelationsPutOne(objectId, regionRelation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Region Relations
         * @param {Array<RegionRelation>} regionRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionRelationsPutSome(regionRelation: Array<RegionRelation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionRelation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionRelationsPutSome(regionRelation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Region Set Shapes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetShapesDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetShapesDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Region Set Shapes
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetShapesDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetShapesDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Region Set Shapes
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetShapesDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetShapesDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Region Set Shapes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetShapesGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionSetShape>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetShapesGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Region Set Shapes
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetShapesGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegionSetShape>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetShapesGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Region Set Shapes
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetShapesGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionSetShape>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetShapesGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Region Set Shapes
         * @param {RegionSetShape} regionSetShape 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetShapesPostOne(regionSetShape: RegionSetShape, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegionSetShape>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetShapesPostOne(regionSetShape, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Region Set Shapes
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetShapesPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionSetShape>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetShapesPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Region Set Shapes
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetShapesPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetShapesPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Region Set Shapes
         * @param {Array<RegionSetShape>} regionSetShape 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetShapesPostSome(regionSetShape: Array<RegionSetShape>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionSetShape>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetShapesPostSome(regionSetShape, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Region Set Shapes
         * @param {string} objectId 
         * @param {RegionSetShape} regionSetShape 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetShapesPutOne(objectId: string, regionSetShape: RegionSetShape, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegionSetShape>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetShapesPutOne(objectId, regionSetShape, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Region Set Shapes
         * @param {Array<RegionSetShape>} regionSetShape 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetShapesPutSome(regionSetShape: Array<RegionSetShape>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionSetShape>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetShapesPutSome(regionSetShape, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
         * @summary Region Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetsDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetsDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
         * @summary Region Sets
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetsDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetsDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
         * @summary Region Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetsDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetsDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
         * @summary Region Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetsGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetsGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
         * @summary Region Sets
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetsGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegionSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetsGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
         * @summary Region Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetsGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetsGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
         * @summary Region Sets
         * @param {RegionSet} regionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetsPostOne(regionSet: RegionSet, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegionSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetsPostOne(regionSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
         * @summary Region Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetsPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetsPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
         * @summary Region Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetsPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetsPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
         * @summary Region Sets
         * @param {Array<RegionSet>} regionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetsPostSome(regionSet: Array<RegionSet>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetsPostSome(regionSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
         * @summary Region Sets
         * @param {string} objectId 
         * @param {RegionSet} regionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetsPutOne(objectId: string, regionSet: RegionSet, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegionSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetsPutOne(objectId, regionSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
         * @summary Region Sets
         * @param {Array<RegionSet>} regionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetsPutSome(regionSet: Array<RegionSet>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetsPutSome(regionSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Regions
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Regions
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Region>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Regions
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Regions
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Region>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Regions
         * @param {Region} region 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsPostOne(region: Region, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsPostOne(region, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Regions
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Region>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Regions
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Regions
         * @param {Array<Region>} region 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsPostSome(region: Array<Region>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Region>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsPostSome(region, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Regions
         * @param {string} objectId 
         * @param {Region} region 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsPutOne(objectId: string, region: Region, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsPutOne(objectId, region, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Regions
         * @param {Array<Region>} region 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsPutSome(region: Array<Region>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Region>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsPutSome(region, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
    }
};

/**
 * GeoApi - factory interface
 * @export
 */

/**
 * GeoApi - object-oriented interface

 * @export
 * @class GeoApi
 * @extends {BaseAPI}
 */
export class GeoApi extends BaseAPI {
  public static instance: GeoApi;
  public static getInstance(): GeoApi {
    this.instance = this.instance || new GeoApi();
    return this.instance;
  }

    /**
     * 
     * @summary Region Relations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionRelationsDeleteAll(options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionRelationsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Relations
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionRelationsDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionRelationsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Relations
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionRelationsDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionRelationsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Relations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionRelationsGetAll(options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionRelationsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Relations
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionRelationsGetOne(objectId: string, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionRelationsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Relations
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionRelationsGetSome(ids: string, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionRelationsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Relations
     * @param {RegionRelation} regionRelation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionRelationsPostOne(regionRelation: RegionRelation, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionRelationsPostOne(regionRelation, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Relations
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionRelationsPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionRelationsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Relations
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionRelationsPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionRelationsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Relations
     * @param {Array<RegionRelation>} regionRelation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionRelationsPostSome(regionRelation: Array<RegionRelation>, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionRelationsPostSome(regionRelation, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Relations
     * @param {string} objectId 
     * @param {RegionRelation} regionRelation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionRelationsPutOne(objectId: string, regionRelation: RegionRelation, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionRelationsPutOne(objectId, regionRelation, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Relations
     * @param {Array<RegionRelation>} regionRelation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionRelationsPutSome(regionRelation: Array<RegionRelation>, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionRelationsPutSome(regionRelation, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Set Shapes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetShapesDeleteAll(options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetShapesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Set Shapes
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetShapesDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetShapesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Set Shapes
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetShapesDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetShapesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Set Shapes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetShapesGetAll(options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetShapesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Set Shapes
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetShapesGetOne(objectId: string, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetShapesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Set Shapes
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetShapesGetSome(ids: string, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetShapesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Set Shapes
     * @param {RegionSetShape} regionSetShape 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetShapesPostOne(regionSetShape: RegionSetShape, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetShapesPostOne(regionSetShape, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Set Shapes
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetShapesPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetShapesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Set Shapes
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetShapesPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetShapesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Set Shapes
     * @param {Array<RegionSetShape>} regionSetShape 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetShapesPostSome(regionSetShape: Array<RegionSetShape>, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetShapesPostSome(regionSetShape, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Set Shapes
     * @param {string} objectId 
     * @param {RegionSetShape} regionSetShape 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetShapesPutOne(objectId: string, regionSetShape: RegionSetShape, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetShapesPutOne(objectId, regionSetShape, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Set Shapes
     * @param {Array<RegionSetShape>} regionSetShape 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetShapesPutSome(regionSetShape: Array<RegionSetShape>, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetShapesPutSome(regionSetShape, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
     * @summary Region Sets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetsDeleteAll(options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
     * @summary Region Sets
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetsDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
     * @summary Region Sets
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetsDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
     * @summary Region Sets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetsGetAll(options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
     * @summary Region Sets
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetsGetOne(objectId: string, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
     * @summary Region Sets
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetsGetSome(ids: string, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
     * @summary Region Sets
     * @param {RegionSet} regionSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetsPostOne(regionSet: RegionSet, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetsPostOne(regionSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
     * @summary Region Sets
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetsPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
     * @summary Region Sets
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetsPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
     * @summary Region Sets
     * @param {Array<RegionSet>} regionSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetsPostSome(regionSet: Array<RegionSet>, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetsPostSome(regionSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
     * @summary Region Sets
     * @param {string} objectId 
     * @param {RegionSet} regionSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetsPutOne(objectId: string, regionSet: RegionSet, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetsPutOne(objectId, regionSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Set of regions that do not overlap geographically     or otherwise did not exist at the same moment in time.
     * @summary Region Sets
     * @param {Array<RegionSet>} regionSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetsPutSome(regionSet: Array<RegionSet>, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetsPutSome(regionSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Regions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionsDeleteAll(options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Regions
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionsDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Regions
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionsDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Regions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionsGetAll(options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Regions
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionsGetOne(objectId: string, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Regions
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionsGetSome(ids: string, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Regions
     * @param {Region} region 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionsPostOne(region: Region, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionsPostOne(region, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Regions
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionsPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Regions
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionsPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Regions
     * @param {Array<Region>} region 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionsPostSome(region: Array<Region>, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionsPostSome(region, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Regions
     * @param {string} objectId 
     * @param {Region} region 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionsPutOne(objectId: string, region: Region, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionsPutOne(objectId, region, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Regions
     * @param {Array<Region>} region 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionsPutSome(region: Array<Region>, options?: AxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionsPutSome(region, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }
}



/**
 * OntologyApi - axios parameter creator
 * @export
 */
const OntologyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Concept Set Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetMembersDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/concept_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Set Members
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetMembersDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('conceptSetMembersDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/concept_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Set Members
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetMembersDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('conceptSetMembersDeleteSome', 'ids', ids)
            const localVarPath = `/v1/concept_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Set Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetMembersGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/concept_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Set Members
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetMembersGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('conceptSetMembersGetOne', 'objectId', objectId)
            const localVarPath = `/v1/concept_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Set Members
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetMembersGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('conceptSetMembersGetSome', 'ids', ids)
            const localVarPath = `/v1/concept_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Set Members
         * @param {ConceptSetMember} conceptSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetMembersPostOne: async (conceptSetMember: ConceptSetMember, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conceptSetMember' is not null or undefined
            assertParamExists('conceptSetMembersPostOne', 'conceptSetMember', conceptSetMember)
            const localVarPath = `/v1/concept_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conceptSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Set Members
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetMembersPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('conceptSetMembersPostQuery', 'filter', filter)
            const localVarPath = `/v1/concept_set_members/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Set Members
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetMembersPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('conceptSetMembersPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/concept_set_members/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Set Members
         * @param {Array<ConceptSetMember>} conceptSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetMembersPostSome: async (conceptSetMember: Array<ConceptSetMember>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conceptSetMember' is not null or undefined
            assertParamExists('conceptSetMembersPostSome', 'conceptSetMember', conceptSetMember)
            const localVarPath = `/v1/concept_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conceptSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Set Members
         * @param {string} objectId 
         * @param {ConceptSetMember} conceptSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetMembersPutOne: async (objectId: string, conceptSetMember: ConceptSetMember, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('conceptSetMembersPutOne', 'objectId', objectId)
            // verify required parameter 'conceptSetMember' is not null or undefined
            assertParamExists('conceptSetMembersPutOne', 'conceptSetMember', conceptSetMember)
            const localVarPath = `/v1/concept_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conceptSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Set Members
         * @param {Array<ConceptSetMember>} conceptSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetMembersPutSome: async (conceptSetMember: Array<ConceptSetMember>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conceptSetMember' is not null or undefined
            assertParamExists('conceptSetMembersPutSome', 'conceptSetMember', conceptSetMember)
            const localVarPath = `/v1/concept_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conceptSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetsDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/concept_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Sets
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetsDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('conceptSetsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/concept_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetsDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('conceptSetsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/concept_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetsGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/concept_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Sets
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetsGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('conceptSetsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/concept_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetsGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('conceptSetsGetSome', 'ids', ids)
            const localVarPath = `/v1/concept_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Sets
         * @param {ConceptSet} conceptSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetsPostOne: async (conceptSet: ConceptSet, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conceptSet' is not null or undefined
            assertParamExists('conceptSetsPostOne', 'conceptSet', conceptSet)
            const localVarPath = `/v1/concept_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conceptSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetsPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('conceptSetsPostQuery', 'filter', filter)
            const localVarPath = `/v1/concept_sets/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetsPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('conceptSetsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/concept_sets/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Sets
         * @param {Array<ConceptSet>} conceptSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetsPostSome: async (conceptSet: Array<ConceptSet>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conceptSet' is not null or undefined
            assertParamExists('conceptSetsPostSome', 'conceptSet', conceptSet)
            const localVarPath = `/v1/concept_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conceptSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Conceptset Concept
         * @param {string} conceptSetId 
         * @param {UpdateConceptSetConceptRequestBody} updateConceptSetConceptRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetsPutConcepts: async (conceptSetId: string, updateConceptSetConceptRequestBody: UpdateConceptSetConceptRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conceptSetId' is not null or undefined
            assertParamExists('conceptSetsPutConcepts', 'conceptSetId', conceptSetId)
            // verify required parameter 'updateConceptSetConceptRequestBody' is not null or undefined
            assertParamExists('conceptSetsPutConcepts', 'updateConceptSetConceptRequestBody', updateConceptSetConceptRequestBody)
            const localVarPath = `/v1/concept_sets/{concept_set_id}/concepts`
                .replace(`{${"concept_set_id"}}`, encodeURIComponent(String(conceptSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateConceptSetConceptRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Sets
         * @param {string} objectId 
         * @param {ConceptSet} conceptSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetsPutOne: async (objectId: string, conceptSet: ConceptSet, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('conceptSetsPutOne', 'objectId', objectId)
            // verify required parameter 'conceptSet' is not null or undefined
            assertParamExists('conceptSetsPutOne', 'conceptSet', conceptSet)
            const localVarPath = `/v1/concept_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conceptSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Sets
         * @param {Array<ConceptSet>} conceptSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetsPutSome: async (conceptSet: Array<ConceptSet>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conceptSet' is not null or undefined
            assertParamExists('conceptSetsPutSome', 'conceptSet', conceptSet)
            const localVarPath = `/v1/concept_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conceptSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concepts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptsDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/concepts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concepts
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptsDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('conceptsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/concepts/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concepts
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptsDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('conceptsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/concepts/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concepts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptsGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/concepts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concepts
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptsGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('conceptsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/concepts/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concepts
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptsGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('conceptsGetSome', 'ids', ids)
            const localVarPath = `/v1/concepts/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concepts
         * @param {Concept} concept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptsPostOne: async (concept: Concept, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'concept' is not null or undefined
            assertParamExists('conceptsPostOne', 'concept', concept)
            const localVarPath = `/v1/concepts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(concept, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concepts
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptsPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('conceptsPostQuery', 'filter', filter)
            const localVarPath = `/v1/concepts/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concepts
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptsPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('conceptsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/concepts/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concepts
         * @param {Array<Concept>} concept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptsPostSome: async (concept: Array<Concept>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'concept' is not null or undefined
            assertParamExists('conceptsPostSome', 'concept', concept)
            const localVarPath = `/v1/concepts/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(concept, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concepts
         * @param {string} objectId 
         * @param {Concept} concept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptsPutOne: async (objectId: string, concept: Concept, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('conceptsPutOne', 'objectId', objectId)
            // verify required parameter 'concept' is not null or undefined
            assertParamExists('conceptsPutOne', 'concept', concept)
            const localVarPath = `/v1/concepts/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(concept, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concepts
         * @param {Array<Concept>} concept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptsPutSome: async (concept: Array<Concept>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'concept' is not null or undefined
            assertParamExists('conceptsPutSome', 'concept', concept)
            const localVarPath = `/v1/concepts/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(concept, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Diseases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diseasesDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/diseases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Diseases
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diseasesDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('diseasesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/diseases/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Diseases
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diseasesDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('diseasesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/diseases/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Diseases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diseasesGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/diseases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Diseases
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diseasesGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('diseasesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/diseases/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Diseases
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diseasesGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('diseasesGetSome', 'ids', ids)
            const localVarPath = `/v1/diseases/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Diseases
         * @param {Disease} disease 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diseasesPostOne: async (disease: Disease, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'disease' is not null or undefined
            assertParamExists('diseasesPostOne', 'disease', disease)
            const localVarPath = `/v1/diseases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disease, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Diseases
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diseasesPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('diseasesPostQuery', 'filter', filter)
            const localVarPath = `/v1/diseases/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Diseases
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diseasesPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('diseasesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/diseases/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Diseases
         * @param {Array<Disease>} disease 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diseasesPostSome: async (disease: Array<Disease>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'disease' is not null or undefined
            assertParamExists('diseasesPostSome', 'disease', disease)
            const localVarPath = `/v1/diseases/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disease, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disease Etiologicalagent
         * @param {string} diseaseId 
         * @param {UpdateDiseaseEtiologicalAgentRequestBody} updateDiseaseEtiologicalAgentRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diseasesPutEtiologicalAgents: async (diseaseId: string, updateDiseaseEtiologicalAgentRequestBody: UpdateDiseaseEtiologicalAgentRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'diseaseId' is not null or undefined
            assertParamExists('diseasesPutEtiologicalAgents', 'diseaseId', diseaseId)
            // verify required parameter 'updateDiseaseEtiologicalAgentRequestBody' is not null or undefined
            assertParamExists('diseasesPutEtiologicalAgents', 'updateDiseaseEtiologicalAgentRequestBody', updateDiseaseEtiologicalAgentRequestBody)
            const localVarPath = `/v1/diseases/{disease_id}/etiological_agents`
                .replace(`{${"disease_id"}}`, encodeURIComponent(String(diseaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDiseaseEtiologicalAgentRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Diseases
         * @param {string} objectId 
         * @param {Disease} disease 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diseasesPutOne: async (objectId: string, disease: Disease, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('diseasesPutOne', 'objectId', objectId)
            // verify required parameter 'disease' is not null or undefined
            assertParamExists('diseasesPutOne', 'disease', disease)
            const localVarPath = `/v1/diseases/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disease, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Diseases
         * @param {Array<Disease>} disease 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diseasesPutSome: async (disease: Array<Disease>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'disease' is not null or undefined
            assertParamExists('diseasesPutSome', 'disease', disease)
            const localVarPath = `/v1/diseases/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disease, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiological Agents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologicalAgentsDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/etiological_agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiological Agents
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologicalAgentsDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('etiologicalAgentsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/etiological_agents/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiological Agents
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologicalAgentsDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('etiologicalAgentsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/etiological_agents/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiological Agents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologicalAgentsGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/etiological_agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiological Agents
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologicalAgentsGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('etiologicalAgentsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/etiological_agents/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiological Agents
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologicalAgentsGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('etiologicalAgentsGetSome', 'ids', ids)
            const localVarPath = `/v1/etiological_agents/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiological Agents
         * @param {EtiologicalAgent} etiologicalAgent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologicalAgentsPostOne: async (etiologicalAgent: EtiologicalAgent, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'etiologicalAgent' is not null or undefined
            assertParamExists('etiologicalAgentsPostOne', 'etiologicalAgent', etiologicalAgent)
            const localVarPath = `/v1/etiological_agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(etiologicalAgent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiological Agents
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologicalAgentsPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('etiologicalAgentsPostQuery', 'filter', filter)
            const localVarPath = `/v1/etiological_agents/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiological Agents
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologicalAgentsPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('etiologicalAgentsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/etiological_agents/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiological Agents
         * @param {Array<EtiologicalAgent>} etiologicalAgent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologicalAgentsPostSome: async (etiologicalAgent: Array<EtiologicalAgent>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'etiologicalAgent' is not null or undefined
            assertParamExists('etiologicalAgentsPostSome', 'etiologicalAgent', etiologicalAgent)
            const localVarPath = `/v1/etiological_agents/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(etiologicalAgent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiological Agents
         * @param {string} objectId 
         * @param {EtiologicalAgent} etiologicalAgent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologicalAgentsPutOne: async (objectId: string, etiologicalAgent: EtiologicalAgent, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('etiologicalAgentsPutOne', 'objectId', objectId)
            // verify required parameter 'etiologicalAgent' is not null or undefined
            assertParamExists('etiologicalAgentsPutOne', 'etiologicalAgent', etiologicalAgent)
            const localVarPath = `/v1/etiological_agents/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(etiologicalAgent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiological Agents
         * @param {Array<EtiologicalAgent>} etiologicalAgent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologicalAgentsPutSome: async (etiologicalAgent: Array<EtiologicalAgent>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'etiologicalAgent' is not null or undefined
            assertParamExists('etiologicalAgentsPutSome', 'etiologicalAgent', etiologicalAgent)
            const localVarPath = `/v1/etiological_agents/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(etiologicalAgent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiologies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologiesDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/etiologies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiologies
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologiesDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('etiologiesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/etiologies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiologies
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologiesDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('etiologiesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/etiologies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiologies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologiesGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/etiologies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiologies
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologiesGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('etiologiesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/etiologies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiologies
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologiesGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('etiologiesGetSome', 'ids', ids)
            const localVarPath = `/v1/etiologies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiologies
         * @param {Etiology} etiology 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologiesPostOne: async (etiology: Etiology, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'etiology' is not null or undefined
            assertParamExists('etiologiesPostOne', 'etiology', etiology)
            const localVarPath = `/v1/etiologies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(etiology, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiologies
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologiesPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('etiologiesPostQuery', 'filter', filter)
            const localVarPath = `/v1/etiologies/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiologies
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologiesPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('etiologiesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/etiologies/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiologies
         * @param {Array<Etiology>} etiology 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologiesPostSome: async (etiology: Array<Etiology>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'etiology' is not null or undefined
            assertParamExists('etiologiesPostSome', 'etiology', etiology)
            const localVarPath = `/v1/etiologies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(etiology, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiologies
         * @param {string} objectId 
         * @param {Etiology} etiology 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologiesPutOne: async (objectId: string, etiology: Etiology, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('etiologiesPutOne', 'objectId', objectId)
            // verify required parameter 'etiology' is not null or undefined
            assertParamExists('etiologiesPutOne', 'etiology', etiology)
            const localVarPath = `/v1/etiologies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(etiology, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiologies
         * @param {Array<Etiology>} etiology 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologiesPutSome: async (etiology: Array<Etiology>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'etiology' is not null or undefined
            assertParamExists('etiologiesPutSome', 'etiology', etiology)
            const localVarPath = `/v1/etiologies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(etiology, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OntologyApi - functional programming interface
 * @export
 */
const OntologyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OntologyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Concept Set Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetMembersDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetMembersDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concept Set Members
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetMembersDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetMembersDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concept Set Members
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetMembersDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetMembersDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concept Set Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetMembersGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConceptSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetMembersGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concept Set Members
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetMembersGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConceptSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetMembersGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concept Set Members
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetMembersGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConceptSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetMembersGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concept Set Members
         * @param {ConceptSetMember} conceptSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetMembersPostOne(conceptSetMember: ConceptSetMember, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConceptSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetMembersPostOne(conceptSetMember, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concept Set Members
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetMembersPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConceptSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetMembersPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concept Set Members
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetMembersPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetMembersPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concept Set Members
         * @param {Array<ConceptSetMember>} conceptSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetMembersPostSome(conceptSetMember: Array<ConceptSetMember>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConceptSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetMembersPostSome(conceptSetMember, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concept Set Members
         * @param {string} objectId 
         * @param {ConceptSetMember} conceptSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetMembersPutOne(objectId: string, conceptSetMember: ConceptSetMember, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConceptSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetMembersPutOne(objectId, conceptSetMember, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concept Set Members
         * @param {Array<ConceptSetMember>} conceptSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetMembersPutSome(conceptSetMember: Array<ConceptSetMember>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConceptSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetMembersPutSome(conceptSetMember, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concept Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetsDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetsDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concept Sets
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetsDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetsDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concept Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetsDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetsDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concept Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetsGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConceptSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetsGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concept Sets
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetsGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConceptSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetsGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concept Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetsGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConceptSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetsGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concept Sets
         * @param {ConceptSet} conceptSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetsPostOne(conceptSet: ConceptSet, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConceptSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetsPostOne(conceptSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concept Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetsPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConceptSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetsPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concept Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetsPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetsPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concept Sets
         * @param {Array<ConceptSet>} conceptSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetsPostSome(conceptSet: Array<ConceptSet>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConceptSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetsPostSome(conceptSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Conceptset Concept
         * @param {string} conceptSetId 
         * @param {UpdateConceptSetConceptRequestBody} updateConceptSetConceptRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetsPutConcepts(conceptSetId: string, updateConceptSetConceptRequestBody: UpdateConceptSetConceptRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConceptSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetsPutConcepts(conceptSetId, updateConceptSetConceptRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concept Sets
         * @param {string} objectId 
         * @param {ConceptSet} conceptSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetsPutOne(objectId: string, conceptSet: ConceptSet, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConceptSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetsPutOne(objectId, conceptSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concept Sets
         * @param {Array<ConceptSet>} conceptSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetsPutSome(conceptSet: Array<ConceptSet>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConceptSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetsPutSome(conceptSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concepts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptsDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptsDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concepts
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptsDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptsDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concepts
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptsDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptsDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concepts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptsGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Concept>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptsGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concepts
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptsGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Concept>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptsGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concepts
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptsGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Concept>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptsGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concepts
         * @param {Concept} concept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptsPostOne(concept: Concept, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Concept>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptsPostOne(concept, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concepts
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptsPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Concept>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptsPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concepts
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptsPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptsPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concepts
         * @param {Array<Concept>} concept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptsPostSome(concept: Array<Concept>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Concept>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptsPostSome(concept, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concepts
         * @param {string} objectId 
         * @param {Concept} concept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptsPutOne(objectId: string, concept: Concept, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Concept>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptsPutOne(objectId, concept, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Concepts
         * @param {Array<Concept>} concept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptsPutSome(concept: Array<Concept>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Concept>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptsPutSome(concept, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Diseases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diseasesDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diseasesDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Diseases
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diseasesDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diseasesDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Diseases
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diseasesDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diseasesDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Diseases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diseasesGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Disease>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diseasesGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Diseases
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diseasesGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Disease>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diseasesGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Diseases
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diseasesGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Disease>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diseasesGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Diseases
         * @param {Disease} disease 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diseasesPostOne(disease: Disease, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Disease>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diseasesPostOne(disease, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Diseases
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diseasesPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Disease>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diseasesPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Diseases
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diseasesPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diseasesPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Diseases
         * @param {Array<Disease>} disease 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diseasesPostSome(disease: Array<Disease>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Disease>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diseasesPostSome(disease, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Disease Etiologicalagent
         * @param {string} diseaseId 
         * @param {UpdateDiseaseEtiologicalAgentRequestBody} updateDiseaseEtiologicalAgentRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diseasesPutEtiologicalAgents(diseaseId: string, updateDiseaseEtiologicalAgentRequestBody: UpdateDiseaseEtiologicalAgentRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Etiology>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diseasesPutEtiologicalAgents(diseaseId, updateDiseaseEtiologicalAgentRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Diseases
         * @param {string} objectId 
         * @param {Disease} disease 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diseasesPutOne(objectId: string, disease: Disease, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Disease>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diseasesPutOne(objectId, disease, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Diseases
         * @param {Array<Disease>} disease 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diseasesPutSome(disease: Array<Disease>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Disease>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diseasesPutSome(disease, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Etiological Agents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologicalAgentsDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologicalAgentsDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Etiological Agents
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologicalAgentsDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologicalAgentsDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Etiological Agents
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologicalAgentsDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologicalAgentsDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Etiological Agents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologicalAgentsGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EtiologicalAgent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologicalAgentsGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Etiological Agents
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologicalAgentsGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EtiologicalAgent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologicalAgentsGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Etiological Agents
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologicalAgentsGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EtiologicalAgent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologicalAgentsGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Etiological Agents
         * @param {EtiologicalAgent} etiologicalAgent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologicalAgentsPostOne(etiologicalAgent: EtiologicalAgent, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EtiologicalAgent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologicalAgentsPostOne(etiologicalAgent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Etiological Agents
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologicalAgentsPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EtiologicalAgent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologicalAgentsPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Etiological Agents
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologicalAgentsPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologicalAgentsPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Etiological Agents
         * @param {Array<EtiologicalAgent>} etiologicalAgent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologicalAgentsPostSome(etiologicalAgent: Array<EtiologicalAgent>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EtiologicalAgent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologicalAgentsPostSome(etiologicalAgent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Etiological Agents
         * @param {string} objectId 
         * @param {EtiologicalAgent} etiologicalAgent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologicalAgentsPutOne(objectId: string, etiologicalAgent: EtiologicalAgent, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EtiologicalAgent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologicalAgentsPutOne(objectId, etiologicalAgent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Etiological Agents
         * @param {Array<EtiologicalAgent>} etiologicalAgent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologicalAgentsPutSome(etiologicalAgent: Array<EtiologicalAgent>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EtiologicalAgent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologicalAgentsPutSome(etiologicalAgent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Etiologies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologiesDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologiesDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Etiologies
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologiesDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologiesDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Etiologies
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologiesDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologiesDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Etiologies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologiesGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Etiology>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologiesGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Etiologies
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologiesGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Etiology>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologiesGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Etiologies
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologiesGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Etiology>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologiesGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Etiologies
         * @param {Etiology} etiology 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologiesPostOne(etiology: Etiology, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Etiology>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologiesPostOne(etiology, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Etiologies
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologiesPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Etiology>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologiesPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Etiologies
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologiesPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologiesPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Etiologies
         * @param {Array<Etiology>} etiology 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologiesPostSome(etiology: Array<Etiology>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Etiology>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologiesPostSome(etiology, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Etiologies
         * @param {string} objectId 
         * @param {Etiology} etiology 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologiesPutOne(objectId: string, etiology: Etiology, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Etiology>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologiesPutOne(objectId, etiology, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Etiologies
         * @param {Array<Etiology>} etiology 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologiesPutSome(etiology: Array<Etiology>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Etiology>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologiesPutSome(etiology, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
    }
};

/**
 * OntologyApi - factory interface
 * @export
 */

/**
 * OntologyApi - object-oriented interface

 * @export
 * @class OntologyApi
 * @extends {BaseAPI}
 */
export class OntologyApi extends BaseAPI {
  public static instance: OntologyApi;
  public static getInstance(): OntologyApi {
    this.instance = this.instance || new OntologyApi();
    return this.instance;
  }

    /**
     * 
     * @summary Concept Set Members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetMembersDeleteAll(options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetMembersDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Set Members
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetMembersDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetMembersDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Set Members
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetMembersDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetMembersDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Set Members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetMembersGetAll(options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetMembersGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Set Members
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetMembersGetOne(objectId: string, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetMembersGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Set Members
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetMembersGetSome(ids: string, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetMembersGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Set Members
     * @param {ConceptSetMember} conceptSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetMembersPostOne(conceptSetMember: ConceptSetMember, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetMembersPostOne(conceptSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Set Members
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetMembersPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetMembersPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Set Members
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetMembersPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetMembersPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Set Members
     * @param {Array<ConceptSetMember>} conceptSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetMembersPostSome(conceptSetMember: Array<ConceptSetMember>, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetMembersPostSome(conceptSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Set Members
     * @param {string} objectId 
     * @param {ConceptSetMember} conceptSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetMembersPutOne(objectId: string, conceptSetMember: ConceptSetMember, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetMembersPutOne(objectId, conceptSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Set Members
     * @param {Array<ConceptSetMember>} conceptSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetMembersPutSome(conceptSetMember: Array<ConceptSetMember>, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetMembersPutSome(conceptSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Sets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetsDeleteAll(options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Sets
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetsDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Sets
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetsDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Sets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetsGetAll(options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Sets
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetsGetOne(objectId: string, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Sets
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetsGetSome(ids: string, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Sets
     * @param {ConceptSet} conceptSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetsPostOne(conceptSet: ConceptSet, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetsPostOne(conceptSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Sets
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetsPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Sets
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetsPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Sets
     * @param {Array<ConceptSet>} conceptSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetsPostSome(conceptSet: Array<ConceptSet>, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetsPostSome(conceptSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Conceptset Concept
     * @param {string} conceptSetId 
     * @param {UpdateConceptSetConceptRequestBody} updateConceptSetConceptRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetsPutConcepts(conceptSetId: string, updateConceptSetConceptRequestBody: UpdateConceptSetConceptRequestBody, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetsPutConcepts(conceptSetId, updateConceptSetConceptRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Sets
     * @param {string} objectId 
     * @param {ConceptSet} conceptSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetsPutOne(objectId: string, conceptSet: ConceptSet, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetsPutOne(objectId, conceptSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Sets
     * @param {Array<ConceptSet>} conceptSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetsPutSome(conceptSet: Array<ConceptSet>, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetsPutSome(conceptSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concepts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptsDeleteAll(options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concepts
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptsDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concepts
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptsDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concepts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptsGetAll(options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concepts
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptsGetOne(objectId: string, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concepts
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptsGetSome(ids: string, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concepts
     * @param {Concept} concept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptsPostOne(concept: Concept, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptsPostOne(concept, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concepts
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptsPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concepts
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptsPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concepts
     * @param {Array<Concept>} concept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptsPostSome(concept: Array<Concept>, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptsPostSome(concept, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concepts
     * @param {string} objectId 
     * @param {Concept} concept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptsPutOne(objectId: string, concept: Concept, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptsPutOne(objectId, concept, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concepts
     * @param {Array<Concept>} concept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptsPutSome(concept: Array<Concept>, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptsPutSome(concept, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Diseases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public diseasesDeleteAll(options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).diseasesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Diseases
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public diseasesDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).diseasesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Diseases
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public diseasesDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).diseasesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Diseases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public diseasesGetAll(options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).diseasesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Diseases
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public diseasesGetOne(objectId: string, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).diseasesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Diseases
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public diseasesGetSome(ids: string, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).diseasesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Diseases
     * @param {Disease} disease 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public diseasesPostOne(disease: Disease, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).diseasesPostOne(disease, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Diseases
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public diseasesPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).diseasesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Diseases
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public diseasesPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).diseasesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Diseases
     * @param {Array<Disease>} disease 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public diseasesPostSome(disease: Array<Disease>, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).diseasesPostSome(disease, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Disease Etiologicalagent
     * @param {string} diseaseId 
     * @param {UpdateDiseaseEtiologicalAgentRequestBody} updateDiseaseEtiologicalAgentRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public diseasesPutEtiologicalAgents(diseaseId: string, updateDiseaseEtiologicalAgentRequestBody: UpdateDiseaseEtiologicalAgentRequestBody, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).diseasesPutEtiologicalAgents(diseaseId, updateDiseaseEtiologicalAgentRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Diseases
     * @param {string} objectId 
     * @param {Disease} disease 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public diseasesPutOne(objectId: string, disease: Disease, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).diseasesPutOne(objectId, disease, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Diseases
     * @param {Array<Disease>} disease 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public diseasesPutSome(disease: Array<Disease>, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).diseasesPutSome(disease, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiological Agents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologicalAgentsDeleteAll(options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologicalAgentsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiological Agents
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologicalAgentsDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologicalAgentsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiological Agents
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologicalAgentsDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologicalAgentsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiological Agents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologicalAgentsGetAll(options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologicalAgentsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiological Agents
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologicalAgentsGetOne(objectId: string, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologicalAgentsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiological Agents
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologicalAgentsGetSome(ids: string, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologicalAgentsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiological Agents
     * @param {EtiologicalAgent} etiologicalAgent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologicalAgentsPostOne(etiologicalAgent: EtiologicalAgent, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologicalAgentsPostOne(etiologicalAgent, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiological Agents
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologicalAgentsPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologicalAgentsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiological Agents
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologicalAgentsPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologicalAgentsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiological Agents
     * @param {Array<EtiologicalAgent>} etiologicalAgent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologicalAgentsPostSome(etiologicalAgent: Array<EtiologicalAgent>, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologicalAgentsPostSome(etiologicalAgent, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiological Agents
     * @param {string} objectId 
     * @param {EtiologicalAgent} etiologicalAgent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologicalAgentsPutOne(objectId: string, etiologicalAgent: EtiologicalAgent, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologicalAgentsPutOne(objectId, etiologicalAgent, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiological Agents
     * @param {Array<EtiologicalAgent>} etiologicalAgent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologicalAgentsPutSome(etiologicalAgent: Array<EtiologicalAgent>, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologicalAgentsPutSome(etiologicalAgent, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiologies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologiesDeleteAll(options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologiesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiologies
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologiesDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologiesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiologies
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologiesDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologiesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiologies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologiesGetAll(options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologiesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiologies
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologiesGetOne(objectId: string, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologiesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiologies
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologiesGetSome(ids: string, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologiesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiologies
     * @param {Etiology} etiology 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologiesPostOne(etiology: Etiology, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologiesPostOne(etiology, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiologies
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologiesPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologiesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiologies
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologiesPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologiesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiologies
     * @param {Array<Etiology>} etiology 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologiesPostSome(etiology: Array<Etiology>, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologiesPostSome(etiology, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiologies
     * @param {string} objectId 
     * @param {Etiology} etiology 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologiesPutOne(objectId: string, etiology: Etiology, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologiesPutOne(objectId, etiology, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiologies
     * @param {Array<Etiology>} etiology 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologiesPutSome(etiology: Array<Etiology>, options?: AxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologiesPutSome(etiology, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }
}



/**
 * OrganizationApi - axios parameter creator
 * @export
 */
const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A class representing contact information for an organization.
         * @summary Contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A class representing contact information for an organization.
         * @summary Contacts
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('contactsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/contacts/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A class representing contact information for an organization.
         * @summary Contacts
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('contactsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/contacts/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A class representing contact information for an organization.
         * @summary Contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A class representing contact information for an organization.
         * @summary Contacts
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('contactsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/contacts/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A class representing contact information for an organization.
         * @summary Contacts
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('contactsGetSome', 'ids', ids)
            const localVarPath = `/v1/contacts/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A class representing contact information for an organization.
         * @summary Contacts
         * @param {Contact} contact 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPostOne: async (contact: Contact, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contact' is not null or undefined
            assertParamExists('contactsPostOne', 'contact', contact)
            const localVarPath = `/v1/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contact, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A class representing contact information for an organization.
         * @summary Contacts
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('contactsPostQuery', 'filter', filter)
            const localVarPath = `/v1/contacts/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A class representing contact information for an organization.
         * @summary Contacts
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('contactsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/contacts/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A class representing contact information for an organization.
         * @summary Contacts
         * @param {Array<Contact>} contact 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPostSome: async (contact: Array<Contact>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contact' is not null or undefined
            assertParamExists('contactsPostSome', 'contact', contact)
            const localVarPath = `/v1/contacts/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contact, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A class representing contact information for an organization.
         * @summary Contacts
         * @param {string} objectId 
         * @param {Contact} contact 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPutOne: async (objectId: string, contact: Contact, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('contactsPutOne', 'objectId', objectId)
            // verify required parameter 'contact' is not null or undefined
            assertParamExists('contactsPutOne', 'contact', contact)
            const localVarPath = `/v1/contacts/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contact, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A class representing contact information for an organization.
         * @summary Contacts
         * @param {Array<Contact>} contact 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPutSome: async (contact: Array<Contact>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contact' is not null or undefined
            assertParamExists('contactsPutSome', 'contact', contact)
            const localVarPath = `/v1/contacts/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contact, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a directional relationship between two data collections.
         * @summary Data Collection Relations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionRelationsDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/data_collection_relations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a directional relationship between two data collections.
         * @summary Data Collection Relations
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionRelationsDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dataCollectionRelationsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/data_collection_relations/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a directional relationship between two data collections.
         * @summary Data Collection Relations
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionRelationsDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('dataCollectionRelationsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/data_collection_relations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a directional relationship between two data collections.
         * @summary Data Collection Relations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionRelationsGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/data_collection_relations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a directional relationship between two data collections.
         * @summary Data Collection Relations
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionRelationsGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dataCollectionRelationsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/data_collection_relations/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a directional relationship between two data collections.
         * @summary Data Collection Relations
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionRelationsGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('dataCollectionRelationsGetSome', 'ids', ids)
            const localVarPath = `/v1/data_collection_relations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a directional relationship between two data collections.
         * @summary Data Collection Relations
         * @param {DataCollectionRelation} dataCollectionRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionRelationsPostOne: async (dataCollectionRelation: DataCollectionRelation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCollectionRelation' is not null or undefined
            assertParamExists('dataCollectionRelationsPostOne', 'dataCollectionRelation', dataCollectionRelation)
            const localVarPath = `/v1/data_collection_relations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollectionRelation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a directional relationship between two data collections.
         * @summary Data Collection Relations
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionRelationsPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('dataCollectionRelationsPostQuery', 'filter', filter)
            const localVarPath = `/v1/data_collection_relations/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a directional relationship between two data collections.
         * @summary Data Collection Relations
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionRelationsPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('dataCollectionRelationsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/data_collection_relations/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a directional relationship between two data collections.
         * @summary Data Collection Relations
         * @param {Array<DataCollectionRelation>} dataCollectionRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionRelationsPostSome: async (dataCollectionRelation: Array<DataCollectionRelation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCollectionRelation' is not null or undefined
            assertParamExists('dataCollectionRelationsPostSome', 'dataCollectionRelation', dataCollectionRelation)
            const localVarPath = `/v1/data_collection_relations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollectionRelation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a directional relationship between two data collections.
         * @summary Data Collection Relations
         * @param {string} objectId 
         * @param {DataCollectionRelation} dataCollectionRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionRelationsPutOne: async (objectId: string, dataCollectionRelation: DataCollectionRelation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dataCollectionRelationsPutOne', 'objectId', objectId)
            // verify required parameter 'dataCollectionRelation' is not null or undefined
            assertParamExists('dataCollectionRelationsPutOne', 'dataCollectionRelation', dataCollectionRelation)
            const localVarPath = `/v1/data_collection_relations/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollectionRelation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a directional relationship between two data collections.
         * @summary Data Collection Relations
         * @param {Array<DataCollectionRelation>} dataCollectionRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionRelationsPutSome: async (dataCollectionRelation: Array<DataCollectionRelation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCollectionRelation' is not null or undefined
            assertParamExists('dataCollectionRelationsPutSome', 'dataCollectionRelation', dataCollectionRelation)
            const localVarPath = `/v1/data_collection_relations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollectionRelation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Set Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetMembersDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/data_collection_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Set Members
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetMembersDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dataCollectionSetMembersDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/data_collection_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Set Members
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetMembersDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('dataCollectionSetMembersDeleteSome', 'ids', ids)
            const localVarPath = `/v1/data_collection_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Set Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetMembersGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/data_collection_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Set Members
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetMembersGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dataCollectionSetMembersGetOne', 'objectId', objectId)
            const localVarPath = `/v1/data_collection_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Set Members
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetMembersGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('dataCollectionSetMembersGetSome', 'ids', ids)
            const localVarPath = `/v1/data_collection_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Set Members
         * @param {DataCollectionSetMember} dataCollectionSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetMembersPostOne: async (dataCollectionSetMember: DataCollectionSetMember, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCollectionSetMember' is not null or undefined
            assertParamExists('dataCollectionSetMembersPostOne', 'dataCollectionSetMember', dataCollectionSetMember)
            const localVarPath = `/v1/data_collection_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollectionSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Set Members
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetMembersPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('dataCollectionSetMembersPostQuery', 'filter', filter)
            const localVarPath = `/v1/data_collection_set_members/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Set Members
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetMembersPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('dataCollectionSetMembersPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/data_collection_set_members/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Set Members
         * @param {Array<DataCollectionSetMember>} dataCollectionSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetMembersPostSome: async (dataCollectionSetMember: Array<DataCollectionSetMember>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCollectionSetMember' is not null or undefined
            assertParamExists('dataCollectionSetMembersPostSome', 'dataCollectionSetMember', dataCollectionSetMember)
            const localVarPath = `/v1/data_collection_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollectionSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Set Members
         * @param {string} objectId 
         * @param {DataCollectionSetMember} dataCollectionSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetMembersPutOne: async (objectId: string, dataCollectionSetMember: DataCollectionSetMember, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dataCollectionSetMembersPutOne', 'objectId', objectId)
            // verify required parameter 'dataCollectionSetMember' is not null or undefined
            assertParamExists('dataCollectionSetMembersPutOne', 'dataCollectionSetMember', dataCollectionSetMember)
            const localVarPath = `/v1/data_collection_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollectionSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Set Members
         * @param {Array<DataCollectionSetMember>} dataCollectionSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetMembersPutSome: async (dataCollectionSetMember: Array<DataCollectionSetMember>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCollectionSetMember' is not null or undefined
            assertParamExists('dataCollectionSetMembersPutSome', 'dataCollectionSetMember', dataCollectionSetMember)
            const localVarPath = `/v1/data_collection_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollectionSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetsDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/data_collection_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Sets
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetsDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dataCollectionSetsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/data_collection_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetsDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('dataCollectionSetsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/data_collection_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetsGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/data_collection_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Sets
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetsGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dataCollectionSetsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/data_collection_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetsGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('dataCollectionSetsGetSome', 'ids', ids)
            const localVarPath = `/v1/data_collection_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Sets
         * @param {DataCollectionSet} dataCollectionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetsPostOne: async (dataCollectionSet: DataCollectionSet, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCollectionSet' is not null or undefined
            assertParamExists('dataCollectionSetsPostOne', 'dataCollectionSet', dataCollectionSet)
            const localVarPath = `/v1/data_collection_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollectionSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetsPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('dataCollectionSetsPostQuery', 'filter', filter)
            const localVarPath = `/v1/data_collection_sets/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetsPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('dataCollectionSetsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/data_collection_sets/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Sets
         * @param {Array<DataCollectionSet>} dataCollectionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetsPostSome: async (dataCollectionSet: Array<DataCollectionSet>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCollectionSet' is not null or undefined
            assertParamExists('dataCollectionSetsPostSome', 'dataCollectionSet', dataCollectionSet)
            const localVarPath = `/v1/data_collection_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollectionSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Datacollectionset Datacollection
         * @param {string} dataCollectionSetId 
         * @param {UpdateDataCollectionSetDataCollectionRequestBody} updateDataCollectionSetDataCollectionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetsPutDataCollections: async (dataCollectionSetId: string, updateDataCollectionSetDataCollectionRequestBody: UpdateDataCollectionSetDataCollectionRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCollectionSetId' is not null or undefined
            assertParamExists('dataCollectionSetsPutDataCollections', 'dataCollectionSetId', dataCollectionSetId)
            // verify required parameter 'updateDataCollectionSetDataCollectionRequestBody' is not null or undefined
            assertParamExists('dataCollectionSetsPutDataCollections', 'updateDataCollectionSetDataCollectionRequestBody', updateDataCollectionSetDataCollectionRequestBody)
            const localVarPath = `/v1/data_collection_sets/{data_collection_set_id}/data_collections`
                .replace(`{${"data_collection_set_id"}}`, encodeURIComponent(String(dataCollectionSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDataCollectionSetDataCollectionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Sets
         * @param {string} objectId 
         * @param {DataCollectionSet} dataCollectionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetsPutOne: async (objectId: string, dataCollectionSet: DataCollectionSet, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dataCollectionSetsPutOne', 'objectId', objectId)
            // verify required parameter 'dataCollectionSet' is not null or undefined
            assertParamExists('dataCollectionSetsPutOne', 'dataCollectionSet', dataCollectionSet)
            const localVarPath = `/v1/data_collection_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollectionSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Sets
         * @param {Array<DataCollectionSet>} dataCollectionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetsPutSome: async (dataCollectionSet: Array<DataCollectionSet>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCollectionSet' is not null or undefined
            assertParamExists('dataCollectionSetsPutSome', 'dataCollectionSet', dataCollectionSet)
            const localVarPath = `/v1/data_collection_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollectionSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a collection of data.
         * @summary Data Collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionsDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/data_collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a collection of data.
         * @summary Data Collections
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionsDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dataCollectionsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/data_collections/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a collection of data.
         * @summary Data Collections
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionsDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('dataCollectionsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/data_collections/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a collection of data.
         * @summary Data Collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionsGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/data_collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a collection of data.
         * @summary Data Collections
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionsGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dataCollectionsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/data_collections/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a collection of data.
         * @summary Data Collections
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionsGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('dataCollectionsGetSome', 'ids', ids)
            const localVarPath = `/v1/data_collections/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a collection of data.
         * @summary Data Collections
         * @param {DataCollection} dataCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionsPostOne: async (dataCollection: DataCollection, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCollection' is not null or undefined
            assertParamExists('dataCollectionsPostOne', 'dataCollection', dataCollection)
            const localVarPath = `/v1/data_collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a collection of data.
         * @summary Data Collections
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionsPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('dataCollectionsPostQuery', 'filter', filter)
            const localVarPath = `/v1/data_collections/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a collection of data.
         * @summary Data Collections
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionsPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('dataCollectionsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/data_collections/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a collection of data.
         * @summary Data Collections
         * @param {Array<DataCollection>} dataCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionsPostSome: async (dataCollection: Array<DataCollection>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCollection' is not null or undefined
            assertParamExists('dataCollectionsPostSome', 'dataCollection', dataCollection)
            const localVarPath = `/v1/data_collections/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a collection of data.
         * @summary Data Collections
         * @param {string} objectId 
         * @param {DataCollection} dataCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionsPutOne: async (objectId: string, dataCollection: DataCollection, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dataCollectionsPutOne', 'objectId', objectId)
            // verify required parameter 'dataCollection' is not null or undefined
            assertParamExists('dataCollectionsPutOne', 'dataCollection', dataCollection)
            const localVarPath = `/v1/data_collections/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a collection of data.
         * @summary Data Collections
         * @param {Array<DataCollection>} dataCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionsPutSome: async (dataCollection: Array<DataCollection>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCollection' is not null or undefined
            assertParamExists('dataCollectionsPutSome', 'dataCollection', dataCollection)
            const localVarPath = `/v1/data_collections/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
         * @summary Identifier Issuers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierIssuersDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/identifier_issuers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
         * @summary Identifier Issuers
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierIssuersDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('identifierIssuersDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/identifier_issuers/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
         * @summary Identifier Issuers
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierIssuersDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('identifierIssuersDeleteSome', 'ids', ids)
            const localVarPath = `/v1/identifier_issuers/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
         * @summary Identifier Issuers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierIssuersGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/identifier_issuers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
         * @summary Identifier Issuers
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierIssuersGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('identifierIssuersGetOne', 'objectId', objectId)
            const localVarPath = `/v1/identifier_issuers/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
         * @summary Identifier Issuers
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierIssuersGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('identifierIssuersGetSome', 'ids', ids)
            const localVarPath = `/v1/identifier_issuers/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
         * @summary Identifier Issuers
         * @param {IdentifierIssuer} identifierIssuer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierIssuersPostOne: async (identifierIssuer: IdentifierIssuer, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifierIssuer' is not null or undefined
            assertParamExists('identifierIssuersPostOne', 'identifierIssuer', identifierIssuer)
            const localVarPath = `/v1/identifier_issuers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identifierIssuer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
         * @summary Identifier Issuers
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierIssuersPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('identifierIssuersPostQuery', 'filter', filter)
            const localVarPath = `/v1/identifier_issuers/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
         * @summary Identifier Issuers
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierIssuersPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('identifierIssuersPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/identifier_issuers/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
         * @summary Identifier Issuers
         * @param {Array<IdentifierIssuer>} identifierIssuer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierIssuersPostSome: async (identifierIssuer: Array<IdentifierIssuer>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifierIssuer' is not null or undefined
            assertParamExists('identifierIssuersPostSome', 'identifierIssuer', identifierIssuer)
            const localVarPath = `/v1/identifier_issuers/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identifierIssuer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
         * @summary Identifier Issuers
         * @param {string} objectId 
         * @param {IdentifierIssuer} identifierIssuer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierIssuersPutOne: async (objectId: string, identifierIssuer: IdentifierIssuer, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('identifierIssuersPutOne', 'objectId', objectId)
            // verify required parameter 'identifierIssuer' is not null or undefined
            assertParamExists('identifierIssuersPutOne', 'identifierIssuer', identifierIssuer)
            const localVarPath = `/v1/identifier_issuers/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identifierIssuer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
         * @summary Identifier Issuers
         * @param {Array<IdentifierIssuer>} identifierIssuer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierIssuersPutSome: async (identifierIssuer: Array<IdentifierIssuer>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifierIssuer' is not null or undefined
            assertParamExists('identifierIssuersPutSome', 'identifierIssuer', identifierIssuer)
            const localVarPath = `/v1/identifier_issuers/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identifierIssuer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Set Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetMembersDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organization_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Set Members
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetMembersDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationSetMembersDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/organization_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Set Members
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetMembersDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('organizationSetMembersDeleteSome', 'ids', ids)
            const localVarPath = `/v1/organization_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Set Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetMembersGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organization_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Set Members
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetMembersGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationSetMembersGetOne', 'objectId', objectId)
            const localVarPath = `/v1/organization_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Set Members
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetMembersGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('organizationSetMembersGetSome', 'ids', ids)
            const localVarPath = `/v1/organization_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Set Members
         * @param {OrganizationSetMember} organizationSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetMembersPostOne: async (organizationSetMember: OrganizationSetMember, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationSetMember' is not null or undefined
            assertParamExists('organizationSetMembersPostOne', 'organizationSetMember', organizationSetMember)
            const localVarPath = `/v1/organization_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Set Members
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetMembersPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('organizationSetMembersPostQuery', 'filter', filter)
            const localVarPath = `/v1/organization_set_members/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Set Members
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetMembersPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('organizationSetMembersPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/organization_set_members/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Set Members
         * @param {Array<OrganizationSetMember>} organizationSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetMembersPostSome: async (organizationSetMember: Array<OrganizationSetMember>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationSetMember' is not null or undefined
            assertParamExists('organizationSetMembersPostSome', 'organizationSetMember', organizationSetMember)
            const localVarPath = `/v1/organization_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Set Members
         * @param {string} objectId 
         * @param {OrganizationSetMember} organizationSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetMembersPutOne: async (objectId: string, organizationSetMember: OrganizationSetMember, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationSetMembersPutOne', 'objectId', objectId)
            // verify required parameter 'organizationSetMember' is not null or undefined
            assertParamExists('organizationSetMembersPutOne', 'organizationSetMember', organizationSetMember)
            const localVarPath = `/v1/organization_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Set Members
         * @param {Array<OrganizationSetMember>} organizationSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetMembersPutSome: async (organizationSetMember: Array<OrganizationSetMember>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationSetMember' is not null or undefined
            assertParamExists('organizationSetMembersPutSome', 'organizationSetMember', organizationSetMember)
            const localVarPath = `/v1/organization_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetsDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organization_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Sets
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetsDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationSetsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/organization_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetsDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('organizationSetsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/organization_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetsGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organization_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Sets
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetsGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationSetsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/organization_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetsGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('organizationSetsGetSome', 'ids', ids)
            const localVarPath = `/v1/organization_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Sets
         * @param {OrganizationSet} organizationSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetsPostOne: async (organizationSet: OrganizationSet, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationSet' is not null or undefined
            assertParamExists('organizationSetsPostOne', 'organizationSet', organizationSet)
            const localVarPath = `/v1/organization_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetsPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('organizationSetsPostQuery', 'filter', filter)
            const localVarPath = `/v1/organization_sets/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetsPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('organizationSetsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/organization_sets/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Sets
         * @param {Array<OrganizationSet>} organizationSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetsPostSome: async (organizationSet: Array<OrganizationSet>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationSet' is not null or undefined
            assertParamExists('organizationSetsPostSome', 'organizationSet', organizationSet)
            const localVarPath = `/v1/organization_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Sets
         * @param {string} objectId 
         * @param {OrganizationSet} organizationSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetsPutOne: async (objectId: string, organizationSet: OrganizationSet, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationSetsPutOne', 'objectId', objectId)
            // verify required parameter 'organizationSet' is not null or undefined
            assertParamExists('organizationSetsPutOne', 'organizationSet', organizationSet)
            const localVarPath = `/v1/organization_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organizationset Organization
         * @param {string} organizationSetId 
         * @param {UpdateOrganizationSetOrganizationRequestBody} updateOrganizationSetOrganizationRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetsPutOrganizations: async (organizationSetId: string, updateOrganizationSetOrganizationRequestBody: UpdateOrganizationSetOrganizationRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationSetId' is not null or undefined
            assertParamExists('organizationSetsPutOrganizations', 'organizationSetId', organizationSetId)
            // verify required parameter 'updateOrganizationSetOrganizationRequestBody' is not null or undefined
            assertParamExists('organizationSetsPutOrganizations', 'updateOrganizationSetOrganizationRequestBody', updateOrganizationSetOrganizationRequestBody)
            const localVarPath = `/v1/organization_sets/{organization_set_id}/organizations`
                .replace(`{${"organization_set_id"}}`, encodeURIComponent(String(organizationSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrganizationSetOrganizationRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Sets
         * @param {Array<OrganizationSet>} organizationSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetsPutSome: async (organizationSet: Array<OrganizationSet>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationSet' is not null or undefined
            assertParamExists('organizationSetsPutSome', 'organizationSet', organizationSet)
            const localVarPath = `/v1/organization_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents an organization.
         * @summary Organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents an organization.
         * @summary Organizations
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/organizations/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents an organization.
         * @summary Organizations
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('organizationsGetSome', 'ids', ids)
            const localVarPath = `/v1/organizations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents an organization.
         * @summary Organizations
         * @param {Organization} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsPostOne: async (organization: Organization, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('organizationsPostOne', 'organization', organization)
            const localVarPath = `/v1/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents an organization.
         * @summary Organizations
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('organizationsPostQuery', 'filter', filter)
            const localVarPath = `/v1/organizations/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents an organization.
         * @summary Organizations
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('organizationsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/organizations/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents an organization.
         * @summary Organizations
         * @param {Array<Organization>} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsPostSome: async (organization: Array<Organization>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('organizationsPostSome', 'organization', organization)
            const localVarPath = `/v1/organizations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents an organization.
         * @summary Organizations
         * @param {string} objectId 
         * @param {Organization} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsPutOne: async (objectId: string, organization: Organization, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationsPutOne', 'objectId', objectId)
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('organizationsPutOne', 'organization', organization)
            const localVarPath = `/v1/organizations/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents an organization.
         * @summary Organizations
         * @param {Array<Organization>} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsPutSome: async (organization: Array<Organization>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('organizationsPutSome', 'organization', organization)
            const localVarPath = `/v1/organizations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieveorganizationadminnameemailscommand
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveOrganizationAdminNameEmails: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/retrieve_organization_admin_name_emails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a physical site of an organization.
         * @summary Sites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a physical site of an organization.
         * @summary Sites
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('sitesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/sites/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a physical site of an organization.
         * @summary Sites
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('sitesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/sites/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a physical site of an organization.
         * @summary Sites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a physical site of an organization.
         * @summary Sites
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('sitesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/sites/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a physical site of an organization.
         * @summary Sites
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('sitesGetSome', 'ids', ids)
            const localVarPath = `/v1/sites/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a physical site of an organization.
         * @summary Sites
         * @param {Site} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesPostOne: async (site: Site, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('sitesPostOne', 'site', site)
            const localVarPath = `/v1/sites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(site, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a physical site of an organization.
         * @summary Sites
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('sitesPostQuery', 'filter', filter)
            const localVarPath = `/v1/sites/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a physical site of an organization.
         * @summary Sites
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('sitesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/sites/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a physical site of an organization.
         * @summary Sites
         * @param {Array<Site>} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesPostSome: async (site: Array<Site>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('sitesPostSome', 'site', site)
            const localVarPath = `/v1/sites/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(site, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a physical site of an organization.
         * @summary Sites
         * @param {string} objectId 
         * @param {Site} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesPutOne: async (objectId: string, site: Site, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('sitesPutOne', 'objectId', objectId)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('sitesPutOne', 'site', site)
            const localVarPath = `/v1/sites/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(site, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a physical site of an organization.
         * @summary Sites
         * @param {Array<Site>} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesPutSome: async (site: Array<Site>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('sitesPutSome', 'site', site)
            const localVarPath = `/v1/sites/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(site, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updateuserownorganization
         * @param {UpdateUserOwnOrganizationRequestBody} updateUserOwnOrganizationRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserOwnOrganization: async (updateUserOwnOrganizationRequestBody: UpdateUserOwnOrganizationRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserOwnOrganizationRequestBody' is not null or undefined
            assertParamExists('updateUserOwnOrganization', 'updateUserOwnOrganizationRequestBody', updateUserOwnOrganizationRequestBody)
            const localVarPath = `/v1/update_user_own_organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserOwnOrganizationRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Invitations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationsDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user_invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Invitations
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationsDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('userInvitationsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/user_invitations/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Invitations
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationsDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('userInvitationsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/user_invitations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Invitations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationsGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user_invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Invitations
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationsGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('userInvitationsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/user_invitations/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Invitations
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationsGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('userInvitationsGetSome', 'ids', ids)
            const localVarPath = `/v1/user_invitations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Invitations
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationsPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('userInvitationsPostQuery', 'filter', filter)
            const localVarPath = `/v1/user_invitations/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Invitations
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationsPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('userInvitationsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/user_invitations/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Userme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMeGetOne: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user_me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('usersGetOne', 'objectId', objectId)
            const localVarPath = `/v1/users/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('usersGetSome', 'ids', ids)
            const localVarPath = `/v1/users/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('usersPostQuery', 'filter', filter)
            const localVarPath = `/v1/users/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('usersPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/users/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updateuser
         * @param {string} objectId 
         * @param {UpdateUserRequestBody} updateUserRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPutOne: async (objectId: string, updateUserRequestBody: UpdateUserRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('usersPutOne', 'objectId', objectId)
            // verify required parameter 'updateUserRequestBody' is not null or undefined
            assertParamExists('usersPutOne', 'updateUserRequestBody', updateUserRequestBody)
            const localVarPath = `/v1/users/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
const OrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * A class representing contact information for an organization.
         * @summary Contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A class representing contact information for an organization.
         * @summary Contacts
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A class representing contact information for an organization.
         * @summary Contacts
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A class representing contact information for an organization.
         * @summary Contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Contact>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A class representing contact information for an organization.
         * @summary Contacts
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contact>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A class representing contact information for an organization.
         * @summary Contacts
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Contact>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A class representing contact information for an organization.
         * @summary Contacts
         * @param {Contact} contact 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsPostOne(contact: Contact, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contact>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsPostOne(contact, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A class representing contact information for an organization.
         * @summary Contacts
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Contact>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A class representing contact information for an organization.
         * @summary Contacts
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A class representing contact information for an organization.
         * @summary Contacts
         * @param {Array<Contact>} contact 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsPostSome(contact: Array<Contact>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Contact>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsPostSome(contact, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A class representing contact information for an organization.
         * @summary Contacts
         * @param {string} objectId 
         * @param {Contact} contact 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsPutOne(objectId: string, contact: Contact, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contact>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsPutOne(objectId, contact, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A class representing contact information for an organization.
         * @summary Contacts
         * @param {Array<Contact>} contact 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsPutSome(contact: Array<Contact>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Contact>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsPutSome(contact, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a directional relationship between two data collections.
         * @summary Data Collection Relations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionRelationsDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionRelationsDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a directional relationship between two data collections.
         * @summary Data Collection Relations
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionRelationsDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionRelationsDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a directional relationship between two data collections.
         * @summary Data Collection Relations
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionRelationsDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionRelationsDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a directional relationship between two data collections.
         * @summary Data Collection Relations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionRelationsGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionRelation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionRelationsGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a directional relationship between two data collections.
         * @summary Data Collection Relations
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionRelationsGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataCollectionRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionRelationsGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a directional relationship between two data collections.
         * @summary Data Collection Relations
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionRelationsGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionRelation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionRelationsGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a directional relationship between two data collections.
         * @summary Data Collection Relations
         * @param {DataCollectionRelation} dataCollectionRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionRelationsPostOne(dataCollectionRelation: DataCollectionRelation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataCollectionRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionRelationsPostOne(dataCollectionRelation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a directional relationship between two data collections.
         * @summary Data Collection Relations
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionRelationsPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionRelation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionRelationsPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a directional relationship between two data collections.
         * @summary Data Collection Relations
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionRelationsPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionRelationsPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a directional relationship between two data collections.
         * @summary Data Collection Relations
         * @param {Array<DataCollectionRelation>} dataCollectionRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionRelationsPostSome(dataCollectionRelation: Array<DataCollectionRelation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionRelation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionRelationsPostSome(dataCollectionRelation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a directional relationship between two data collections.
         * @summary Data Collection Relations
         * @param {string} objectId 
         * @param {DataCollectionRelation} dataCollectionRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionRelationsPutOne(objectId: string, dataCollectionRelation: DataCollectionRelation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataCollectionRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionRelationsPutOne(objectId, dataCollectionRelation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a directional relationship between two data collections.
         * @summary Data Collection Relations
         * @param {Array<DataCollectionRelation>} dataCollectionRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionRelationsPutSome(dataCollectionRelation: Array<DataCollectionRelation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionRelation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionRelationsPutSome(dataCollectionRelation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Data Collection Set Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetMembersDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetMembersDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Data Collection Set Members
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetMembersDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetMembersDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Data Collection Set Members
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetMembersDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetMembersDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Data Collection Set Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetMembersGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetMembersGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Data Collection Set Members
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetMembersGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataCollectionSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetMembersGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Data Collection Set Members
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetMembersGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetMembersGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Data Collection Set Members
         * @param {DataCollectionSetMember} dataCollectionSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetMembersPostOne(dataCollectionSetMember: DataCollectionSetMember, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataCollectionSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetMembersPostOne(dataCollectionSetMember, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Data Collection Set Members
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetMembersPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetMembersPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Data Collection Set Members
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetMembersPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetMembersPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Data Collection Set Members
         * @param {Array<DataCollectionSetMember>} dataCollectionSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetMembersPostSome(dataCollectionSetMember: Array<DataCollectionSetMember>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetMembersPostSome(dataCollectionSetMember, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Data Collection Set Members
         * @param {string} objectId 
         * @param {DataCollectionSetMember} dataCollectionSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetMembersPutOne(objectId: string, dataCollectionSetMember: DataCollectionSetMember, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataCollectionSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetMembersPutOne(objectId, dataCollectionSetMember, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Data Collection Set Members
         * @param {Array<DataCollectionSetMember>} dataCollectionSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetMembersPutSome(dataCollectionSetMember: Array<DataCollectionSetMember>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetMembersPutSome(dataCollectionSetMember, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Data Collection Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetsDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetsDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Data Collection Sets
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetsDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetsDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Data Collection Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetsDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetsDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Data Collection Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetsGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetsGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Data Collection Sets
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetsGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataCollectionSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetsGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Data Collection Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetsGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetsGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Data Collection Sets
         * @param {DataCollectionSet} dataCollectionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetsPostOne(dataCollectionSet: DataCollectionSet, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataCollectionSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetsPostOne(dataCollectionSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Data Collection Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetsPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetsPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Data Collection Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetsPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetsPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Data Collection Sets
         * @param {Array<DataCollectionSet>} dataCollectionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetsPostSome(dataCollectionSet: Array<DataCollectionSet>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetsPostSome(dataCollectionSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Datacollectionset Datacollection
         * @param {string} dataCollectionSetId 
         * @param {UpdateDataCollectionSetDataCollectionRequestBody} updateDataCollectionSetDataCollectionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetsPutDataCollections(dataCollectionSetId: string, updateDataCollectionSetDataCollectionRequestBody: UpdateDataCollectionSetDataCollectionRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetsPutDataCollections(dataCollectionSetId, updateDataCollectionSetDataCollectionRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Data Collection Sets
         * @param {string} objectId 
         * @param {DataCollectionSet} dataCollectionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetsPutOne(objectId: string, dataCollectionSet: DataCollectionSet, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataCollectionSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetsPutOne(objectId, dataCollectionSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Data Collection Sets
         * @param {Array<DataCollectionSet>} dataCollectionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetsPutSome(dataCollectionSet: Array<DataCollectionSet>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetsPutSome(dataCollectionSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a collection of data.
         * @summary Data Collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionsDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionsDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a collection of data.
         * @summary Data Collections
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionsDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionsDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a collection of data.
         * @summary Data Collections
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionsDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionsDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a collection of data.
         * @summary Data Collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionsGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollection>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionsGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a collection of data.
         * @summary Data Collections
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionsGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionsGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a collection of data.
         * @summary Data Collections
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionsGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollection>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionsGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a collection of data.
         * @summary Data Collections
         * @param {DataCollection} dataCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionsPostOne(dataCollection: DataCollection, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionsPostOne(dataCollection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a collection of data.
         * @summary Data Collections
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionsPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollection>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionsPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a collection of data.
         * @summary Data Collections
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionsPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionsPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a collection of data.
         * @summary Data Collections
         * @param {Array<DataCollection>} dataCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionsPostSome(dataCollection: Array<DataCollection>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollection>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionsPostSome(dataCollection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a collection of data.
         * @summary Data Collections
         * @param {string} objectId 
         * @param {DataCollection} dataCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionsPutOne(objectId: string, dataCollection: DataCollection, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionsPutOne(objectId, dataCollection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a collection of data.
         * @summary Data Collections
         * @param {Array<DataCollection>} dataCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionsPutSome(dataCollection: Array<DataCollection>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollection>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionsPutSome(dataCollection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
         * @summary Identifier Issuers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierIssuersDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierIssuersDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
         * @summary Identifier Issuers
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierIssuersDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierIssuersDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
         * @summary Identifier Issuers
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierIssuersDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierIssuersDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
         * @summary Identifier Issuers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierIssuersGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentifierIssuer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierIssuersGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
         * @summary Identifier Issuers
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierIssuersGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentifierIssuer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierIssuersGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
         * @summary Identifier Issuers
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierIssuersGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentifierIssuer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierIssuersGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
         * @summary Identifier Issuers
         * @param {IdentifierIssuer} identifierIssuer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierIssuersPostOne(identifierIssuer: IdentifierIssuer, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentifierIssuer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierIssuersPostOne(identifierIssuer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
         * @summary Identifier Issuers
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierIssuersPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentifierIssuer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierIssuersPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
         * @summary Identifier Issuers
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierIssuersPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierIssuersPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
         * @summary Identifier Issuers
         * @param {Array<IdentifierIssuer>} identifierIssuer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierIssuersPostSome(identifierIssuer: Array<IdentifierIssuer>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentifierIssuer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierIssuersPostSome(identifierIssuer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
         * @summary Identifier Issuers
         * @param {string} objectId 
         * @param {IdentifierIssuer} identifierIssuer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierIssuersPutOne(objectId: string, identifierIssuer: IdentifierIssuer, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentifierIssuer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierIssuersPutOne(objectId, identifierIssuer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
         * @summary Identifier Issuers
         * @param {Array<IdentifierIssuer>} identifierIssuer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierIssuersPutSome(identifierIssuer: Array<IdentifierIssuer>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentifierIssuer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierIssuersPutSome(identifierIssuer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Set Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetMembersDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetMembersDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Set Members
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetMembersDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetMembersDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Set Members
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetMembersDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetMembersDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Set Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetMembersGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetMembersGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Set Members
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetMembersGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetMembersGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Set Members
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetMembersGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetMembersGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Set Members
         * @param {OrganizationSetMember} organizationSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetMembersPostOne(organizationSetMember: OrganizationSetMember, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetMembersPostOne(organizationSetMember, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Set Members
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetMembersPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetMembersPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Set Members
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetMembersPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetMembersPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Set Members
         * @param {Array<OrganizationSetMember>} organizationSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetMembersPostSome(organizationSetMember: Array<OrganizationSetMember>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetMembersPostSome(organizationSetMember, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Set Members
         * @param {string} objectId 
         * @param {OrganizationSetMember} organizationSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetMembersPutOne(objectId: string, organizationSetMember: OrganizationSetMember, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetMembersPutOne(objectId, organizationSetMember, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Set Members
         * @param {Array<OrganizationSetMember>} organizationSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetMembersPutSome(organizationSetMember: Array<OrganizationSetMember>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetMembersPutSome(organizationSetMember, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetsDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetsDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Sets
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetsDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetsDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetsDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetsDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetsGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetsGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Sets
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetsGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetsGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Sets
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetsGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetsGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Sets
         * @param {OrganizationSet} organizationSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetsPostOne(organizationSet: OrganizationSet, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetsPostOne(organizationSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetsPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetsPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Sets
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetsPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetsPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Sets
         * @param {Array<OrganizationSet>} organizationSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetsPostSome(organizationSet: Array<OrganizationSet>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetsPostSome(organizationSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Sets
         * @param {string} objectId 
         * @param {OrganizationSet} organizationSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetsPutOne(objectId: string, organizationSet: OrganizationSet, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetsPutOne(objectId, organizationSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organizationset Organization
         * @param {string} organizationSetId 
         * @param {UpdateOrganizationSetOrganizationRequestBody} updateOrganizationSetOrganizationRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetsPutOrganizations(organizationSetId: string, updateOrganizationSetOrganizationRequestBody: UpdateOrganizationSetOrganizationRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetsPutOrganizations(organizationSetId, updateOrganizationSetOrganizationRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Organization Sets
         * @param {Array<OrganizationSet>} organizationSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetsPutSome(organizationSet: Array<OrganizationSet>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetsPutSome(organizationSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents an organization.
         * @summary Organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents an organization.
         * @summary Organizations
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents an organization.
         * @summary Organizations
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents an organization.
         * @summary Organizations
         * @param {Organization} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsPostOne(organization: Organization, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsPostOne(organization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents an organization.
         * @summary Organizations
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents an organization.
         * @summary Organizations
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents an organization.
         * @summary Organizations
         * @param {Array<Organization>} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsPostSome(organization: Array<Organization>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsPostSome(organization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents an organization.
         * @summary Organizations
         * @param {string} objectId 
         * @param {Organization} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsPutOne(objectId: string, organization: Organization, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsPutOne(objectId, organization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents an organization.
         * @summary Organizations
         * @param {Array<Organization>} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsPutSome(organization: Array<Organization>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsPutSome(organization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Retrieveorganizationadminnameemailscommand
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveOrganizationAdminNameEmails(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserNameEmail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveOrganizationAdminNameEmails(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a physical site of an organization.
         * @summary Sites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a physical site of an organization.
         * @summary Sites
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a physical site of an organization.
         * @summary Sites
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a physical site of an organization.
         * @summary Sites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Site>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a physical site of an organization.
         * @summary Sites
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a physical site of an organization.
         * @summary Sites
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Site>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a physical site of an organization.
         * @summary Sites
         * @param {Site} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesPostOne(site: Site, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesPostOne(site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a physical site of an organization.
         * @summary Sites
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Site>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a physical site of an organization.
         * @summary Sites
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a physical site of an organization.
         * @summary Sites
         * @param {Array<Site>} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesPostSome(site: Array<Site>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Site>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesPostSome(site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a physical site of an organization.
         * @summary Sites
         * @param {string} objectId 
         * @param {Site} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesPutOne(objectId: string, site: Site, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesPutOne(objectId, site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a physical site of an organization.
         * @summary Sites
         * @param {Array<Site>} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesPutSome(site: Array<Site>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Site>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesPutSome(site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Updateuserownorganization
         * @param {UpdateUserOwnOrganizationRequestBody} updateUserOwnOrganizationRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserOwnOrganization(updateUserOwnOrganizationRequestBody: UpdateUserOwnOrganizationRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserOwnOrganization(updateUserOwnOrganizationRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary User Invitations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInvitationsDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInvitationsDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary User Invitations
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInvitationsDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInvitationsDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary User Invitations
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInvitationsDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInvitationsDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary User Invitations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInvitationsGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInvitation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInvitationsGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary User Invitations
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInvitationsGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInvitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInvitationsGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary User Invitations
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInvitationsGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInvitation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInvitationsGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary User Invitations
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInvitationsPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInvitation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInvitationsPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary User Invitations
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInvitationsPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInvitationsPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Userme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userMeGetOne(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompleteUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userMeGetOne(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Users
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Users
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Users
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Users
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Updateuser
         * @param {string} objectId 
         * @param {UpdateUserRequestBody} updateUserRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPutOne(objectId: string, updateUserRequestBody: UpdateUserRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPutOne(objectId, updateUserRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */

/**
 * OrganizationApi - object-oriented interface

 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
  public static instance: OrganizationApi;
  public static getInstance(): OrganizationApi {
    this.instance = this.instance || new OrganizationApi();
    return this.instance;
  }

    /**
     * A class representing contact information for an organization.
     * @summary Contacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public contactsDeleteAll(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).contactsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A class representing contact information for an organization.
     * @summary Contacts
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public contactsDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).contactsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A class representing contact information for an organization.
     * @summary Contacts
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public contactsDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).contactsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A class representing contact information for an organization.
     * @summary Contacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public contactsGetAll(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).contactsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A class representing contact information for an organization.
     * @summary Contacts
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public contactsGetOne(objectId: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).contactsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A class representing contact information for an organization.
     * @summary Contacts
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public contactsGetSome(ids: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).contactsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A class representing contact information for an organization.
     * @summary Contacts
     * @param {Contact} contact 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public contactsPostOne(contact: Contact, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).contactsPostOne(contact, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A class representing contact information for an organization.
     * @summary Contacts
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public contactsPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).contactsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A class representing contact information for an organization.
     * @summary Contacts
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public contactsPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).contactsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A class representing contact information for an organization.
     * @summary Contacts
     * @param {Array<Contact>} contact 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public contactsPostSome(contact: Array<Contact>, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).contactsPostSome(contact, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A class representing contact information for an organization.
     * @summary Contacts
     * @param {string} objectId 
     * @param {Contact} contact 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public contactsPutOne(objectId: string, contact: Contact, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).contactsPutOne(objectId, contact, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A class representing contact information for an organization.
     * @summary Contacts
     * @param {Array<Contact>} contact 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public contactsPutSome(contact: Array<Contact>, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).contactsPutSome(contact, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a directional relationship between two data collections.
     * @summary Data Collection Relations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionRelationsDeleteAll(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionRelationsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a directional relationship between two data collections.
     * @summary Data Collection Relations
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionRelationsDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionRelationsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a directional relationship between two data collections.
     * @summary Data Collection Relations
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionRelationsDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionRelationsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a directional relationship between two data collections.
     * @summary Data Collection Relations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionRelationsGetAll(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionRelationsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a directional relationship between two data collections.
     * @summary Data Collection Relations
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionRelationsGetOne(objectId: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionRelationsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a directional relationship between two data collections.
     * @summary Data Collection Relations
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionRelationsGetSome(ids: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionRelationsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a directional relationship between two data collections.
     * @summary Data Collection Relations
     * @param {DataCollectionRelation} dataCollectionRelation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionRelationsPostOne(dataCollectionRelation: DataCollectionRelation, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionRelationsPostOne(dataCollectionRelation, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a directional relationship between two data collections.
     * @summary Data Collection Relations
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionRelationsPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionRelationsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a directional relationship between two data collections.
     * @summary Data Collection Relations
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionRelationsPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionRelationsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a directional relationship between two data collections.
     * @summary Data Collection Relations
     * @param {Array<DataCollectionRelation>} dataCollectionRelation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionRelationsPostSome(dataCollectionRelation: Array<DataCollectionRelation>, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionRelationsPostSome(dataCollectionRelation, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a directional relationship between two data collections.
     * @summary Data Collection Relations
     * @param {string} objectId 
     * @param {DataCollectionRelation} dataCollectionRelation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionRelationsPutOne(objectId: string, dataCollectionRelation: DataCollectionRelation, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionRelationsPutOne(objectId, dataCollectionRelation, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a directional relationship between two data collections.
     * @summary Data Collection Relations
     * @param {Array<DataCollectionRelation>} dataCollectionRelation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionRelationsPutSome(dataCollectionRelation: Array<DataCollectionRelation>, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionRelationsPutSome(dataCollectionRelation, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Set Members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetMembersDeleteAll(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetMembersDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Set Members
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetMembersDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetMembersDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Set Members
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetMembersDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetMembersDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Set Members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetMembersGetAll(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetMembersGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Set Members
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetMembersGetOne(objectId: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetMembersGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Set Members
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetMembersGetSome(ids: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetMembersGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Set Members
     * @param {DataCollectionSetMember} dataCollectionSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetMembersPostOne(dataCollectionSetMember: DataCollectionSetMember, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetMembersPostOne(dataCollectionSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Set Members
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetMembersPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetMembersPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Set Members
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetMembersPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetMembersPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Set Members
     * @param {Array<DataCollectionSetMember>} dataCollectionSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetMembersPostSome(dataCollectionSetMember: Array<DataCollectionSetMember>, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetMembersPostSome(dataCollectionSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Set Members
     * @param {string} objectId 
     * @param {DataCollectionSetMember} dataCollectionSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetMembersPutOne(objectId: string, dataCollectionSetMember: DataCollectionSetMember, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetMembersPutOne(objectId, dataCollectionSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Set Members
     * @param {Array<DataCollectionSetMember>} dataCollectionSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetMembersPutSome(dataCollectionSetMember: Array<DataCollectionSetMember>, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetMembersPutSome(dataCollectionSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Sets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetsDeleteAll(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Sets
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetsDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Sets
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetsDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Sets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetsGetAll(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Sets
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetsGetOne(objectId: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Sets
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetsGetSome(ids: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Sets
     * @param {DataCollectionSet} dataCollectionSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetsPostOne(dataCollectionSet: DataCollectionSet, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetsPostOne(dataCollectionSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Sets
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetsPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Sets
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetsPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Sets
     * @param {Array<DataCollectionSet>} dataCollectionSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetsPostSome(dataCollectionSet: Array<DataCollectionSet>, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetsPostSome(dataCollectionSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Datacollectionset Datacollection
     * @param {string} dataCollectionSetId 
     * @param {UpdateDataCollectionSetDataCollectionRequestBody} updateDataCollectionSetDataCollectionRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetsPutDataCollections(dataCollectionSetId: string, updateDataCollectionSetDataCollectionRequestBody: UpdateDataCollectionSetDataCollectionRequestBody, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetsPutDataCollections(dataCollectionSetId, updateDataCollectionSetDataCollectionRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Sets
     * @param {string} objectId 
     * @param {DataCollectionSet} dataCollectionSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetsPutOne(objectId: string, dataCollectionSet: DataCollectionSet, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetsPutOne(objectId, dataCollectionSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Sets
     * @param {Array<DataCollectionSet>} dataCollectionSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetsPutSome(dataCollectionSet: Array<DataCollectionSet>, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetsPutSome(dataCollectionSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a collection of data.
     * @summary Data Collections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionsDeleteAll(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a collection of data.
     * @summary Data Collections
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionsDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a collection of data.
     * @summary Data Collections
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionsDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a collection of data.
     * @summary Data Collections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionsGetAll(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a collection of data.
     * @summary Data Collections
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionsGetOne(objectId: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a collection of data.
     * @summary Data Collections
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionsGetSome(ids: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a collection of data.
     * @summary Data Collections
     * @param {DataCollection} dataCollection 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionsPostOne(dataCollection: DataCollection, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionsPostOne(dataCollection, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a collection of data.
     * @summary Data Collections
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionsPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a collection of data.
     * @summary Data Collections
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionsPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a collection of data.
     * @summary Data Collections
     * @param {Array<DataCollection>} dataCollection 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionsPostSome(dataCollection: Array<DataCollection>, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionsPostSome(dataCollection, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a collection of data.
     * @summary Data Collections
     * @param {string} objectId 
     * @param {DataCollection} dataCollection 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionsPutOne(objectId: string, dataCollection: DataCollection, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionsPutOne(objectId, dataCollection, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a collection of data.
     * @summary Data Collections
     * @param {Array<DataCollection>} dataCollection 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionsPutSome(dataCollection: Array<DataCollection>, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionsPutSome(dataCollection, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
     * @summary Identifier Issuers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public identifierIssuersDeleteAll(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).identifierIssuersDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
     * @summary Identifier Issuers
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public identifierIssuersDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).identifierIssuersDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
     * @summary Identifier Issuers
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public identifierIssuersDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).identifierIssuersDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
     * @summary Identifier Issuers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public identifierIssuersGetAll(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).identifierIssuersGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
     * @summary Identifier Issuers
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public identifierIssuersGetOne(objectId: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).identifierIssuersGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
     * @summary Identifier Issuers
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public identifierIssuersGetSome(ids: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).identifierIssuersGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
     * @summary Identifier Issuers
     * @param {IdentifierIssuer} identifierIssuer 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public identifierIssuersPostOne(identifierIssuer: IdentifierIssuer, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).identifierIssuersPostOne(identifierIssuer, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
     * @summary Identifier Issuers
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public identifierIssuersPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).identifierIssuersPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
     * @summary Identifier Issuers
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public identifierIssuersPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).identifierIssuersPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
     * @summary Identifier Issuers
     * @param {Array<IdentifierIssuer>} identifierIssuer 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public identifierIssuersPostSome(identifierIssuer: Array<IdentifierIssuer>, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).identifierIssuersPostSome(identifierIssuer, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
     * @summary Identifier Issuers
     * @param {string} objectId 
     * @param {IdentifierIssuer} identifierIssuer 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public identifierIssuersPutOne(objectId: string, identifierIssuer: IdentifierIssuer, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).identifierIssuersPutOne(objectId, identifierIssuer, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * A system or process that issues identifiers.     The combination (identifier_issuer, issued_identifier) is universally unique.
     * @summary Identifier Issuers
     * @param {Array<IdentifierIssuer>} identifierIssuer 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public identifierIssuersPutSome(identifierIssuer: Array<IdentifierIssuer>, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).identifierIssuersPutSome(identifierIssuer, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Set Members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetMembersDeleteAll(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetMembersDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Set Members
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetMembersDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetMembersDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Set Members
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetMembersDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetMembersDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Set Members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetMembersGetAll(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetMembersGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Set Members
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetMembersGetOne(objectId: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetMembersGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Set Members
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetMembersGetSome(ids: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetMembersGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Set Members
     * @param {OrganizationSetMember} organizationSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetMembersPostOne(organizationSetMember: OrganizationSetMember, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetMembersPostOne(organizationSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Set Members
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetMembersPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetMembersPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Set Members
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetMembersPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetMembersPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Set Members
     * @param {Array<OrganizationSetMember>} organizationSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetMembersPostSome(organizationSetMember: Array<OrganizationSetMember>, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetMembersPostSome(organizationSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Set Members
     * @param {string} objectId 
     * @param {OrganizationSetMember} organizationSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetMembersPutOne(objectId: string, organizationSetMember: OrganizationSetMember, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetMembersPutOne(objectId, organizationSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Set Members
     * @param {Array<OrganizationSetMember>} organizationSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetMembersPutSome(organizationSetMember: Array<OrganizationSetMember>, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetMembersPutSome(organizationSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Sets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetsDeleteAll(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Sets
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetsDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Sets
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetsDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Sets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetsGetAll(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Sets
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetsGetOne(objectId: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Sets
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetsGetSome(ids: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Sets
     * @param {OrganizationSet} organizationSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetsPostOne(organizationSet: OrganizationSet, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetsPostOne(organizationSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Sets
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetsPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Sets
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetsPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Sets
     * @param {Array<OrganizationSet>} organizationSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetsPostSome(organizationSet: Array<OrganizationSet>, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetsPostSome(organizationSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Sets
     * @param {string} objectId 
     * @param {OrganizationSet} organizationSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetsPutOne(objectId: string, organizationSet: OrganizationSet, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetsPutOne(objectId, organizationSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organizationset Organization
     * @param {string} organizationSetId 
     * @param {UpdateOrganizationSetOrganizationRequestBody} updateOrganizationSetOrganizationRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetsPutOrganizations(organizationSetId: string, updateOrganizationSetOrganizationRequestBody: UpdateOrganizationSetOrganizationRequestBody, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetsPutOrganizations(organizationSetId, updateOrganizationSetOrganizationRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Sets
     * @param {Array<OrganizationSet>} organizationSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetsPutSome(organizationSet: Array<OrganizationSet>, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetsPutSome(organizationSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents an organization.
     * @summary Organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationsGetAll(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents an organization.
     * @summary Organizations
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationsGetOne(objectId: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents an organization.
     * @summary Organizations
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationsGetSome(ids: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents an organization.
     * @summary Organizations
     * @param {Organization} organization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationsPostOne(organization: Organization, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationsPostOne(organization, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents an organization.
     * @summary Organizations
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationsPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents an organization.
     * @summary Organizations
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationsPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents an organization.
     * @summary Organizations
     * @param {Array<Organization>} organization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationsPostSome(organization: Array<Organization>, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationsPostSome(organization, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents an organization.
     * @summary Organizations
     * @param {string} objectId 
     * @param {Organization} organization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationsPutOne(objectId: string, organization: Organization, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationsPutOne(objectId, organization, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents an organization.
     * @summary Organizations
     * @param {Array<Organization>} organization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationsPutSome(organization: Array<Organization>, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationsPutSome(organization, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Retrieveorganizationadminnameemailscommand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public retrieveOrganizationAdminNameEmails(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).retrieveOrganizationAdminNameEmails(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a physical site of an organization.
     * @summary Sites
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public sitesDeleteAll(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).sitesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a physical site of an organization.
     * @summary Sites
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public sitesDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).sitesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a physical site of an organization.
     * @summary Sites
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public sitesDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).sitesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a physical site of an organization.
     * @summary Sites
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public sitesGetAll(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).sitesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a physical site of an organization.
     * @summary Sites
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public sitesGetOne(objectId: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).sitesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a physical site of an organization.
     * @summary Sites
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public sitesGetSome(ids: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).sitesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a physical site of an organization.
     * @summary Sites
     * @param {Site} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public sitesPostOne(site: Site, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).sitesPostOne(site, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a physical site of an organization.
     * @summary Sites
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public sitesPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).sitesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a physical site of an organization.
     * @summary Sites
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public sitesPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).sitesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a physical site of an organization.
     * @summary Sites
     * @param {Array<Site>} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public sitesPostSome(site: Array<Site>, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).sitesPostSome(site, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a physical site of an organization.
     * @summary Sites
     * @param {string} objectId 
     * @param {Site} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public sitesPutOne(objectId: string, site: Site, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).sitesPutOne(objectId, site, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a physical site of an organization.
     * @summary Sites
     * @param {Array<Site>} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public sitesPutSome(site: Array<Site>, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).sitesPutSome(site, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Updateuserownorganization
     * @param {UpdateUserOwnOrganizationRequestBody} updateUserOwnOrganizationRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateUserOwnOrganization(updateUserOwnOrganizationRequestBody: UpdateUserOwnOrganizationRequestBody, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateUserOwnOrganization(updateUserOwnOrganizationRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Invitations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public userInvitationsDeleteAll(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).userInvitationsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Invitations
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public userInvitationsDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).userInvitationsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Invitations
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public userInvitationsDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).userInvitationsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Invitations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public userInvitationsGetAll(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).userInvitationsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Invitations
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public userInvitationsGetOne(objectId: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).userInvitationsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Invitations
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public userInvitationsGetSome(ids: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).userInvitationsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Invitations
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public userInvitationsPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).userInvitationsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Invitations
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public userInvitationsPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).userInvitationsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Userme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public userMeGetOne(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).userMeGetOne(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public usersGetAll(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).usersGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Users
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public usersGetOne(objectId: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).usersGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Users
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public usersGetSome(ids: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).usersGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Users
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public usersPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).usersPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Users
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public usersPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).usersPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Updateuser
     * @param {string} objectId 
     * @param {UpdateUserRequestBody} updateUserRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public usersPutOne(objectId: string, updateUserRequestBody: UpdateUserRequestBody, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).usersPutOne(objectId, updateUserRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }
}



/**
 * SystemApi - axios parameter creator
 * @export
 */
const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Log
         * @param {LogRequestBody} logRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        log: async (logRequestBody: LogRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logRequestBody' is not null or undefined
            assertParamExists('log', 'logRequestBody', logRequestBody)
            const localVarPath = `/v1/log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a system outage.
         * @summary Outages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outagesDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/outages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a system outage.
         * @summary Outages
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outagesDeleteOne: async (objectId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('outagesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/outages/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a system outage.
         * @summary Outages
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outagesDeleteSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('outagesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/outages/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a system outage.
         * @summary Outages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outagesGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/outages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a system outage.
         * @summary Outages
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outagesGetOne: async (objectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('outagesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/outages/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a system outage.
         * @summary Outages
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outagesGetSome: async (ids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('outagesGetSome', 'ids', ids)
            const localVarPath = `/v1/outages/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a system outage.
         * @summary Outages
         * @param {Outage} outage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outagesPostOne: async (outage: Outage, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'outage' is not null or undefined
            assertParamExists('outagesPostOne', 'outage', outage)
            const localVarPath = `/v1/outages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(outage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a system outage.
         * @summary Outages
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outagesPostQuery: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('outagesPostQuery', 'filter', filter)
            const localVarPath = `/v1/outages/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a system outage.
         * @summary Outages
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outagesPostQueryIds: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('outagesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/outages/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a system outage.
         * @summary Outages
         * @param {Array<Outage>} outage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outagesPostSome: async (outage: Array<Outage>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'outage' is not null or undefined
            assertParamExists('outagesPostSome', 'outage', outage)
            const localVarPath = `/v1/outages/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(outage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a system outage.
         * @summary Outages
         * @param {string} objectId 
         * @param {Outage} outage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outagesPutOne: async (objectId: string, outage: Outage, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('outagesPutOne', 'objectId', objectId)
            // verify required parameter 'outage' is not null or undefined
            assertParamExists('outagesPutOne', 'outage', outage)
            const localVarPath = `/v1/outages/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(outage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents a system outage.
         * @summary Outages
         * @param {Array<Outage>} outage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outagesPutSome: async (outage: Array<Outage>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'outage' is not null or undefined
            assertParamExists('outagesPutSome', 'outage', outage)
            const localVarPath = `/v1/outages/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(outage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Outages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveOutages: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/retrieve/outages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
const SystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async health(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthReponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.health(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Log
         * @param {LogRequestBody} logRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async log(logRequestBody: LogRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.log(logRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a system outage.
         * @summary Outages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outagesDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.outagesDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a system outage.
         * @summary Outages
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outagesDeleteOne(objectId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.outagesDeleteOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a system outage.
         * @summary Outages
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outagesDeleteSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.outagesDeleteSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a system outage.
         * @summary Outages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outagesGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Outage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.outagesGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a system outage.
         * @summary Outages
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outagesGetOne(objectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Outage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.outagesGetOne(objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a system outage.
         * @summary Outages
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outagesGetSome(ids: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Outage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.outagesGetSome(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a system outage.
         * @summary Outages
         * @param {Outage} outage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outagesPostOne(outage: Outage, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Outage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.outagesPostOne(outage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a system outage.
         * @summary Outages
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outagesPostQuery(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Outage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.outagesPostQuery(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a system outage.
         * @summary Outages
         * @param {Filter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outagesPostQueryIds(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.outagesPostQueryIds(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a system outage.
         * @summary Outages
         * @param {Array<Outage>} outage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outagesPostSome(outage: Array<Outage>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Outage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.outagesPostSome(outage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a system outage.
         * @summary Outages
         * @param {string} objectId 
         * @param {Outage} outage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outagesPutOne(objectId: string, outage: Outage, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Outage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.outagesPutOne(objectId, outage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * Represents a system outage.
         * @summary Outages
         * @param {Array<Outage>} outage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outagesPutSome(outage: Array<Outage>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Outage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.outagesPutSome(outage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary Outages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveOutages(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Outage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveOutages(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */

/**
 * SystemApi - object-oriented interface

 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
  public static instance: SystemApi;
  public static getInstance(): SystemApi {
    this.instance = this.instance || new SystemApi();
    return this.instance;
  }

    /**
     * 
     * @summary Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public health(options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).health(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Log
     * @param {LogRequestBody} logRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public log(logRequestBody: LogRequestBody, options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).log(logRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a system outage.
     * @summary Outages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public outagesDeleteAll(options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).outagesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a system outage.
     * @summary Outages
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public outagesDeleteOne(objectId: any, options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).outagesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a system outage.
     * @summary Outages
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public outagesDeleteSome(ids: string, options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).outagesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a system outage.
     * @summary Outages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public outagesGetAll(options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).outagesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a system outage.
     * @summary Outages
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public outagesGetOne(objectId: string, options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).outagesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a system outage.
     * @summary Outages
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public outagesGetSome(ids: string, options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).outagesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a system outage.
     * @summary Outages
     * @param {Outage} outage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public outagesPostOne(outage: Outage, options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).outagesPostOne(outage, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a system outage.
     * @summary Outages
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public outagesPostQuery(filter: Filter, options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).outagesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a system outage.
     * @summary Outages
     * @param {Filter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public outagesPostQueryIds(filter: Filter, options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).outagesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a system outage.
     * @summary Outages
     * @param {Array<Outage>} outage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public outagesPostSome(outage: Array<Outage>, options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).outagesPostSome(outage, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a system outage.
     * @summary Outages
     * @param {string} objectId 
     * @param {Outage} outage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public outagesPutOne(objectId: string, outage: Outage, options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).outagesPutOne(objectId, outage, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Represents a system outage.
     * @summary Outages
     * @param {Array<Outage>} outage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public outagesPutSome(outage: Array<Outage>, options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).outagesPutSome(outage, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Outages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public retrieveOutages(options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).retrieveOutages(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }
}



